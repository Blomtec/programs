//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "X_Axle_Correction"
	Revision           = "0.0"
	GUID               = "{1A6EFA18-8799-4593-A0B9-37F22DE6802D}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(750,120)">
	<Channels>
		<Server Name="CorrectionMM" GUID="{73653C77-F458-4272-A3F4-57CE72122634}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="StationNbr" GUID="{544B8B45-AE30-4E99-9716-61E0E662AE5B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="X_Axle_Error" GUID="{92198C78-E8A3-43EF-9834-D4F881EA934C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="X_Axle_State" GUID="{8DD98A68-46BB-4572-A32F-C9FC1D9932EC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="Comm_Next" Required="false" Internal="false"/>
		<Client Name="iFc_Trigger" Required="true" Internal="false"/>
		<Client Name="Standard3" Required="true" Internal="true"/>
		<Client Name="Virtual_Axle" Required="true" Internal="false"/>
		<Client Name="X_Axle" Required="true" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="4"/>
			<SepChn Position="0"/>
		</Servers>
	</Separators>
	<Network Name="X_Axle_Correction">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{75D5F85F-08BA-475C-BAEC-151951423897}"
				Class      = "MachineBase"
				Position   = "(324,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ObjectServer"/>
					<Server Name="RunningMode"/>
					<Server Name="Stepper"/>
				</Channels>
			</Object>
			<Object
				Name           = "Standard3"
				GUID           = "{4B6C2691-DC7B-4A87-9E9E-B09D4A99B94F}"
				Class          = "Standard"
				Position       = "(270,420)"
				Visualized     = "false"
				BackgroundTime = "1000 ms">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Standard3" Destination="Standard3.ClassSvr"/>
			<Connection Source="this.ObjectServer" Destination="_base.ObjectServer" Vertices="(1112,210),(940,210),"/>
			<Connection Source="this.Stepper" Destination="_base.Stepper" Vertices="(1112,270),(940,270),"/>
			<Connection Source="this.RunningMode" Destination="_base.RunningMode" Vertices="(1112,330),(940,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using MachineBase

X_Axle_Correction : CLASS
: MachineBase
  //Servers:
	StationNbr 	: SvrCh_DINT;
	X_Axle_State 	: SvrCh__LMCAXIS_STATUS;
	X_Axle_Error 	: SvrCh__LMCAXIS_ERROR;
	CorrectionMM 	: SvrCh_DINT;
  //Clients:
	iFc_Trigger 	: CltChCmd_ProductTriggerCamera;
	Virtual_Axle 	: CltChCmd__LMCAxis;
	X_Axle 	: CltChCmd__LMCAxis;
	Comm_Next 	: CltChCmd_X_Axle_Correction;
	Standard3 	: CltChCmd_Standard;
  //Variables:
		CalcAccDec 	: DINT;
		CalcSpeed 	: DINT;
		CameraPtr 	: ^StrCameraData;
		CalcLineSpeed 	: DINT;
		OldCleaningMode 	: OptiesEnum;
		CleaningSpeedOld 	: DINT;
		CalcCleaningSpeed 	: DINT;
		CalcCleaningAccDec 	: DINT;
		CleaningJogDistance 	: DINT;
		OldCalcLineSpeed 	: DINT;
		TriggerInfo 	: ProductTriggerCamera::OutInfoStr;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL MyInit;
	
	FUNCTION VIRTUAL GLOBAL MyCyTask;
	
	FUNCTION GLOBAL SetStationNbr
		VAR_INPUT
			Nbr 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ChangePos
		VAR_INPUT
			Position 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Standard
#pragma usingLtd _LMCAxis
#pragma usingLtd ProductTriggerCamera


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB X_Axle_Correction::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_X_AXLE_CORRECTION
0$UINT, 0$UINT, (SIZEOF(::X_Axle_Correction))$UINT, 
4$UINT, 5$UINT, 0$UINT, 
TO_UDINT(1781566825), "X_Axle_Correction", //Class
TO_UDINT(3119722310), "MachineBase", 0$UINT, 0$UINT, //Baseclass
//Servers:
(::X_Axle_Correction.StationNbr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(413879351), "StationNbr", 
(::X_Axle_Correction.X_Axle_State.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(355114119), "X_Axle_State", 
(::X_Axle_Correction.X_Axle_Error.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3949261325), "X_Axle_Error", 
(::X_Axle_Correction.CorrectionMM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3128313523), "CorrectionMM", 
//Clients:
(::X_Axle_Correction.iFc_Trigger.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2256343536), "iFc_Trigger", TO_UDINT(410707856), "ProductTriggerCamera", 0$UINT, 0$UINT, 
(::X_Axle_Correction.Virtual_Axle.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2983705794), "Virtual_Axle", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 73$UINT, 
(::X_Axle_Correction.X_Axle.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4028728933), "X_Axle", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 73$UINT, 
(::X_Axle_Correction.Comm_Next.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3456928936), "Comm_Next", TO_UDINT(1781566825), "X_Axle_Correction", 0$UINT, 0$UINT, 
(::X_Axle_Correction.Standard3.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1639076328), "Standard3", TO_UDINT(3603188683), "Standard", 6$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_X_Axle_Correction 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_X_Axle_Correction] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION X_Axle_Correction::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= MachineBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= MachineBase::ObjectServer.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, MachineBase::ObjectServer.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_X_Axle_Correction;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #MyInit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #MyCyTask();

#pragma warning (default : 74)
	MachineBase::ObjectServer.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF MachineBase::ObjectServer.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION GLOBAL X_Axle_Correction::MyInit
  
  // Set another inits
  if IsClientConnected(#Comm_Next) then
    Comm_Next.InitTask(SetGlobalPtr:= GlobalDataPtr, SetRecipePtr:= RecipePtr);
  end_if;

END_FUNCTION

FUNCTION GLOBAL X_Axle_Correction::MyCyTask
  
  // Set another CyTasks
  if IsClientConnected(#Comm_Next) then
    Comm_Next.CyTask();
  end_if;

  // Read Axle States
  X_Axle_State       := X_Axle.ReadAxisStatus();
  X_Axle_Error       := X_Axle.ReadAxisError();
  
  
  // Calculations
  CalcSpeed          := to_dint(to_real RecipePtr^.X_Axle.Speed ToMMperSec);
  CalcAccDec         := to_dint(to_real RecipePtr^.X_Axle.AccDec ToMMperSec);

  // Set Trigger info
  TriggerInfo        := iFc_Trigger.OffsetTrigger();


  // check for errors
  if GlobalDataPtr^.gGeneralData.NoError = 0 | GlobalDataPtr^.gGeneralData.iNoodstopOk = 0
    | GlobalDataPtr^.gRunStatus.gRunStatusGlob = eNoodstopStatus | GlobalDataPtr^.gRunStatus.gRunStatusGlob = eErrorStatus then
    if Stepper < 100 | Stepper >= 200 then
      Stepper := 100;
    end_if;
  end_if;


  case Stepper of
  00:// start
    if GlobalDataPtr^.gRunStatus.gRunStatusGlob = eRunStatus | GlobalDataPtr^.gRunStatus.gRunStatusGlob = eStartUpStatus
      | GlobalDataPtr^.gRunStatus.gRunStatusGlob = eCleaningStatus | GlobalDataPtr^.gRunStatus.gRunStatusGlob = ePauseStatus then
      if GlobalDataPtr^.gGeneralData.iDrivesOK = 1 then 
        Stepper += 1;
      end_if;  
    end_if;
    
  01: 
    if GlobalDataPtr^.gGeneralData.iDrivesEnabled = 0 then  // Axles enabled??
      if X_Axle_State.PowerOn = 0 then
        X_Axle.PowerOn(Mode:= LMCAXIS_MOVE_ANY_WAY);
      end_if;
    else
      Stepper += 1;
    end_if;
  
  02: // What do we choose?
    GlobalDataPtr^.gRunStatus.gRunStatusXaxles[StationNbr] := GlobalDataPtr^.gRunStatus.gRunStatusGlob;
    if GlobalDataPtr^.gRunStatus.gRunStatusGlob = eStartUpStatus | GlobalDataPtr^.gRunStatus.gRunStatusGlob = eRunStatus
      | GlobalDataPtr^.gRunStatus.gRunStatusGlob = ePauseStatus then
      Stepper := 20;
    elsif GlobalDataPtr^.gRunStatus.gRunStatusGlob = eCleaningStatus then
      Stepper := 200;
    end_if; 


  //--------------------------------       
  20: // Reset positions of Axle
    X_Axle.SetPosition(Mode:=::_LMCAXIS_SETPOSITION::LMCAXIS_SET_ACTPOS_INTUNIT, Position:= 0);
    Stepper += 1;

  21: // Couple Axles to Virtual axle
    if X_Axle_State.DelayedMasterLock = false then
      X_Axle.CoupleGearAbsolute(MaxVel:= X_Axle.ReadParameter(ParNr:=::_LMCAXIS_READPARAMETER::LMCAXIS_PAR_RD_V_MAX, mode:= 0), 
                                MaxAcc:= CalcAccDec, 
                                DeltaPos:= 0, 
                                pMaster:= Virtual_Axle.ReadMasterInfo(), 
                                GearMul:= 1, 
                                GearDiv:= 1);   
    else
      Stepper += 1;
    end_if;
    
  22: // Check for runstatus
    GlobalDataPtr^.gRunStatus.gRunStatusXaxles[StationNbr] := GlobalDataPtr^.gRunStatus.gRunStatusGlob;
    if GlobalDataPtr^.gRunStatus.gRunStatusGlob = eStartUpStatus | GlobalDataPtr^.gRunStatus.gRunStatusGlob = eRunStatus
      | GlobalDataPtr^.gRunStatus.gRunStatusGlob = ePauseStatus then
      Stepper := 20;
    elsif GlobalDataPtr^.gRunStatus.gRunStatusGlob = eCleaningStatus then
      Stepper := 200;
    end_if; 
  
  
  //--------------------------------   
  40: // Set Line Speed
    GlobalDataPtr^.gRunStatus.gRunStatusXaxles[StationNbr] := eRunStatus;
    Virtual_Axle.MoveEndless(Speed:= CalcLineSpeed, Accel:= CalcAccDec);
    OldCalcLineSpeed := CalcLineSpeed;
    Stepper += 1;
  
  41: // Check for position difference
    if GlobalDataPtr^.gRunStatus.gRunStatusGlob <> eRunStatus & GlobalDataPtr^.gRunStatus.gRunStatusGlob <> ePauseStatus then
      Stepper := 100;  
    elsif Standard3.R_TRIG(CLK:= TriggerInfo.TriggerState) = True then
      CorrectionMM += TriggerInfo.CameraData[StationNbr].Xposition;
      ChangePos(Position:= (CorrectionMM * 1000));  
    elsif OldCalcLineSpeed <> CalcLineSpeed then
      Stepper -= 1;
    end_if;
    
    
  //--------------------------------  
  100: // assen stopzetten en uitzetten
    GlobalDataPtr^.gRunStatus.gRunStatusXaxles[StationNbr] := eStopStatus;
    if X_Axle_State.PowerOn = 1 then
      X_Axle.PowerOff(Mode:= LMCAXIS_IMMEDIATE_STOPP);
    else
      Stepper += 1;
    end_if;
    
  101:
    GlobalDataPtr^.gRunStatus.gRunStatusXaxles[StationNbr] := eDriveOffStatus;
    if GlobalDataPtr^.gGeneralData.NoError = 1 & GlobalDataPtr^.gGeneralData.iNoodstopOk = 1 then
      Stepper := 0;
    end_if;
    
    
  //-------------------------------- 
  200: // Cleaning
    GlobalDataPtr^.gRunStatus.gRunStatusXaxles[StationNbr] := eCleaningStatus; 
    OldCleaningMode := GlobalDataPtr^.gGeneralData.CleaningJogOption; 
    if GlobalDataPtr^.gGeneralData.CleaningJogOption = Actief then
      Stepper := 205;
    else
      Stepper += 1;
    end_if;

  201: // Cleaning endless //
    X_Axle.MoveEndless(Speed:= CalcCleaningSpeed, Accel:= CalcCleaningAccDec);
    CleaningSpeedOld   := CalcCleaningSpeed;
    Stepper += 1;
    
  202:
    if GlobalDataPtr^.gRunStatus.gRunStatusGlob <> eCleaningStatus then
      Stepper := 100;
    elsif OldCleaningMode <> GlobalDataPtr^.gGeneralData.CleaningJogOption then // Is cleaningOption different?
      X_Axle.StopMove(Decel:= CalcCleaningAccDec);
      Stepper := 200;
    elsif CalcCleaningSpeed <> CleaningSpeedOld then
      Stepper -= 1;
    end_if;    
  
  205: // Cleaning in jogmode (every time a step) //
    if GlobalDataPtr^.gRunStatus.gRunStatusGlob <> eCleaningStatus then
      Stepper := 100;
    elsif OldCleaningMode <> GlobalDataPtr^.gGeneralData.CleaningJogOption then // Is cleaningOption different?
      X_Axle.StopMove(Decel:= CalcCleaningAccDec);
      Stepper := 200;
    elsif GlobalDataPtr^.gGeneralData.CleaningJog = 1 then
      X_Axle.MoveRelative(Position:= CleaningJogDistance, 
                          Mode:= LMCAXIS_MOVE_RELATIVE_TO_POSITION, 
                          Speed:= CalcCleaningSpeed, 
                          Accel:= CalcCleaningAccDec, 
                          Decel:= CalcCleaningAccDec);
      Stepper += 1;
    end_if;
    
   206: 
    if GlobalDataPtr^.gRunStatus.gRunStatusGlob <> eCleaningStatus then
      Stepper := 100;
    elsif X_Axle.InPosition(Mode:= LMCAXIS_SETPOS_IN_WINDOW_APP_UNITS, PositionWindow:= 1000) then
      if GlobalDataPtr^.gGeneralData.CleaningJog = 0 then
        Stepper -= 1;
      end_if;
    end_if;
  
  end_case;


END_FUNCTION

FUNCTION GLOBAL X_Axle_Correction::SetStationNbr
	VAR_INPUT
		Nbr 	: DINT;
	END_VAR
  
  StationNbr := Nbr;
  
  // Set station nbr
  if IsClientConnected(#Comm_Next) then
    Comm_Next.SetStationNbr(Nbr:= StationNbr + 1);
  end_if;

END_FUNCTION

FUNCTION GLOBAL X_Axle_Correction::ChangePos
	VAR_INPUT
		Position 	: DINT;
	END_VAR
  
  X_Axle.ChangeCoupleSettings(MaxVel:= X_Axle.ReadParameter(ParNr:=::_LMCAXIS_READPARAMETER::LMCAXIS_PAR_RD_V_MAX, mode:= 0), 
                              MaxAcc:= CalcAccDec, 
                              DeltaPos:= Position, 
                              GearMul:= 1, 
                              GearDiv:= 1);
  
END_FUNCTION
