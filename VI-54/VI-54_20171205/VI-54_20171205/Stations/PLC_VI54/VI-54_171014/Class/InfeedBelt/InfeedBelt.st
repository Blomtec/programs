//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "InfeedBelt"
	Revision           = "1.0"
	GUID               = "{3C65EFBC-A7B4-4081-B2A6-BBA4CA52F13B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(810,120)">
	<Channels>
		<Server Name="AxleInfeedError" GUID="{2E4029D0-8B25-4736-9880-584E46BACF4B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="AxleInfeedState" GUID="{662630AC-6C88-409E-A299-91E4749A5916}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="StationNbr" GUID="{8BDB7CC1-48E6-40CC-97DB-3395ECE466C6}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="AxleInfeed" Required="true" Internal="false"/>
		<Client Name="NextBelt" Required="false" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="0"/>
		</Servers>
	</Separators>
	<Network Name="InfeedBelt">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{37EE7D66-408C-4765-A6B6-481D3F1CCCC8}"
				Class      = "MachineBase"
				Position   = "(150,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ObjectServer"/>
					<Server Name="Runningmode"/>
					<Server Name="Stepper"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ObjectServer" Destination="_base.ObjectServer" Vertices="(938,210),(766,210),"/>
			<Connection Source="this.Stepper" Destination="_base.Stepper" Vertices="(938,270),(766,270),"/>
			<Connection Source="this.Runningmode" Destination="_base.Runningmode" Vertices="(938,330),(766,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using MachineBase

InfeedBelt : CLASS
: MachineBase
  //Servers:
	StationNbr 	: SvrCh_DINT;
	AxleInfeedState 	: SvrCh__LMCAXIS_STATUS;
	AxleInfeedError 	: SvrCh__LMCAXIS_ERROR;
  //Clients:
	AxleInfeed 	: CltChCmd__LMCAxis;
	NextBelt 	: CltChCmd_InfeedBelt;
  //Variables:
		CalcLineSpeed 	: DINT;
		CalcCleaningSpeed 	: DINT;
		CalcCleaningAccDec 	: DINT;
		CalcCleaningJogDistance 	: DINT;
		CalcLineAccDec 	: DINT;
		OldCalcLineSpeed 	: DINT;
		OldCleaningMode 	: OptiesEnum;
		CleaningSpeedOld 	: DINT;
		CleaningAccDecOld 	: DINT;
		Override 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL MyInit;
	
	FUNCTION VIRTUAL GLOBAL MyCyTask;
	
	FUNCTION VIRTUAL GLOBAL ResetErrors;
	
	FUNCTION GLOBAL SetStationNbr
		VAR_INPUT
			Nbr 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _LMCAxis


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB InfeedBelt::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_INFEEDBELT
1$UINT, 0$UINT, (SIZEOF(::InfeedBelt))$UINT, 
3$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3956548114), "InfeedBelt", //Class
TO_UDINT(3119722310), "MachineBase", 0$UINT, 0$UINT, //Baseclass
//Servers:
(::InfeedBelt.StationNbr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(413879351), "StationNbr", 
(::InfeedBelt.AxleInfeedState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3471494630), "AxleInfeedState", 
(::InfeedBelt.AxleInfeedError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(816096108), "AxleInfeedError", 
//Clients:
(::InfeedBelt.AxleInfeed.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3363610997), "AxleInfeed", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 73$UINT, 
(::InfeedBelt.NextBelt.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(365886592), "NextBelt", TO_UDINT(3956548114), "InfeedBelt", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_InfeedBelt 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_InfeedBelt] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION InfeedBelt::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= MachineBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= MachineBase::ObjectServer.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, MachineBase::ObjectServer.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_InfeedBelt;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #MyInit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #MyCyTask();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #ResetErrors();

#pragma warning (default : 74)
	MachineBase::ObjectServer.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF MachineBase::ObjectServer.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL InfeedBelt::MyInit
  
  // Next conveyor
  if IsClientConnected(#NextBelt) then
    NextBelt.InitTask(SetGlobalPtr:= GlobalDataPtr, SetRecipePtr:= RecipePtr);
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL InfeedBelt::MyCyTask
  
  // Another infeed belts
  if IsClientConnected(#NextBelt) then
    NextBelt.CyTask();
  end_if;
  
  // Statussen van de motor uitlezen
  AxleInfeed      := AxleInfeed.Read();
  AxleInfeedState := AxleInfeed.ReadAxisStatus();
  AxleInfeedError := AxleInfeed.ReadAxisError();
  
  // Set runningmode 
  RunningMode := GlobalDataPtr^.gRunStatus.gRunStatusInfeedConv;
    
  // Calculate the follow next settings
  CalcLineSpeed               := GlobalDataPtr^.gGeneralData.LineSpeed;
  CalcLineAccDec              := to_dint(to_real 30 ToMMperSec2); // 3.0 m/s2
  
  CalcCleaningSpeed           := GlobalDataPtr^.gGeneralData.CleaningSpeed;
  CalcCleaningAccDec          := GlobalDataPtr^.gGeneralData.CleaningAccDec;
  CalcCleaningJogDistance     := to_dint(to_real GlobalDataPtr^.gGeneralData.CleaningJogDistance * cIntUnitsTo_mm);
  
  
  // pause signal .. override
  Override := GlobalDataPtr^.gGeneralData.PauzeOverride;
  if GlobalDataPtr^.gGeneralData.iExternrelease = 0 then 
    AxleInfeed.SetParameter(ParNr:= LMCAXIS_PAR_SET_OVERRIDE, Value:= Override, mode:=0);
  else
    AxleInfeed.SetParameter(ParNr:= LMCAXIS_PAR_SET_OVERRIDE, Value:= 1000, mode:=0);
  end_if;
  
  
  // check for errors
  if GlobalDataPtr^.gGeneralData.NoError = 0 | GlobalDataPtr^.gGeneralData.iNoodstopOk = 0 then
    if Stepper < 100 | Stepper >= 200 then
      Stepper := 100;
    end_if;
  end_if; 
  
  // When beltnbr is equal to '0' then the machine is working with 1 station.. 
  if StationNbr <> 0 then
    case Stepper of
    00: // Looking for status
      GlobalDataPtr^.gRunStatus.gRunStatusInfeedConv := eStopStatus;  
      if GlobalDataPtr^.gRunStatus.gRunStatusGlob = eRunStatus | GlobalDataPtr^.gRunStatus.gRunStatusGlob = eCleaningStatus | 
      GlobalDataPtr^.gRunStatus.gRunStatusGlob = ePauseStatus | GlobalDataPtr^.gRunStatus.gRunStatusGlob = eStartUpStatus then
        if GlobalDataPtr^.gGeneralData.iDrivesOK = 1 then
          Stepper += 1;
        end_if;  
      end_if;

    01: // Axle enabled??
      if GlobalDataPtr^.gGeneralData.iDrivesEnabled = 0 then
        if AxleInfeedState.PowerOn = 0 then
          AxleInfeed.PowerOn(Mode:=LMCAXIS_MOVE_ANY_WAY);
        end_if;  
      else
        Stepper += 1;
      end_if;

    02: // What do we choose?
      if GlobalDataPtr^.gRunStatus.gRunStatusGlob = eRunStatus | GlobalDataPtr^.gRunStatus.gRunStatusGlob = ePauseStatus then
        Stepper := 40;
      elsif GlobalDataPtr^.gRunStatus.gRunStatusGlob = eCleaningStatus then
        Stepper := 200;
      end_if; 

      
    //--------------------------------   
    40: // Runstate
      GlobalDataPtr^.gRunStatus.gRunStatusInfeedConv := eRunStatus;
      AxleInfeed.MoveEndless(Speed:= CalcLineSpeed, Accel:= CalcLineAccDec);
      OldCalcLineSpeed := CalcLineSpeed;
      Stepper += 1;
    
    41: 
      if GlobalDataPtr^.gRunStatus.gRunStatusGlob <> eRunStatus & GlobalDataPtr^.gRunStatus.gRunStatusGlob <> ePauseStatus then
        Stepper := 100;
      elsif (OldCalcLineSpeed <> CalcLineSpeed) then
        Stepper -= 1;
      end_if;
    
    
    //--------------------------------  
    100: // assen stopzetten en uitzetten
      GlobalDataPtr^.gRunStatus.gRunStatusInfeedConv := eStopStatus;
      if AxleInfeedState.PowerOn = 1 then
        AxleInfeed.PowerOff(Mode:= LMCAXIS_IMMEDIATE_STOPP);
      else
        Stepper += 1;
      end_if;
      
    101:
      GlobalDataPtr^.gRunStatus.gRunStatusInfeedConv := eDriveOffStatus;
      if GlobalDataPtr^.gGeneralData.NoError = 1 & GlobalDataPtr^.gGeneralData.iNoodstopOk = 1 then
        Stepper := 0;
      end_if;
      
      
    //-------------------------------- 
    200: // Cleaning
      GlobalDataPtr^.gRunStatus.gRunStatusInfeedConv := eCleaningStatus;
      OldCleaningMode := GlobalDataPtr^.gGeneralData.CleaningJogOption; 
      if GlobalDataPtr^.gGeneralData.CleaningJogOption = Actief then
        Stepper := 205;
      else
        Stepper += 1;
      end_if;
      
    201: // Cleaning endless //
      AxleInfeed.MoveEndless(Speed:= CalcCleaningSpeed, Accel:= CalcCleaningAccDec);
      CleaningSpeedOld := CalcCleaningSpeed;
      CleaningAccDecOld   := CalcCleaningAccDec;
      Stepper += 1;
      
    202:
      if GlobalDataPtr^.gRunStatus.gRunStatusGlob <> eCleaningStatus then
        Stepper := 100;
      elsif OldCleaningMode <> GlobalDataPtr^.gGeneralData.CleaningJogOption then // Is cleaningOption different?
        AxleInfeed.StopMove(Decel:= CalcCleaningAccDec);
        Stepper := 200;
      elsif CalcCleaningSpeed <> CleaningSpeedOld then
        Stepper -= 1;
      elsif CalcCleaningAccDec <> CleaningAccDecOld then
        Stepper -= 1;
      end_if;    
    
    205: // Cleaning in jogmode (every time a step) //
      if GlobalDataPtr^.gRunStatus.gRunStatusGlob <> eCleaningStatus then
        Stepper := 100;
      elsif OldCleaningMode <> GlobalDataPtr^.gGeneralData.CleaningJogOption then // Is cleaningOption different?
        AxleInfeed.StopMove(Decel:= CalcCleaningAccDec);
        Stepper := 200;
      elsif GlobalDataPtr^.gGeneralData.CleaningJog = 1 then
        AxleInfeed.MoveRelative(Position:= CalcCleaningJogDistance, 
                                Mode:= LMCAXIS_MOVE_RELATIVE_TO_POSITION, 
                                Speed:= CalcCleaningSpeed, 
                                Accel:= CalcCleaningAccDec, 
                                Decel:= CalcCleaningAccDec);
        Stepper += 1;
      end_if;
      
     206: 
      if GlobalDataPtr^.gRunStatus.gRunStatusGlob <> eCleaningStatus then
        Stepper := 100;
      elsif AxleInfeed.InPosition(Mode:= LMCAXIS_SETPOS_IN_WINDOW_APP_UNITS, PositionWindow:= 1000) then
        if GlobalDataPtr^.gGeneralData.CleaningJog = 0 then
          Stepper -= 1;
        end_if;
      end_if;
      
    end_case;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL InfeedBelt::ResetErrors

  // Reset errors
  if IsClientConnected(#NextBelt) then
    NextBelt.ResetErrors();
  end_if;

END_FUNCTION

FUNCTION GLOBAL InfeedBelt::SetStationNbr
	VAR_INPUT
		Nbr 	: DINT;
	END_VAR
  
  StationNbr := Nbr;
  
  if IsClientConnected(#NextBelt) then
    NextBelt.SetStationNbr(Nbr:= StationNbr + 1);
  end_if;

END_FUNCTION
