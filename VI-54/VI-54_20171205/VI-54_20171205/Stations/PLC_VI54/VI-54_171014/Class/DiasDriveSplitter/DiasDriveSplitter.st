//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "DiasDriveSplitter"
	Revision           = "6.1"
	GUID               = "{07ED901B-3850-48B7-9C4E-C058F1CBDDEE}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,480)">
	<Channels>
		<Server Name="ClassSvr" GUID="{AF3F2C0C-313A-45AB-A403-AEEBC309AED7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="DrivesEnabled" GUID="{8AD2BAA5-4F9B-454B-B7E7-ABDE809C22BF}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="DrivesOk" GUID="{28228C54-D37A-4CA3-9835-78F8BB7B6B9F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="DriveAxleM1" Required="true" Internal="false" Comment="Connected to the _DriveAxis&#13;&#10;"/>
		<Client Name="DriveAxleM2" Required="false" Internal="false" Comment="Connected to the _DriveAxis"/>
		<Client Name="DriveAxleM3" Required="false" Internal="false" Comment="Connected to the _DriveAxis"/>
		<Client Name="DriveAxleM4" Required="false" Internal="false" Comment="Connected to the _DriveAxis"/>
		<Client Name="DriveAxleM5" Required="false" Internal="false" Comment="Connected to the _DriveAxis"/>
		<Client Name="DriveAxleM6" Required="false" Internal="false" Comment="Connected to the _DriveAxis"/>
		<Client Name="DriveAxleM7" Required="false" Internal="false"/>
		<Client Name="DriveAxleM8" Required="false" Internal="false"/>
	</Channels>
	<Network Name="DiasDriveSplitter">
		<!-- List of Components in this network -->
		<Components>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
DiasDriveSplitter : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	DrivesOk 	: SvrCh_DINT;
	DrivesEnabled 	: SvrCh_DINT;
  //Clients:
	DriveAxleM1 	: CltChCmd_DriveAxleErr;
	DriveAxleM2 	: CltChCmd_DriveAxleErr;
	DriveAxleM3 	: CltChCmd_DriveAxleErr;
	DriveAxleM4 	: CltChCmd_DriveAxleErr;
	DriveAxleM5 	: CltChCmd_DriveAxleErr;
	DriveAxleM6 	: CltChCmd_DriveAxleErr;
	DriveAxleM7 	: CltChCmd_DriveAxleErr;
	DriveAxleM8 	: CltChCmd_DriveAxleErr;
  //Variables:
		DriveManagerOnline 	: DINT;
		AxleOkM1 	: DINT;
		AxleOkM2 	: DINT;
		AxleOkM3 	: DINT;
		AxleOkM4 	: DINT;
		AxleOkM5 	: DINT;
		AxleOkM6 	: DINT;
		AxleOkM7 	: DINT;
		AxleOkM8 	: DINT;
		AxleEnableM1 	: DINT;
		AxleEnableM2 	: DINT;
		AxleEnableM3 	: DINT;
		AxleEnableM4 	: DINT;
		AxleEnableM5 	: DINT;
		AxleEnableM6 	: DINT;
		AxleEnableM7 	: DINT;
		AxleEnableM8 	: DINT;
		cmdResetDrives 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL ReadDriveOk
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ReadDrivesEnabled
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DrivesOk::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd DriveAxleErr


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DiasDriveSplitter::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_DIASDRIVESPLITTER
6$UINT, 1$UINT, (SIZEOF(::DiasDriveSplitter))$UINT, 
3$UINT, 8$UINT, 0$UINT, 
TO_UDINT(3993294158), "DiasDriveSplitter", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DiasDriveSplitter.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::DiasDriveSplitter.DrivesOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3076815131), "DrivesOk", 
(::DiasDriveSplitter.DrivesEnabled.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(108232900), "DrivesEnabled", 
//Clients:
(::DiasDriveSplitter.DriveAxleM1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(943807528), "DriveAxleM1", TO_UDINT(573136687), "DriveAxleErr", 6$UINT, 1$UINT, 
(::DiasDriveSplitter.DriveAxleM2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2705853842), "DriveAxleM2", TO_UDINT(573136687), "DriveAxleErr", 6$UINT, 1$UINT, 
(::DiasDriveSplitter.DriveAxleM3.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3595517188), "DriveAxleM3", TO_UDINT(573136687), "DriveAxleErr", 6$UINT, 1$UINT, 
(::DiasDriveSplitter.DriveAxleM4.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1210820775), "DriveAxleM4", TO_UDINT(573136687), "DriveAxleErr", 6$UINT, 1$UINT, 
(::DiasDriveSplitter.DriveAxleM5.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1059887153), "DriveAxleM5", TO_UDINT(573136687), "DriveAxleErr", 6$UINT, 1$UINT, 
(::DiasDriveSplitter.DriveAxleM6.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2787494283), "DriveAxleM6", TO_UDINT(573136687), "DriveAxleErr", 6$UINT, 1$UINT, 
(::DiasDriveSplitter.DriveAxleM7.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3508730141), "DriveAxleM7", TO_UDINT(573136687), "DriveAxleErr", 6$UINT, 1$UINT, 
(::DiasDriveSplitter.DriveAxleM8.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1100866700), "DriveAxleM8", TO_UDINT(573136687), "DriveAxleErr", 6$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_DiasDriveSplitter 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DiasDriveSplitter] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DiasDriveSplitter::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DiasDriveSplitter, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DrivesOk.pMeth			:= StoreMethod( #M_RD_DIRECT(), #DrivesOk::Write() );
	IF DrivesOk.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL DiasDriveSplitter::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  // Axle number 1
  if IsClientConnected(#DriveAxleM1) then
    DriveAxleM1  := DriveAxleM1.Read();
    AxleOkM1     := DriveAxleM1.ReadDriveOk();
    AxleEnableM1 := DriveAxleM1.ReadDriveEnabled();
    if cmdResetDrives = 1 then
      DriveAxleM1.ResetDrives();
    end_if;
  else
    DriveAxleM1  := ERROR;
    AxleEnableM1 := 1; // Axle enabled
    AxleOkM1     := 1;// axle oke
  end_if;

  // Axle number 2
  if IsClientConnected(#DriveAxleM2) then
    DriveAxleM2  := DriveAxleM2.Read();
    AxleOkM2     := DriveAxleM2.ReadDriveOk();
    AxleEnableM2 := DriveAxleM2.ReadDriveEnabled();
    if cmdResetDrives = 1 then
      DriveAxleM2.ResetDrives();
    end_if;
  else
    DriveAxleM2  := ERROR;
    AxleEnableM2 := 1; // Axle enabled
    AxleOkM2     := 1;// axle oke
  end_if;

  // Axle number 3
  if IsClientConnected(#DriveAxleM3) then
    DriveAxleM3  := DriveAxleM3.Read();
    AxleOkM3     := DriveAxleM3.ReadDriveOk();
    AxleEnableM3 := DriveAxleM3.ReadDriveEnabled();
    if cmdResetDrives = 1 then
      DriveAxleM3.ResetDrives();
    end_if;
  else
    DriveAxleM3  := ERROR;
    AxleEnableM3 := 1; // Axle enabled
    AxleOkM3     := 1;// axle oke
  end_if; 

  // Axle number 4
  if IsClientConnected(#DriveAxleM4) then
    DriveAxleM4  := DriveAxleM4.Read();
    AxleOkM4     := DriveAxleM4.ReadDriveOk();
    AxleEnableM4 := DriveAxleM4.ReadDriveEnabled();
    if cmdResetDrives = 1 then
      DriveAxleM4.ResetDrives();
    end_if;
  else
    DriveAxleM4  := ERROR;
    AxleEnableM4 := 1; // Axle enabled
    AxleOkM4     := 1;// axle oke
  end_if;

  // Axle number 5
  if IsClientConnected(#DriveAxleM5) then
    DriveAxleM5  := DriveAxleM5.Read();
    AxleOkM5     := DriveAxleM5.ReadDriveOk();
    AxleEnableM5 := DriveAxleM5.ReadDriveEnabled();
    if cmdResetDrives = 1 then
      DriveAxleM5.ResetDrives();
    end_if;
  else
    DriveAxleM5  := ERROR;
    AxleEnableM5 := 1; // Axle enabled
    AxleOkM5     := 1;// axle oke
  end_if;
  
  // Axle number 6
  if IsClientConnected(#DriveAxleM6) then
    DriveAxleM6  := DriveAxleM6.Read();
    AxleOkM6     := DriveAxleM6.ReadDriveOk();
    AxleEnableM6 := DriveAxleM6.ReadDriveEnabled();
    if cmdResetDrives = 1 then
      DriveAxleM6.ResetDrives();
    end_if;
  else
    DriveAxleM6  := ERROR;
    AxleEnableM6 := 1; // Axle enabled
    AxleOkM6     := 1;// axle oke
  end_if;
  
  // Axle number 7
  if IsClientConnected(#DriveAxleM7) then
    DriveAxleM7  := DriveAxleM7.Read();
    AxleOkM7     := DriveAxleM7.ReadDriveOk();
    AxleEnableM7 := DriveAxleM7.ReadDriveEnabled();
    if cmdResetDrives = 1 then
      DriveAxleM7.ResetDrives();
    end_if;
  else
    DriveAxleM7  := ERROR;
    AxleEnableM7 := 1; // Axle enabled
    AxleOkM7     := 1;// axle oke
  end_if;
  
  // Axle number 8
  if IsClientConnected(#DriveAxleM8) then
    DriveAxleM8  := DriveAxleM8.Read();
    AxleOkM8     := DriveAxleM8.ReadDriveOk();
    AxleEnableM8 := DriveAxleM8.ReadDriveEnabled();
    if cmdResetDrives = 1 then
      DriveAxleM8.ResetDrives();
    end_if;
  else
    DriveAxleM8  := ERROR;
    AxleEnableM8 := 1; // Axle enabled
    AxleOkM8     := 1;// axle oke
  end_if;
  
  DrivesEnabled := ((AxleEnableM1 = 1 & AxleEnableM2 = 1 & AxleEnableM3 = 1 & AxleEnableM4 = 1 & AxleEnableM5 = 1 & AxleEnableM6 = 1 & AxleEnableM7 = 1 & AxleEnableM8 = 1));
  DrivesOK      := ((AxleOkM1 = 1 & AxleOkM2 = 1 & AxleOkM3 = 1 & AxleOkM4 = 1 & AxleOkM5 = 1 & AxleOkM6 = 1 & AxleOkM7 = 1 & AxleOkM8 = 1));


	state := READY;

END_FUNCTION

FUNCTION GLOBAL DiasDriveSplitter::ReadDriveOk
	VAR_OUTPUT
		State 	: DINT;
	END_VAR

  State := DrivesOk;

END_FUNCTION


FUNCTION GLOBAL DiasDriveSplitter::ReadDrivesEnabled
	VAR_OUTPUT
		State 	: DINT;
	END_VAR
  
  State := DrivesEnabled;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DiasDriveSplitter::DrivesOk::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	  
  if DrivesOk = 0 then
    cmdResetDrives := input;
  end_if; 
  
 	result := input;

END_FUNCTION
