//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

(*
 * Array size
 *)
#define cMaxStandardArray 1024
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "Standard"
	Revision           = "6.1"
	GUID               = "{E7A386E5-4A39-4E73-8C4C-CCC1280FF277}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "1000 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(420,180)">
	<Channels>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\Standard\Standard.doc"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="SigmaControl" Author="Johan Embregts"/>
		<Dokumentation Revision="6.1" Date="2015-01-01" Author="Johan Embregts" Company="SigmaControl" Description="Improvement for ARM compiler."/>
		<Dokumentation Revision="6.0" Date="2014-10-07" Author="Johan Embregts" Company="SigmaControl" Description="Moved General functions to SCBase Class.&#13;&#10;There are; Swap2b(), Swap4b(), GetClassCheckSum(), RandomGenerator(), StepHndl(), BuildEventMsg().&#13;&#10;Server LogID moved to SCBase.&#13;&#10;Some serious name changing."/>
		<Dokumentation Revision="5.4" Date="2014-07-23" Author="Johan Embregts" Company="SigmaControl" Description="When Freeze is active then also freeze the Stepper tMark time."/>
		<Dokumentation Revision="5.3" Date="2014-07-04" Author="Johan Embregts" Company="SigmaControl" Description="Very first &quot;First&quot; in StepperHndl() was not handeld correct.&#13;&#10;This is corrected and there is an OerInit added to the struct."/>
		<Dokumentation Revision="5.2" Date="2014-06-19" Author="Johan Embregts" Company="SigmaControl" Description="Added a 500mSec Imp and Clk puls."/>
		<Dokumentation Revision="5.1" Date="2014-06-02" Author="Johan Embregts" Company="SigmaControl" Description="Invalid InvalidArchitectureType detected and message."/>
		<Dokumentation Revision="5.0" Date="2014-04-03" Author="Johan Embregts" Company="SigmaControl" Description="Moved to LibrarySC.&#13;&#10;Placed Global Types in a folder LibrarySC.&#13;&#10;Made more use of ENUMs.&#13;&#10;Added invalid LogID number message.&#13;&#10;Made use of Standard Units.&#13;&#10;Moved all definitions to &quot;Defines&quot; if posible."/>
		<Dokumentation Revision="4.1" Date="2014-02-25" Author="Martin Spitzauer" Company="SigmaTek" Description="EBP for ARM is #Q"/>
		<Dokumentation Revision="4.0" Date="2013-11-01" Author="Johan Embregts" Company="SigmaControl" Description="ARM compatible. Changed AWL functions in to STR.&#13;&#10; "/>
		<Dokumentation Revision="3.5" Date="2013-10-03" Author="Johan Embregts" Company="SigmaControl" Description="- Imp_Clk corrected timing.&#13;&#10;- use time constants from unit.h"/>
		<Dokumentation Revision="3.4" Date="2013-06-11" Author="Johan Embregts" Company="SigmaControl" Description="- LogId extended 0..8, 10..18 for Eventlog10..18 &#13;&#10;- Errorcode for LFush corrected.&#13;&#10;- Expanded Doc and error text."/>
		<Dokumentation Revision="3.3" Date="2013-03-07" Author="Johan Embregts" Company="SigmaControl" Description="Convert Big- and Little-Endian of 2 and 4 byte value."/>
		<Dokumentation Revision="3.2" Date="2013-02-19" Author="Johan Embregts" Company="SigmaControl" Description="Expanded the internal buffer to 100.000 Byte.&#13;&#10;Had to place it outside the Class with &quot;ToGrafix.MemoryV1()&quot;."/>
		<Dokumentation Revision="3.1" Date="2013-02-13" Author="Johan Embregts" Company="SigmaControl" Description="Flush methodes from diferent timeout timers!&#13;&#10;Extra test for LFlush with Nil pointer. "/>
		<Dokumentation Revision="3.0" Date="2013-02-02" Author="Johan Embregts" Company="SigmaControl" Description="- For the  R_TRIG, F_TRIG and N_TRIG function the CLK does not have to be a pointer.&#13;&#10;  Therefore the pointer is removed.&#13;&#10;  This can give a compiler error but has more advantages therefore it has been changed.&#13;&#10;- Help texts for new functions added."/>
		<Dokumentation Revision="2.5" Date="2012-11-06" Author="Johan Embregts" Company="SigmaControl" Description="ULFush and LFush added for log messages.&#13;&#10;LFush has no overflow flush so set to cMaxMsgTo ( 5Sec).&#13;&#10;ULFush has an overflow flush so when cMaxMsgTo ( 5Sec) no flush then force flush."/>
		<Dokumentation Revision="2.4" Date="2012-10-30" Author="Johan Embregts" Company="SigmaControl" Description="Messages and test on handel corrected."/>
		<Dokumentation Revision="2.3" Date="2012-10-08" Author="Johan Embregts" Company="SigmaControl" Description="Only ULFlush with nonblokking.&#13;&#10;Flushing when cMaxMsgTo time no data is loged.&#13;&#10;Max size Event10.log .. Event18.log  is set to 100Mb by cMaxMsgFileSize."/>
		<Dokumentation Revision="2.2" Date="2012-09-28" Author="Johan Embregts" Company="SigmaControl" Description="CreateMsg and LFlush had a bug and generated a message. This has been corrected."/>
		<Dokumentation Revision="2.1" Date="2012-09-08" Author="Johan Embregts" Company="SigmaControl" Description="- Added server LogID. -1 is off and 0..8 for Event10.log to Event18.log.&#13;&#10;- ErrorMsg, AlarmMsg and LogisticsMsg are written to Event01.Log.&#13;&#10;- ValueLog is written to Event1x.Log.&#13;&#10;- EtcMsg is written to Debugtracer."/>
		<Dokumentation Revision="2.0" Date="2012-09-04" Author="Johan Embregts" Company="SigmaControl" Description="- Added a Background Task. This for When this is a BaseClass to a Class that needs a Background Task.&#13;&#10;- Added a general &quot;BuildEventMsg()&quot; method to log events. With a flush mechanisme."/>
		<Dokumentation Revision="1.5" Date="2012-06-12" Author="Johan Embregts" Company="SigmaControl" Description="Added Random generator.&#13;&#10;Made one BuildTraceMsg.&#13;&#10;Traces also send to Event01.log."/>
		<Dokumentation Revision="1.4" Date="2011-12-16" Author="Johan Embregts" Company="SigmaControl" Description="When TONOF() and DisplayTONOF() are used as debounce there was a bug.&#13;&#10;This bug is corrected."/>
		<Dokumentation Revision="1.3" Date="2011-10-07" Author="Johan Embregts" Company="SigmaControl" Description="Comment veld voor de methode&apos;s DELAYS() en DisplayDELAYS() aangepast."/>
		<Dokumentation Revision="1.2" Date="2011-08-23" Author="Johan Embregts" Company="SigmaControl" Description="Function StepperHandel() is added.&#13;&#10;Trace messages are added."/>
		<Dokumentation Revision="1.1" Date="2011-08-23" Author="Johan Embregts" Company="SigmaControl" Description="The function _Imp_Clk() added.&#13;&#10;This funktion generate&apos;s 10mSec, 100mSec, 1Sec and 10Second Impulse and Clock signals.&#13;&#10;Test if ET and CLK pointer is valid."/>
		<Dokumentation Revision="1.0" Date="2011-08-18" Author="Johan Embregts" Company="SigmaControl" Description="The input “NR” from the timers is made obsolete.&#13;&#10;Timer Struct is expanded with CallBackAddress. &#13;&#10;Should “IN” from a “TON” be ‘1’ on initial, then “Q” is set direct to ‘1’ without delay.&#13;&#10;Should “IN” from a “TOF” be ‘0’ on initial, then “Q” is set direct to ‘0’ without delay. &#13;&#10;Should “IN” from a “TP” be ‘1’ on initial, then “Q” will not pulse.&#13;&#10;Freeze timer option is added. To freeze the timer when set to ‘1’. &#13;&#10;For the Freeze function all timer arrays are combined. &#13;&#10;Array size and size test are defined with constant &quot;cMaxStandardArray&quot; and set to 1023.&#13;&#10;ClassSvr is set to -1 and -2 should Timer array or Trigger array be full.&#13;&#10;Trigger is changed so that 2 or more separate triggers on the same flag generate 2 or more separate pulses.&#13;&#10;New function TONOF and DisplayTONOF added."/>
		<Dokumentation Revision="0.3" Date="2011-08-16" Author="Peter van Oostrom" Company="SigmaControl" Description="Time constances for Seconds and Minutes.&#13;&#10;Documented."/>
		<Dokumentation Revision="0.2" Date="2011-08-15" Author="Johan Embregts" Company="SigmaControl" Description="Puls Function of the TP was not correct."/>
		<Dokumentation Revision="0.1" Date="2011-08-15" Author="Lucien Kouwenhoven" Company="SigmaControl" Description="Q from TP function was not always writen."/>
		<Dokumentation Revision="0.0" Date="2011-08-15" Author="Lucien Kouwenhoven" Company="SigmaControl" Description="Created."/>
	</RevDoku>
	<Network Name="Standard">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{5E7DE831-554D-4C5D-8ADC-29B04EBA9AEE}"
				Class      = "SCBase"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="LogID"/>
					<Client Name="ToGrafix"/>
					<Client Name="ToLinker"/>
					<Client Name="ToSigCLib"/>
					<Client Name="ToSysMsg"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SCBase

Standard : CLASS
: SCBase
	TYPE
#pragma pack(push, 1)
	  STbTimerStr : STRUCT
	    Status : DINT;
	    Timer : UDINT;
	    CallBackAddress : HDINT;
	  END_STRUCT;
#pragma pack(pop)
	  STbTraceMsgTxt :
	  (
	    STbTimerArrayIsFullMess,
	    STbTriggerArrauIsFullMess
	  )$UDINT;
#pragma pack(push, 1)
	  STbTriggerStr : STRUCT
	    Status : DINT;
	    CallBackAddress : HDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
  //Clients:
  //Variables:
		tMark10mSec 	: UDINT;
		tMark100mSec 	: UDINT;
		tMark500mSec 	: UDINT;
		tMark1Sec 	: UDINT;
		tMark10Sec 	: UDINT;
		NrTimersInuse 	: DINT;
		STbMessTimerFull 	: DINT;
		aTimeData : ARRAY [0..cMaxStandardArray] OF STbTimerStr;

		NrTriggerInuse 	: DINT;
		STbMessTriggerFull 	: DINT;
		aTriggerData : ARRAY [0..cMaxStandardArray] OF STbTriggerStr;

		FreezeTimeOld 	: UDINT;
		MessInvalidPointer 	: DINT;
  //Functions:
				//! <Function Comment="Timer on-delay&#13;&#10;IN:(* begint timer met stijgende flank, reset timer met dalende flank *&#41; &#13;&#10;PT:(* tijd om te passeren, voordat Q is ingesteld [ms]*&#41;&#13;&#10;&#13;&#10;Q: (* WAAR is, PT seconden nadat IN had een stijgende flank *&#41;&#13;&#10;" Name="TON"/>
	FUNCTION VIRTUAL GLOBAL TON
		VAR_INPUT
			IN 	: DINT;			//! <Variable Comment="begint timer met stijgende flank, reset timer met dalende flank." Name="TON.IN"/>
			PT 	: DINT;			//! <Variable Comment="tijd om te passeren, voordat Q is ingesteld [ms]." Name="TON.PT"/>
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;			//! <Variable Comment="WAAR is, PT seconden nadat IN had een stijgende flank" Name="TON.Q"/>
		END_VAR;
				//! <Function Comment="Timer off-delay&#13;&#10;IN:(* begint timer met een dalende rand, reset timer met stijgende flank *&#41; &#13;&#10;PT:(* tijd om te passeren, voordat Q is ingesteld *&#41;&#13;&#10;&#13;&#10;Q: (* is FALSE, PT seconden nadat IN had een dalende flank *&#41;&#13;&#10;" Name="TOF"/>
	FUNCTION VIRTUAL GLOBAL TOF
		VAR_INPUT
			IN 	: DINT;
			PT 	: DINT;
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="Timer on-off-delay&#13;&#10;IN: (* begint timer met een flank*&#41;&#13;&#10;PT: (* tijd om te passeren, voordat Q is ingesteld *&#41;&#13;&#10;&#13;&#10;Q: (* is FALSE, PT seconden nadat IN had een dalende flank *&#41;" Name="TONOF"/>
	FUNCTION VIRTUAL GLOBAL TONOF
		VAR_INPUT
			IN 	: DINT;
			PT 	: DINT;
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="De puls timer blok kan worden gebruikt om de uitvoer pulsen van een bepaalde tijdsduur te genereren&#13;&#10;IN: (* Trigger voor Start van de Signal *&#41;&#13;&#10;PT: (* De lengte van de Waar-Signaal in [ms] *&#41;&#13;&#10;&#13;&#10;Q:  (* De puls *&#41;&#13;&#10;" Name="TP"/>
	FUNCTION VIRTUAL GLOBAL TP
		VAR_INPUT
			IN 	: DINT;
			PT 	: DINT;
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="Timer on-delay (voor Case instructie)&#13;&#10;LetOp deze tijd moet wel voledig aflopen.&#13;&#10;Bij vroegtijdig verlaten van de stap wordt de tijd niet gereset.&#13;&#10;&#13;&#10;PT:(* tijd om te passeren, voordat Q is ingesteld [ms]*&#41;&#13;&#10;&#13;&#10;Q: (* WAAR is, PT seconden nadat IN had een stijgende flank *&#41;&#13;&#10;" Name="DELAYS"/>
	FUNCTION VIRTUAL GLOBAL DELAYS
		VAR_INPUT
			PT 	: DINT;
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="Timer on-delay&#13;&#10;IN:(* begint timer met stijgende flank, reset timer met dalende flank *&#41; &#13;&#10;PT:(* tijd om te passeren, voordat Q is ingesteld [ms]*&#41;&#13;&#10;ET:(* pointer naar een address om looptijd weer te geven [ms] *&#41;&#13;&#10;&#13;&#10;Q: (* WAAR is, PT seconden nadat IN had een stijgende flank *&#41;&#13;&#10;" Name="DisplayTON"/>
	FUNCTION VIRTUAL GLOBAL DisplayTON
		VAR_INPUT
			IN 	: DINT;
			PT 	: DINT;
			ET 	: ^UDINT;			//! <Variable Comment="pointer naar een address om looptijd weer te geven [ms]" Name="DisplayTON.ET"/>
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="Timer off-delay&#13;&#10;IN:(* begint timer met een dalende rand, reset timer met stijgende flank *&#41; &#13;&#10;PT:(* tijd om te passeren, voordat Q is ingesteld *&#41;&#13;&#10;ET:(* pointer naar een address om looptijd weer te geven [ms] *&#41;&#13;&#10;&#13;&#10;Q: (* is FALSE, PT seconden nadat IN had een dalende flank *&#41;&#13;&#10;" Name="DisplayTOF"/>
	FUNCTION VIRTUAL GLOBAL DisplayTOF
		VAR_INPUT
			IN 	: DINT;
			PT 	: DINT;
			ET 	: ^UDINT;			//! <Variable Comment="pointer naar een address om looptijd weer te geven [ms]" Name="DisplayTOF.ET"/>
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="Timer on-off-delay&#13;&#10;IN: (* begint timer met een flank*&#41;&#13;&#10;PT: (* tijd om te passeren, voordat Q is ingesteld *&#41;&#13;&#10;ET: (* pointer naar een address om looptijd weer te geven [ms] *&#41;&#13;&#10;&#13;&#10;Q:  (* is FALSE, PT seconden nadat IN had een dalende flank *&#41;" Name="DisplayTONOF"/>
	FUNCTION VIRTUAL GLOBAL DisplayTONOF
		VAR_INPUT
			IN 	: DINT;
			PT 	: DINT;
			ET 	: ^UDINT;			//! <Variable Comment="pointer naar een address om looptijd weer te geven [ms]" Name="DisplayTONOF.ET"/>
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="De puls timer blok kan worden gebruikt om de uitvoer pulsen van een bepaalde tijdsduur te genereren&#13;&#10;IN: (* Trigger voor Start van de Signal *&#41;&#13;&#10;PT: (* De lengte van de Waar-Signaal in [ms] *&#41;&#13;&#10;ET:(* pointer naar een address om looptijd weer te geven [ms] *&#41;&#13;&#10;&#13;&#10;Q:  (* De puls *&#41;&#13;&#10;" Name="DisplayTP"/>
	FUNCTION VIRTUAL GLOBAL DisplayTP
		VAR_INPUT
			IN 	: DINT;
			PT 	: DINT;
			ET 	: ^UDINT;			//! <Variable Comment="pointer naar een address om looptijd weer te geven [ms]" Name="DisplayTP.ET"/>
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="Timer on-delay (voor Case instructie)&#13;&#10;LetOp deze tijd moet wel voledig aflopen.&#13;&#10;Bij vroegtijdig verlaten van de stap wordt de tijd niet gereset.&#13;&#10;&#13;&#10;PT:(* tijd om te passeren, voordat Q is ingesteld [ms]*&#41;&#13;&#10;ET:(* pointer naar een address om looptijd weer te geven [ms] *&#41;&#13;&#10;&#13;&#10;Q: (* WAAR is, PT seconden nadat IN had een stijgende flank *&#41;&#13;&#10;" Name="DisplayDELAYS"/>
	FUNCTION VIRTUAL GLOBAL DisplayDELAYS
		VAR_INPUT
			PT 	: DINT;
			ET 	: ^UDINT;			//! <Variable Comment="pointer naar een address om looptijd weer te geven [ms]" Name="DisplayDELAYS.ET"/>
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="This function Freezes all timer functions.&#13;&#10;&#13;&#10;This is to freeze all counters should actions (Machine) be paused.&#13;&#10;If this option is needed than place freeze once and call cyclic.&#13;&#10;If this option is not needed than don&apos;t call at all.&#13;&#10;&#13;&#10;S1.FreezeTime( 0);  // for all timers to work normal.&#13;&#10;S1.FreezeTime( 1);  // for all timers to stop.&#13;&#10;" Name="FreezeTime"/>
	FUNCTION VIRTUAL GLOBAL FreezeTime
		VAR_INPUT
			Freeze 	: DINT;
		END_VAR;
				//! <Function Comment="Puls voor een stijgende flank&#13;&#10;CLK: (* Signaal 0 -&gt; 1 *&#41;&#13;&#10;&#13;&#10;Q: (* Pulse *&#41; &#13;&#10;&#13;&#10;PasOp! Trigger functies moeten cyclisch aangeroepen worden.&#13;&#10;dus niet over-sprongen worden door bv, een IF of een CASE functie.&#13;&#10;" Name="R_TRIG"/>
	FUNCTION VIRTUAL GLOBAL R_TRIG
		VAR_INPUT
			CLK 	: DINT;
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="Puls voor een dalende flank&#13;&#10;CLK: (* Signaal 1 -&gt; 0 *&#41;&#13;&#10;&#13;&#10;Q: (* Pulse *&#41; &#13;&#10;&#13;&#10;PasOp! Trigger functies moeten cyclisch aangeroepen worden.&#13;&#10;dus niet over-sprongen worden door bv, een IF of een CASE functie.&#13;&#10;" Name="F_TRIG"/>
	FUNCTION VIRTUAL GLOBAL F_TRIG
		VAR_INPUT
			CLK 	: DINT;
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="Puls voor een stijgende / dalende flank&#13;&#10;CLK: (* Signaal 1 -&gt; 0 &amp; 0 -&gt; 1 *&#41;&#13;&#10;&#13;&#10;Q: (* Pulzen *&#41; &#13;&#10;&#13;&#10;PasOp! Trigger functies moeten cyclisch aangeroepen worden.&#13;&#10;dus niet over-sprongen worden door bv, een IF of een CASE functie.&#13;&#10;" Name="N_TRIG"/>
	FUNCTION VIRTUAL GLOBAL N_TRIG
		VAR_INPUT
			CLK 	: DINT;
		END_VAR
		VAR_OUTPUT
			Q 	: DINT;
		END_VAR;
				//! <Function Comment="This funktion generate&apos;s 10mSec, 100mSec, 1Sec and 10Second Impulse and Clock signals." Name="Imp_Clk"/>
	FUNCTION VIRTUAL GLOBAL Imp_Clk
		VAR_INPUT
			pTimeData 	: ^ImpClkStr;
		END_VAR;
				//! <Function Comment="For internal messages from the Standerd Class." Name="STbBuildTraceMsg"/>
	FUNCTION VIRTUAL STbBuildTraceMsg
		VAR_INPUT
			MsgNr 	: STbTraceMsgTxt;
			Value1 	: DINT := 0;
			Value2 	: DINT := 0;
			Value3 	: DINT := 0;
		END_VAR
		VAR_OUTPUT
			Status 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Standard::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_STANDARD
6$UINT, 1$UINT, (SIZEOF(::Standard))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3603188683), "Standard", //Class
TO_UDINT(4092474794), "SCBase", 0$UINT, 7$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_Standard 28

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Standard] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Standard::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SCBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SCBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SCBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_Standard;
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #TON();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #TOF();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #TONOF();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #TP();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #DELAYS();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #DisplayTON();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #DisplayTOF();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #DisplayTONOF();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #DisplayTP();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #DisplayDELAYS();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #FreezeTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #R_TRIG();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #F_TRIG();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #N_TRIG();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #Imp_Clk();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #STbBuildTraceMsg();

#pragma warning (default : 74)
	SCBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SCBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL Standard::TON
	VAR_INPUT
		IN 	: DINT;
		PT 	: DINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    if NR<= cMaxStandardArray then
      // valid timer
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Timer  := ops.tAbsolute- PT$UDINT;              // Suppress initial puls should IN be '1'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      if IN = 1 then
        if ops.tAbsolute- aTimeData[NR].Timer>= PT$UDINT then
          // Time has elapsed.
          aTimeData[NR].Status := Q := 1;
        else
          // Timer is running
          aTimeData[NR].Status := Q := 0;
        end_if;
      else
        // init timer
        aTimeData[NR].Timer  := ops.tAbsolute;
        aTimeData[NR].Status := Q := 0;
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q := -1;
    end_if;
  else
    Q := -1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::DisplayTON
	VAR_INPUT
		IN 	: DINT;
		PT 	: DINT;
		ET 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
    DummyET : UDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    // Test if ET pointer is valid.
    if ET= nil then
      if MessInvalidPointer= 0 then
        ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbInvalidPointerMess);
        MessInvalidPointer := 1;
      end_if;
      // Overwrite invalid pointer.
      ET := #DummyET;
    end_if;
    if NR<= cMaxStandardArray then
      // valid timer
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Timer  := ops.tAbsolute- PT$UDINT;              // Suppress initial puls should IN be '0'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      if IN = 1 then
        if ops.tAbsolute- aTimeData[NR].Timer>= PT$UDINT then
          // Time has elapsed.
          aTimeData[NR].Status := Q := 1;
          ET^ := PT$UDINT;
        else
          // Time is running.
          aTimeData[NR].Status := Q := 0;
          ET^ := ops.tAbsolute- aTimeData[NR].Timer;
        end_if;
      else
        // init timer
        aTimeData[NR].Timer  := ops.tAbsolute;
        aTimeData[NR].Status := Q := 0;
        ET^ := 0;
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q   := -1;
      ET^ := 0;
    end_if;
  else
    Q   := -1;
    ET^ := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::TOF
	VAR_INPUT
		IN 	: DINT;
		PT 	: DINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR<= cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    if NR<= cMaxStandardArray then
      // valid timer
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Timer  := ops.tAbsolute- PT$UDINT;              // Suppress initial puls should IN be '0'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      if IN = 0 then
        if ops.tAbsolute- aTimeData[NR].Timer>= PT$UDINT then
          // Time has elapsed.
          aTimeData[NR].Status := Q := 0;
        else
          // Time is running.
          aTimeData[NR].Status := Q := 1;
        end_if;
      else
        // init timer
        aTimeData[NR].Timer  := ops.tAbsolute;
        aTimeData[NR].Status := Q := 1;
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q := -1;
    end_if;
  else
    Q := -1;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::DisplayTOF
	VAR_INPUT
		IN 	: DINT;
		PT 	: DINT;
		ET 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
    DummyET : UDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    // Test if ET pointer is valid.
    if ET= nil then
      if MessInvalidPointer= 0 then
        ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbInvalidPointerMess);
        MessInvalidPointer := 1;
      end_if;
      // Overwrite invalid pointer.
      ET := #DummyET;
    end_if;
    if NR<= cMaxStandardArray then
      // valid timer
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Timer  := ops.tAbsolute- PT$UDINT;              // Suppress initial puls should IN be '0'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      if IN = 0 then
        if ops.tAbsolute- aTimeData[NR].Timer>= PT$UDINT then
          // Time has elapsed.
          aTimeData[NR].Status := Q := 0;
          ET^ := PT$UDINT;
        else
          // Time is running.
          aTimeData[NR].Status := Q := 1;
          ET^ := ops.tAbsolute- aTimeData[NR].Timer;
        end_if;
      else
        // init timer
        aTimeData[NR].Timer  := ops.tAbsolute;
        aTimeData[NR].Status := Q := 1;
        ET^ := 0;
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q := -1;
      ET^ := 0;
    end_if;
  else
    Q   := -1;
    ET^ := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::TONOF
	VAR_INPUT
		IN 	: DINT;
		PT 	: DINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    if NR<= cMaxStandardArray then
      // valid timer
      IN:= IN<> 0;  // BOOL filter for the XOR later on.
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Status  := IN;                                  // Initial Old := New.
        aTimeData[NR].Timer   := ops.tAbsolute- PT$UDINT;             // Suppress initial puls should IN be '1'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      if aTimeData[NR].Status<> IN then
        // Edge detected init timer
        if ops.tAbsolute- aTimeData[NR].Timer>= PT$UDINT then
          aTimeData[NR].Timer   := ops.tAbsolute;             // Start timer
        else
          aTimeData[NR].Timer   := ops.tAbsolute- PT$UDINT;   // Timer already elapsed
        end_if;
        aTimeData[NR].Status  := IN;                          // New= Old
      end_if;
      
      if ops.tAbsolute- aTimeData[NR].Timer>= PT$UDINT then
        // Time has elapsed.
        Q := IN;                                              // Q= new value
      else
        // Timer is running.
        Q := IN Xor 2#1;                                      // Q= not new value
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q := -1;
    end_if;
  else
    Q := -1;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::DisplayTONOF
	VAR_INPUT
		IN 	: DINT;
		PT 	: DINT;
		ET 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
    DummyET : UDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    // Test if ET pointer is valid.
    if ET= nil then
      if MessInvalidPointer= 0 then
        ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbInvalidPointerMess);
        MessInvalidPointer := 1;
      end_if;
      // Overwrite invalid pointer.
      ET := #DummyET;
    end_if;
    if NR<= cMaxStandardArray then
      // valid timer
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Status  := IN;                                  // Initial Old := New.
        aTimeData[NR].Timer   := ops.tAbsolute- PT$UDINT;             // Suppress initial puls should IN be '1'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      IN:= IN<> 0;  // BOOL filter for the XOR later on.
      if aTimeData[NR].Status<> IN then
        // Edge detected init timer
        if ops.tAbsolute- aTimeData[NR].Timer>= PT$UDINT then
          aTimeData[NR].Timer   := ops.tAbsolute;             // Start timer
        else
          aTimeData[NR].Timer   := ops.tAbsolute- PT$UDINT;   // Timer already elapsed
        end_if;
        aTimeData[NR].Status  := IN;                          // New= Old
      end_if;
      
      if ops.tAbsolute- aTimeData[NR].Timer>= PT$UDINT then
        // Time has elapsed.
        Q := IN;                                              // Q= new value
        ET^ := 0;
      else
        // Timer is running.
        Q := IN Xor 2#1;                                      // Q= not new value
        ET^ := ops.tAbsolute- aTimeData[NR].Timer;
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q := -1;
      ET^ := 0;
    end_if;
  else
    Q   := -1;
    ET^ := 0;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::TP
	VAR_INPUT
		IN 	: DINT;
		PT 	: DINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    if NR<= cMaxStandardArray then
      // valid timer
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Status := IN;                                   // Initial Old := New.
        aTimeData[NR].Timer  := ops.tAbsolute- PT$UDINT;              // Suppress initial puls should IN be '0'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      if aTimeData[NR].Status = 1   then
        if ops.tAbsolute- aTimeData[NR].Timer >= PT$UDINT then
          // Time has elapsed.
          if IN = 0 then
            aTimeData[NR].Status  := 0;
          end_if;
          Q := 0;
        else
          // Time is running.
          Q := 1;
        end_if;
      else
        Q := 0;
        if IN = 1 then
          // init timer
          aTimeData[NR].Timer  := ops.tAbsolute;
          aTimeData[NR].Status := Q := 1;
        end_if;
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q := -1;
    end_if;
  else
    Q := -1;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::DisplayTP
	VAR_INPUT
		IN 	: DINT;
		PT 	: DINT;
		ET 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
    DummyET : UDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    // Test if ET pointer is valid.
    if ET= nil then
      if MessInvalidPointer= 0 then
        ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbInvalidPointerMess);
        MessInvalidPointer := 1;
      end_if;
      // Overwrite invalid pointer.
      ET := #DummyET;
    end_if;
    if NR<= cMaxStandardArray then
      // valid timer
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Status := IN;                                   // Initial Old := New.
        aTimeData[NR].Timer  := ops.tAbsolute- PT$UDINT;              // Suppress initial puls should IN be '0'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      if aTimeData[NR].Status = 1 then
        if ops.tAbsolute- aTimeData[NR].Timer >= PT$UDINT then
          // Time has elapsed.
          if IN= 0 then
            aTimeData[NR].Status  := 0;
          end_if;
          Q   := 0;
          ET^ := PT$UDINT;
        else
          // Time is running.
          Q   := 1;
          ET^ := ops.tAbsolute- aTimeData[NR].Timer;
        end_if;
      else
        Q   := 0;
        ET^ := 0;
        if IN= 1 then
          // init timer
          aTimeData[NR].Timer  := ops.tAbsolute;
          aTimeData[NR].Status := Q := 1;
          ET^ := ops.tAbsolute- aTimeData[NR].Timer;
        end_if;
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q   := -1;
      ET^ := 0;
    end_if;
  else
    Q   := -1;
    ET^ := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::DELAYS
	VAR_INPUT
		PT 	: DINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    if NR<= cMaxStandardArray then
      // valid timer
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Timer  := ops.tAbsolute- PT$UDINT;              // Suppress initial puls should IN be '0'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      if aTimeData[NR].Status = 1   then
        // Time is running.
        Q := 0;
        if ops.tAbsolute- aTimeData[NR].Timer >= PT$UDINT then
          // Time has elapsed.
          aTimeData[NR].Status  := 0;
          Q := 1;
        end_if;
      else
        // Init timer
        aTimeData[NR].Timer  := ops.tAbsolute;
        aTimeData[NR].Status := 1;
        Q := 0;
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q := -1;
    end_if;
  else
    Q   := -1;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::DisplayDELAYS
	VAR_INPUT
		PT 	: DINT;
		ET 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
    DummyET : UDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> CallBackAddress
        & aTimeData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    // Test if ET pointer is valid.
    if ET= nil then
      if MessInvalidPointer= 0 then
        ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbInvalidPointerMess);
        MessInvalidPointer := 1;
      end_if;
      // Overwrite invalid pointer.
      ET := #DummyET;
    end_if;
    if NR<= cMaxStandardArray then
      // valid timer
      if aTimeData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTimersInuse then NrTimersInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTimeData[NR].Timer  := ops.tAbsolute- PT$UDINT;              // Suppress initial puls should IN be '0'
        aTimeData[NR].CallBackAddress  := CallBackAddress;            // Reserve this number.
      end_if;
      
      if aTimeData[NR].Status = 1   then
        // Time is running.
        Q   := 0;
        ET^ := ops.tAbsolute- aTimeData[NR].Timer;
        if ops.tAbsolute- aTimeData[NR].Timer >= PT$UDINT then
          // Time has elapsed.
          aTimeData[NR].Status  := 0;
          ET^ := 0;
          Q := 1;
        end_if;
      else
        // init timer
        aTimeData[NR].Timer  := ops.tAbsolute;
        aTimeData[NR].Status := 1;
        Q   := 0;
        ET^ := 0;
      end_if;
    else
      //array full
      if STbMessTimerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTimerArrayIsFullMess);
        STbMessTimerFull := 1;
      end_if;
      Q   := -1;
      ET^ := 0;
    end_if;
  else
    Q   := -1;
    ET^ := 0;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::FreezeTime
	VAR_INPUT
		Freeze 	: DINT;
	END_VAR
  VAR
    NR  : DINT;
//		tDelta 	: UDINT;
	END_VAR
  
  tDelta  := 0;
  if Freeze<> 0 then
    tDelta  := ops.tAbsolute- FreezeTimeOld;
    // Freeze all used timers
    NR  := 0;
    while NR<= cMaxStandardArray
        & aTimeData[NR].CallBackAddress<> nil
    do
      // Freeze time
      aTimeData[NR].Timer += tDelta;
      // Next
      NR  += 1;
    end_while;
  end_if;
  FreezeTimeOld := ops.tAbsolute;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::R_TRIG
	VAR_INPUT
		CLK 	: DINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
  END_VAR

  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTriggerData[NR].CallBackAddress<> CallBackAddress
        & aTriggerData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    if NR<= cMaxStandardArray then
      // valid trigger
      if aTriggerData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTriggerInuse then NrTriggerInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTriggerData[NR].Status           := CLK; // ^;                      // Initial Old := New.
        aTriggerData[NR].CallBackAddress  := CallBackAddress;           // Reserve this number.
      end_if;
      
      Q := 0;                             // Start with set to '0'
      if aTriggerData[NR].Status= 0       // Edge detection
       & CLK= 1 // ^= 1
      then
        Q := 1;                           // Edge detected
      end_if;
      aTriggerData[NR].Status := CLK; // ^;    // Old := New
    else
      //array full
      if STbMessTriggerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTriggerArrauIsFullMess);
        STbMessTriggerFull := 1;
      end_if;
      Q := -1;
    end_if;
  else
    Q := -1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::F_TRIG
	VAR_INPUT
		CLK 	: DINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTriggerData[NR].CallBackAddress<> CallBackAddress
        & aTriggerData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    if NR<= cMaxStandardArray then
      // valid trigger
      if aTriggerData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTriggerInuse then NrTriggerInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTriggerData[NR].Status           := CLK;                      // Initial Old := New.
        aTriggerData[NR].CallBackAddress  := CallBackAddress;           // Reserve this number.
      end_if;
      
      Q := 0;                             // Start with set to '0'
      if aTriggerData[NR].Status= 1       // Edge detection
       & CLK= 0
      then
        Q := 1;                           // Edge detected
      end_if;
      aTriggerData[NR].Status := CLK;    // Old := New
    else
      //array full
      if STbMessTriggerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTriggerArrauIsFullMess);
        STbMessTriggerFull := 1;
      end_if;
      Q := -1;
    end_if;
  else
    Q := -1;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::N_TRIG
	VAR_INPUT
		CLK 	: DINT;
	END_VAR
	VAR_OUTPUT
		Q 	: DINT;
	END_VAR
  VAR
  	NR  : UINT;
  	retPtr : ^UDINT;
    CallBackAddress : HDINT;
  END_VAR
  
  // Get return pointer
#ifdef _LSL_TARGETARCH_ARM
  CallBackAddress := LR;
  retPtr  := nil;
#elif _LSL_TARGETARCH_X86
  retPtr  := EBP$^udint;
  retPtr  += Sizeof( Dint);
  CallBackAddress := retPtr^;
#else
  ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbInvalidArchitectureType);
  CallBackAddress := nil;
  retPtr  := nil;
#endif
  if CallBackAddress<> nil then
    // Find NR
    NR  := 0;
    while NR< cMaxStandardArray
        & aTriggerData[NR].CallBackAddress<> CallBackAddress
        & aTriggerData[NR].CallBackAddress<> nil
    do
      NR  += 1;
    end_while;

    if NR<= cMaxStandardArray then
      // valid trigger
      if aTriggerData[NR].CallBackAddress= nil then
        // First
        if Nr>= NrTriggerInuse then NrTriggerInuse  := Nr+ 1; end_if;   // Calc number of timers in use.
        aTriggerData[NR].Status           := CLK;                      // Initial Old := New.
        aTriggerData[NR].CallBackAddress  := CallBackAddress;           // Reserve this number.
      end_if;
      
      Q := 0;                                // Start with set to '0'
      if aTriggerData[NR].Status<> CLK then  // Edge detection
        Q := 1;                              // Edge detected
      end_if;
      aTriggerData[NR].Status := CLK;        // Old := New
    else
      //array full
      if STbMessTriggerFull= 0 then
        ClassSvr  := STbBuildTraceMsg(MsgNr:= STbTriggerArrauIsFullMess);
        STbMessTriggerFull := 1;
      end_if;
      Q := -1;
    end_if;
  else
    Q   := -1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Standard::Imp_Clk
	VAR_INPUT
		pTimeData 	: ^ImpClkStr;
	END_VAR
  
  if pTimeData<> nil then     // Test for invalid pointer.
    // Generate 10mSec Impulse and Clock.
    pTimeData^._Imp10mSec  := 0;
    if ops.tAbsolute- tMark10mSec>= 10 ms then
      tMark10mSec := ops.tAbsolute;
      pTimeData^._Clk10mSec  := ( pTimeData^._Clk10mSec xor 2#1);
      pTimeData^._Imp10mSec  := 1;
    end_if;
    // Generate 100mSec Impulse and Clock.
    pTimeData^._Imp100mSec  := 0;
    if ops.tAbsolute- tMark100mSec>= 100 ms then
      tMark100mSec := ops.tAbsolute;
      pTimeData^._Clk100mSec  := ( pTimeData^._Clk100mSec xor 2#1);
      pTimeData^._Imp100mSec  := 1;
    end_if;
    // Generate 500mSec Impulse and Clock.
    pTimeData^._Imp500mSec  := 0;
    if ops.tAbsolute- tMark500mSec>= 500 ms then
      tMark500mSec := ops.tAbsolute;
      pTimeData^._Clk500mSec  := ( pTimeData^._Clk500mSec xor 2#1);
      pTimeData^._Imp500mSec  := 1;
    end_if;
    // Generate 1Sec Impulse and Clock.
    pTimeData^._Imp1Sec  := 0;
    if ops.tAbsolute- tMark1Sec>= 1 sec then
      tMark1Sec := ops.tAbsolute;
      pTimeData^._Clk1Sec  := ( pTimeData^._Clk1Sec xor 2#1);
      pTimeData^._Imp1Sec  := 1;
    end_if;
    // Generate 10Sec Impulse and Clock.
    pTimeData^._Imp10Sec  := 0;
    if ops.tAbsolute- tMark10Sec>= 10 sec then
      tMark10mSec := ops.tAbsolute; // to sync the puls.
      tMark100mSec := ops.tAbsolute;
      tMark1Sec := ops.tAbsolute;
      tMark10Sec := ops.tAbsolute;
      pTimeData^._Clk10Sec  := ( pTimeData^._Clk10Sec xor 2#1);
      pTimeData^._Imp10Sec  := 1;
    end_if;
  else
    // Invalid pTimeData pointer.
    if MessInvalidPointer= 0 then
      ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbInvalidPointerMess);
      MessInvalidPointer := 1;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL Standard::STbBuildTraceMsg
	VAR_INPUT
		MsgNr 	: STbTraceMsgTxt;
		Value1 	: DINT;(* := 0 *)
		Value2 	: DINT;(* := 0 *)
		Value3 	: DINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		Status 	: DINT;
	END_VAR

  case MsgNr of
(*
 * Timer & Trigger error's
 *)
  STbTimerArrayIsFullMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln1("Timer array from Object: '%s' is full.", (#aObjName)$Dint);
    // To Debugger Trace.
    TRACE0("Timer array from Object: '{0}' is full.", #aObjName[0]);
    Status  := -101;
  STbTriggerArrauIsFullMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln1("Trigger array from Object: '%s' is full.", (#aObjName)$Dint);
    // To Debugger Trace.
    TRACE0("Trigger array from Object: '{0}' is full.", #aObjName[0]);
    Status  := -102;
(*
 * Next
 *)
  else  // Unknown
    // To Event01.log.
    ToSysMsg.ULPrintfln1("Object: '%s'. Unknown TraceMsgTxt type.",  (#aObjName)$Dint);
    // To Debugger Trace.
    TRACE0("Object: '{0}'. Unknown TraceMsgTxt type.", #aObjName[0]);
    Status  := -999899;
  end_case;

END_FUNCTION
