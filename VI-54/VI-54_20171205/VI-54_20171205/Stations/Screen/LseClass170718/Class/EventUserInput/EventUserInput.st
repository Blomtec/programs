//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

// Eigenschaften der Buffer
//----------------------------------------------------------------------------------------------------------------------------

#define   EventUser_MaxBufferLength     200           // Maximale Anzahl an Zeichen
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "EventUserInput"
	Revision           = "1.1"
	GUID               = "{3DA7B406-5D59-493F-A11A-DE0C1F9F2F16}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,240)"
	Comment            = "class to create a user-input for the the EventJournal ">
	<Channels>
		<Server Name="OpenInput" GUID="{98633D5A-1D2D-49F0-8841-8571B2BDCFE7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="write() will open the toucheditorwindow for input"/>
		<Client Name="coEventQueue" Required="true" Internal="false" Comment="object channel to EventQueue"/>
		<Client Name="coSystemLogging" Required="false" Internal="false" Comment="object channel to SystemLogging (optional)"/>
		<Client Name="StringEventUser" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="KaiAnd"/>
		<Dokumentation Revision="1.1" Date="2016-08-30" Author="KaiAnd" Company="Sigmatek" Description="changed procedure to get the name of the own object - the object name no longer must be &quot;EventUserInput1&quot;!"/>
		<Dokumentation Revision="1.0" Date="2016-05-20" Author="KaiAnd" Company="Sigmatek" Description="created; for user-input into the EventJournal"/>
	</RevDoku>
	<Network Name="EventUserInput">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{2694846C-E522-4301-800E-89061C26D046}"
				Class      = "_Global"
				Position   = "(120,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
			<Object
				Name       = "StringEventUser"
				GUID       = "{20EF9F71-98DE-4E0D-A3CE-1032B48119F0}"
				Class      = "String"
				Position   = "(120,360)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(848,210),(420,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(120,210),(38,210),"/>
			<Connection Source="this.StringEventUser" Destination="StringEventUser.Data"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Global

EventUserInput : CLASS
: _Global
  //Servers:
	OpenInput 	: SvrCh_DINT;
  //Clients:
	StringEventUser 	: CltChCmd_String;
	coEventQueue 	: CltChCmd_EventQueue;
	coSystemLogging 	: CltChCmd_SystemLogging;
  //Variables:
		udVarNo_InpString 	: UDINT;
		IsCon_coSystemLogging 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="methode will be called after lse-project is successfully loaded and &#13;&#10;possibly given communication to extern plc is stable" Name="IF_ProjectReady"/>
	FUNCTION VIRTUAL GLOBAL IF_ProjectReady
		VAR_INPUT
			state 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_InputIsSaved
		VAR_INPUT
			pi 	: ^_INPUT;
			pr 	: ^_RESULT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OpenInput::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd EventQueue
#pragma usingLtd SystemLogging


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB EventUserInput::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EVENTUSERINPUT
1$UINT, 1$UINT, (SIZEOF(::EventUserInput))$UINT, 
1$UINT, 3$UINT, 0$UINT, 
TO_UDINT(2089343112), "EventUserInput", //Class
TO_UDINT(3788417926), "_Global", 0$UINT, 14$UINT, //Baseclass
//Servers:
(::EventUserInput.OpenInput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2017139974), "OpenInput", 
//Clients:
(::EventUserInput.StringEventUser.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(958982240), "StringEventUser", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::EventUserInput.coEventQueue.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2896066780), "coEventQueue", TO_UDINT(915169004), "EventQueue", 1$UINT, 3$UINT, 
(::EventUserInput.coSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(292037947), "coSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_EventUserInput 44

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_EventUserInput] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION EventUserInput::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Global::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Global::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Global::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_EventUserInput;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #IF_ProjectReady();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #IF_InputIsSaved();

#pragma warning (default : 74)
	_Global::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Global::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	OpenInput.pMeth			:= StoreMethod( #M_RD_DIRECT(), #OpenInput::Write() );
	IF OpenInput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL EventUserInput::Init


  // Methode der Basis-Klasse
  _Global::Init();

  if (_FirstScan) then

    //---------------------------------------------------------------------------------------------
    //  check client-connnections and set flags
    //---------------------------------------------------------------------------------------------
    if (IsClientConnected(#coSystemLogging)) then
      IsCon_coSystemLogging := TRUE;
    else
      IsCon_coSystemLogging := FALSE;
    end_if;


  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL EventUserInput::IF_ProjectReady
#pragma warning(disable:73); // disable warning 
  VAR_INPUT
		state 	: BOOL;
  END_VAR
#pragma warning(default:73); 
	VAR_OUTPUT
		retcode : BOOL;
	END_VAR
  VAR
    VarNoMe   : UDINT;
    dummy     : _UBYTE;
    myObjName : Array [0..99] of CHAR;   // ObjektName
  END_VAR

  //===============================================================================================
  //  Besorge eindeutige VAR-No des Strings für UserEvent-Input
  //===============================================================================================

  //---------------------------------------------------------------------------------------------
  //  den Namen des eigenen Objektes besorgen  V.1.1
  //---------------------------------------------------------------------------------------------
  VarNoMe := VarList_GetVarNoByID(x0:=this$udint, x1:=255, x2:=_FALSE);
  VarList_GetLabel(p0:=#myObjName[0], p1:=#dummy, x2:=VarNoMe);

  _strcat(dest:=#myObjName[0], src:="\StringEventUser.Data");   // Namen des eingebetteten String-Objektes anfügen
 
  //---------------------------------------------------------------------------------------------
  // VAR-No nun besorgen  
  //---------------------------------------------------------------------------------------------
  udVarNo_InpString := VarList_GetVarNoStation(p0 := #myObjName[0], station := 255);

  retcode := TRUE;  // Retcode setzen, sonst kann Visu stehen bleiben
  
  //===============================================================================================

END_FUNCTION


FUNCTION VIRTUAL GLOBAL EventUserInput::OpenInput::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	OpenInput := input;
	result := OpenInput;

  //---------------------------------------------------------------------------------------
  //  Init Input
  //---------------------------------------------------------------------------------------
  StringEventUser.Clear();

  //---------------------------------------------------------------------------------------
  //  Command an LSE: öffne toucheditorwindow für Input auf angegebene VAR
  //---------------------------------------------------------------------------------------
  InsertCmd(x0 := CMD_EDITSERVER_HID,
            x1 := udVarNo_InpString$DINT,
            x2 := 0);

  //---------------------------------------------------------------------------------------

END_FUNCTION


FUNCTION VIRTUAL GLOBAL EventUserInput::IF_InputIsSaved
	VAR_INPUT
		pi 	: ^_INPUT;
		pr 	: ^_RESULT;
	END_VAR
  VAR
    tmpString       : ARRAY [0..EventUser_MaxBufferLength] OF _CHAR;
    tmpStringLength : UDINT;
  END_VAR

  //===============================================================================================
  //  auf "eigenen Input" reagieren (ASCII, eigene VAR-No)
  //===============================================================================================
  case pi^.io.typ of

    AS_ASCII:

      if ( (pi^.io.variable.info[0].state = VAR_VAL) &
           (pi^.io.variable.info[0].value = udVarNo_InpString$DINT) ) then

        tmpStringLength := StringEventUser.GetLength();
        if ((tmpStringLength > 0) & (tmpStringLength < EventUser_MaxBufferLength)) then

          //----- Event-String holen ----------------------------------------------------------
          StringEventUser.GetDataAt(pData:=#tmpString[0]$char, udSize:=tmpStringLength, udAt:=2);

          //----- Event-String eintragen ------------------------------------------------------
          if (coEventQueue.AddUserEvent(pEventString:=#tmpString[0]) = false) then

            if (IsCon_coSystemLogging = True) then
              coSystemLogging.LogEventText("EventQueue.AddUserEvent(): Benutzer-Event konnte nicht in EventJournal eingetragen werden");
            end_if;

          end_if;

        end_if;

      end_if;

  end_case;

  //===============================================================================================

END_FUNCTION



