//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "EventJournal"
	Revision           = "1.2"
	GUID               = "{68B1F60E-0170-4664-9821-71CDD84397DE}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,480)"
	Comment            = "main class of the EventJournal (event list draw, export, ...)">
	<Channels>
		<Server Name="DisplayFilter" GUID="{EB94E5C4-E456-47FE-B1CE-7AEB8D768511}" Visualized="true" Initialize="true" DefValue="2#1111111111" WriteProtected="false" Retentive="false" Comment="Filter for displaying the event types in the list&#13;&#10;Bit 0 = System Messsage Cat.1&#13;&#10;Bit 1 = System Messsage Cat.2&#13;&#10;Bit 2 = System Messsage Cat.3&#13;&#10;Bit 3 = System Messsage Cat.4&#13;&#10;Bit 4 = Alarm&#13;&#10;Bit 5 = System On/Off&#13;&#10;Bit 6 = Login/Logout&#13;&#10;Bit 7 = value changes&#13;&#10;Bit 8 = User-Event&#13;&#10;Bit 9 = switching operation mode"/>
		<Server Name="ExportProgress" GUID="{EB02E0BC-FBAB-4EDC-9048-4C58A337440A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="progress value during export (0 - 1000)"/>
		<Client Name="ccNewEvent" Required="false" Internal="false" Comment="command channel to share new events (optional)"/>
		<Client Name="coDriveLetter" Required="true" Internal="false"/>
		<Client Name="coEventTitle" Required="false" Internal="false" Comment="object channel to EventTitleLine (optional)"/>
		<Client Name="coFileSys" Required="false" Internal="false" Comment="object channel to FileSys (don&apos;t connect!)"/>
		<Client Name="ColumnChoice" Required="true" Internal="false" Comment="Bitmuster zum Enablen der Darstellung von Display-Items&#13;&#10;2#00001 = Event Zeitstempel&#13;&#10;2#00010 = Parameter 1&#13;&#10;2#00100 = Alarmnummer&#13;&#10;2#01000 = Parameter 2&#13;&#10;2#10000 = Beschreibung&#13;&#10;"/>
		<Client Name="coSigCLib" Required="false" Internal="false"/>
		<Client Name="coStdLib" Required="false" Internal="false" Comment="object channel to SdtLib (don&apos;t connect!)"/>
		<Client Name="coSystemLogging" Required="false" Internal="false" Comment="object channel to SystemLogging (optional)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\EventJournal\Event.h" Include="true"/>
			<File Path=".\Class\EventJournal\EventJournal.UDC"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.2" Date="2016-08-30" Author="KaiAnd" Company="Sigmatek" Description="command channel &quot;ccNewEvent&quot; implemented to share new events for external use&#13;&#10;... new overwritten function ::AddEntry()&#13;&#10;... changed functions ::GetEventTime(), ::GetAlarmNo(), ::GetParameter1(), ::GetParameter2()"/>
		<Dokumentation Revision="1.1" Date="2016-07-13" Author="Roskri" Company="Sigmatek" Description="Changed define for event window in Lasal SCREEN"/>
		<Dokumentation Revision="1.0" Date="2016-06-15" Author="KaiAnd" Company="Sigmatek" Description="Renamed and upgraded (taken from Class EventHistory)"/>
		<Dokumentation Revision="0.38" Date="2016-02-24" Author="WitJul" Company="Sigmatek" Description="output an empty line with the right colors if there are too little columns for the whole width"/>
		<Dokumentation Revision="0.37" Date="2016-02-17" Author="WitJul" Company="Sigmatek" Description="deactivate the cursor line"/>
		<Dokumentation Revision="0.36" Date="2015-10-29" Author="BraLis" Company="Sigmatek" Description="completed method ExportEvents() in step WriteHeader and FillBuffer&#13;&#10;"/>
		<Dokumentation Revision="0.35&#13;&#10;" Date="2015-09-30" Author="BraLis" Company="Sigmatek" Description="in the methods GetTextEventXXXChange were some mistakes we mended"/>
		<Dokumentation Revision="0.34" Date="2015-09-29" Author="BraLis" Company="Sigmatek" Description="insert the method SystemLogging::LogEventText instead of TRACE-Messages"/>
		<Dokumentation Revision="0.33" Date="2015-09-28" Author="KruAle" Company="Sigmatek" Description="get udc-data in IF_Start."/>
		<Dokumentation Revision="0.32&#13;&#10;" Date="2015-09-25" Author="BraLis" Company="Sigmatek" Description="if you export the event history, the title line will also be exported&#13;&#10;"/>
		<Dokumentation Revision="0.31" Date="2015-09-23" Author="BraLis" Company="Sigmatek" Description="Deleted unnecessary defines in the Headerfile Event.h&#13;&#10;"/>
		<Dokumentation Revision="0.30" Date="2015-09-22" Company="Sigmatek" Description="Creation."/>
	</RevDoku>
	<Network Name="EventJournal">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{74832085-F81D-465B-8CD0-16FB90DA114D}"
				Class      = "_AlarmDisplay"
				Position   = "(240,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Acknowledge"/>
					<Server Name="ActPos"/>
					<Server Name="Delete"/>
					<Server Name="NoActive"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Server Name="SortAlgorithm"/>
					<Client Name="Filter"/>
					<Client Name="HistoryTemporary"/>
					<Client Name="Lse"/>
					<Client Name="MaxNo"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(964,210),(792,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(964,270),(792,270),"/>
			<Connection Source="this.Delete" Destination="_base.Delete" Vertices="(964,330),(792,510),"/>
			<Connection Source="_base.MaxNo" Destination="this.MaxNo" Vertices="(240,330),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _AlarmDisplay

EventJournal : CLASS
: _AlarmDisplay
	TYPE
	  T_BITS : BDINT  //! <Type Public="true" Name="T_BITS"/>
	  [
	    1 Bit1,
	    2 Bit2,
	    3 Bit3,
	    4 Bit4,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	  t_e_FileState :
	  (
	    EventJournal_STARTEXPORT:=0,
	    EventJournal_CREATEDIR:=1,
	    EventJournal_WAIT4CREATEDIR:=2,
	    EventJournal_FILEOPEN:=3,
	    EventJournal_WAIT4FILEOPEN:=4,
	    EventJournal_WRITEHEADER:=5,
	    EventJournal_WAIT4WRITEHEADER:=6,
	    EventJournal_FILLBUFFER:=7,
	    EventJournal_FILEWRITE:=8,
	    EventJournal_WAIT4FILEWRITE:=9,
	    EventJournal_FILECLOSE:=10,
	    EventJournal_WAIT4FILECLOSE:=11
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_CategorieColors : STRUCT
	    Cat_TextColor : _COLOR;
	    Cat_BgColor : _COLOR;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_EventConfig : STRUCT
	    aColumnWidths : ARRAY [0..Event_VariableNo-1] OF DINT;
	    aCategorieColors : ARRAY [0..5] OF t_s_CategorieColors;
	    SystemOnOff : _ANYTHING;
	    OPMode : _ANYTHING;
	    EventTitleTextScheme : _ANYTHING;
	    LoginLogout : _ANYTHING;
	    SystemEntryCategory1 : _ANYTHING;
	    SystemEntryCategory2 : _ANYTHING;
	    SystemEntryCategory3 : _ANYTHING;
	    SystemEntryCategory4 : _ANYTHING;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_FolderPaths : STRUCT
	    FolderPath : ARRAY [0..99] OF CHAR;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_FolderPathList : STRUCT
	    uiFolderNr : UINT;
	    FolderPaths : ARRAY [1..Event_DefaultPath_MAX_Folder] OF t_s_FolderPaths;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	DisplayFilter 	: SvrCh_T_BITS_PTofCls_EventJournal;
	ExportProgress 	: SvrCh_UDINT;
  //Clients:
	coFileSys 	: CltChCmd__FileSys;
	coStdLib 	: CltChCmd__StdLib;
	coSigCLib 	: CltChCmd_SigCLib;
	ColumnChoice 	: CltCh_BDINT;
	coEventTitle 	: CltChCmd_TitleLine;
	coSystemLogging 	: CltChCmd_SystemLogging;
	coDriveLetter 	: CltChCmd_String;
	ccNewEvent 	: CltChCmd_DINT;
  //Variables:
		aBlank : ARRAY [0..1] OF CHAR;

		aColSep : ARRAY [0..2] OF CHAR;

		aLineEnd : ARRAY [0..2] OF CHAR;

		aFilename : ARRAY [0..Event_MaxFilenameLength] OF CHAR;

		dAsyncID 	: DINT;
		dAsyncState 	: DINT;
		dFileHandle 	: DINT;
		dFileWrite 	: DINT;
		eEventFileState 	: t_e_FileState;
		pBuffer 	: ^_CHAR;			//! <Variable Comment="Puffer mit dem die Daten in die Datei geschrieben werden." Name="pBuffer"/>
		pEndBuffer 	: ^_CHAR;			//! <Variable Comment="Zeiger auf das Ende des Puffers." Name="pEndBuffer"/>
		pWriteBuffer 	: ^_CHAR;			//! <Variable Comment="Zeiger auf die aktuelle Position im Puffer." Name="pWriteBuffer"/>
		udAddedDataLength 	: UDINT;
		udBlankLength 	: UDINT;
		udCommaLength 	: UDINT;
		udLineEndLength 	: UDINT;
		udTimeStamp 	: UDINT;
		iOldScrollOffset 	: INT;
		EventConfig 	: t_s_EventConfig;
		bInitialized 	: BOOL;
		ExportActLineNr 	: UDINT;
		ExportLineNumbers 	: UDINT;
		bGetTheurgeData 	: BOOL;
		aVarSingle : ARRAY [0..Event_VariableNo-1] OF _VARSINGLE;

		IsCon_coSystemLogging 	: BOOL;
		IsCon_coEventTitle 	: BOOL;
		tmpText : ARRAY [0..599] OF _CHAR;

		tmpEvTxt : ARRAY [0..79] OF _CHAR;

		FolderPathList 	: t_s_FolderPathList;
		uiCreatedFolderCnt 	: UINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to redraw the io&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;pr ........ pointer to result information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when redraw of a single line is necessary.&#13;&#10;ps ..... --&gt; to structure _SCROLL&#13;&#10;pr ..... --&gt; to place where line should be drawn&#13;&#10;line ... number of line which should be drawn&#13;&#10;state .. line ia selected (TRUE) or passive (FALSE)&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to structure _SCROLL" Name="Line.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to place where line should be drawn" Name="Line.pr"/>
			line 	: UINT;			//! <Variable Comment="16 bit linenumber " Name="Line.line"/>
			state 	: BOOL;			//! <Variable Comment="line is selected (true) or passive (false)" Name="Line.state"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when system wants to insert an entry into ringbuffer&#13;&#10;call this methode if you want to add an entry&#13;&#10;if you decide that entry shouldn&apos;t be added, dont call function add_SINGLEALARM() inside&#13;&#10;ptr .... --&gt; to new entry&#13;&#10;at success method returns TRUE, on the other hand FALSE&#13;&#10;" Name="AddEntry"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AddEntry
		VAR_INPUT
			ptr 	: ^_SINGLEALARM;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="Calculates the width of all columns" Name="CalcWidth"/>
	FUNCTION CalcWidth;
				//! <Function Comment="returns the alarm number of a alarm as pointer to a text and as value" Name="GetAlarmNo"/>
	FUNCTION GetAlarmNo
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="GetAlarmNo.pEntry"/>
			pRetDINT 	: ^DINT;			//! <Variable Comment="pointer to return the value (DINT)" Name="GetAlarmNo.pRetDINT"/>
		END_VAR
		VAR_OUTPUT
			pString 	: ^_CHAR;			//! <Variable Comment="Alarmnumber, in case that the entry was an alarm" Name="GetAlarmNo.pString"/>
		END_VAR;
				//! <Function Comment="Returns a pointer to a text for the different events." Name="GetEventText"/>
	FUNCTION VIRTUAL GetEventText
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="GetEventText.pEntry"/>
		END_VAR
		VAR_OUTPUT
			pEventTxt 	: ^_CHAR;			//! <Variable Comment="Pointer to the event text" Name="GetEventText.pEventTxt"/>
		END_VAR;
				//! <Function Comment="Returns a pointer to a text and the values with date and time when the event occured" Name="GetEventTime"/>
	FUNCTION GetEventTime
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="GetEventTime.pEntry"/>
			pRetdDate 	: ^DINT;			//! <Variable Comment="pointer to return the Date as DINT" Name="GetEventTime.pRetdDate"/>
			pRetdTime 	: ^DINT;			//! <Variable Comment="pointer to return the Time as DINT" Name="GetEventTime.pRetdTime"/>
		END_VAR
		VAR_OUTPUT
			pString 	: ^_CHAR;			//! <Variable Comment="Pointer to the text with the date and the time" Name="GetEventTime.pString"/>
		END_VAR;
				//! <Function Comment="Returns a pointer to a text and the value for the parameter 1" Name="GetParameter1"/>
	FUNCTION GetParameter1
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="GetParameter1.pEntry"/>
			pRetDINT 	: ^DINT;			//! <Variable Comment="pointer to return the value (DINT)" Name="GetParameter1.pRetDINT"/>
		END_VAR
		VAR_OUTPUT
			pString 	: ^_CHAR;			//! <Variable Comment="Pointer to the text of the parameter 1" Name="GetParameter1.pString"/>
		END_VAR;
				//! <Function Comment="Returns a pointer to a text and the value for the parameter 2" Name="GetParameter2"/>
	FUNCTION GetParameter2
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="GetParameter2.pEntry"/>
			pRetDINT 	: ^DINT;			//! <Variable Comment="pointer to return the value (DINT)" Name="GetParameter2.pRetDINT"/>
		END_VAR
		VAR_OUTPUT
			pString 	: ^_CHAR;			//! <Variable Comment="Pointer to the text of the parameter 2" Name="GetParameter2.pString"/>
		END_VAR;
				//! <Function Comment="Returns a pointer to a text for a date change" Name="GetTextEventDateChange"/>
	FUNCTION GetTextEventDateChange
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="GetTextEventDateChange.pEntry"/>
		END_VAR
		VAR_OUTPUT
			pString 	: ^_CHAR;			//! <Variable Comment="Pointer to the text of the date change" Name="GetTextEventDateChange.pString"/>
		END_VAR;
				//! <Function Comment="Returns a pointer to a text for a menu change." Name="GetTextEventMenueChange"/>
	FUNCTION GetTextEventMenueChange
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of a list entry" Name="GetTextEventMenueChange.pEntry"/>
		END_VAR
		VAR_OUTPUT
			pString 	: ^_CHAR;			//! <Variable Comment="Pointer to the text for the menu change" Name="GetTextEventMenueChange.pString"/>
		END_VAR;
				//! <Function Comment="Returns a pointer to a text for a time change." Name="GetTextEventTimeChange"/>
	FUNCTION GetTextEventTimeChange
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="GetTextEventTimeChange.pEntry"/>
		END_VAR
		VAR_OUTPUT
			pString 	: ^_CHAR;			//! <Variable Comment="Pointer to the text for the time change" Name="GetTextEventTimeChange.pString"/>
		END_VAR;
				//! <Function Comment="Returns a pointer to a text for a value change" Name="GetTextEventValueChange"/>
	FUNCTION GetTextEventValueChange
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="GetTextEventValueChange.pEntry"/>
		END_VAR
		VAR_OUTPUT
			pString 	: ^_CHAR;			//! <Variable Comment="Pointer to the text for the value change" Name="GetTextEventValueChange.pString"/>
		END_VAR;
				//! <Function Comment="This method reads the data, which were deliverd by the UDC, with help of the theurge-pointer." Name="GetTheUrge"/>
	FUNCTION GetTheUrge
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="Pointer to the _IO information" Name="GetTheUrge.pio"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE .. Ok&#13;&#10;FALSE .. Error" Name="GetTheUrge.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Get the values for the column width from the server, if theser were defined as server values in LSE." Name="GetTheUrgeValues"/>
	FUNCTION GetTheUrgeValues
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="Pointer to the _IO information" Name="GetTheUrgeValues.pio"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE .. Ok&#13;&#10;FALSE .. Error" Name="GetTheUrgeValues.bSuccessful"/>
		END_VAR;
				//! <Function Comment="This method draws the dividing lines between the list entrys." Name="TableLines"/>
	FUNCTION TableLines
		VAR_INPUT
			sColor 	: _COLOR;			//! <Variable Comment="Color of the dividing lines" Name="TableLines.sColor"/>
			pRoom 	: ^_ROOM;			//! <Variable Comment="Pointer to the position information of the entry" Name="TableLines.pRoom"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE .. Ok&#13;&#10;FALSE .. pRoom was NIL" Name="TableLines.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Gets the text for the alarmnumber and outputs it on a specific position." Name="WriteAlarmNo"/>
	FUNCTION WriteAlarmNo
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="WriteAlarmNo.pEntry"/>
			pRoom 	: ^_ROOM;			//! <Variable Comment="Pointer to the position information of the entry" Name="WriteAlarmNo.pRoom"/>
			sFont 	: _FONT;			//! <Variable Comment="Font of the list entry" Name="WriteAlarmNo.sFont"/>
			sTextColor 	: _COLOR;			//! <Variable Comment="Text color" Name="WriteAlarmNo.sTextColor"/>
			sBackColor 	: _COLOR;			//! <Variable Comment="Background color" Name="WriteAlarmNo.sBackColor"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE .. Ok&#13;&#10;FALSE .. pRoom or pEntry was NIL" Name="WriteAlarmNo.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Writes a line into the event journal." Name="WriteEventEntry"/>
	FUNCTION WriteEventEntry
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="WriteEventEntry.pEntry"/>
			pRoom 	: ^_ROOM;			//! <Variable Comment="Pointer to the position data of the list entry" Name="WriteEventEntry.pRoom"/>
			sFont 	: _FONT;			//! <Variable Comment="Font of the list entry" Name="WriteEventEntry.sFont"/>
			sTextColor 	: _COLOR;			//! <Variable Comment="Text color" Name="WriteEventEntry.sTextColor"/>
			sBackColor 	: _COLOR;			//! <Variable Comment="Background color" Name="WriteEventEntry.sBackColor"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE .. Ok&#13;&#10;FALSE .. pRoom or pEntry was NIL" Name="WriteEventEntry.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Gets the text for the description of an event and outputs it on a specific position." Name="WriteEventText"/>
	FUNCTION WriteEventText
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="WriteEventText.pEntry"/>
			pRoom 	: ^_ROOM;			//! <Variable Comment="Pointer to the position data of the list entry" Name="WriteEventText.pRoom"/>
			sFont 	: _FONT;			//! <Variable Comment="Font of the list entry" Name="WriteEventText.sFont"/>
			sTextColor 	: _COLOR;			//! <Variable Comment="Text color" Name="WriteEventText.sTextColor"/>
			sBackColor 	: _COLOR;			//! <Variable Comment="Background color" Name="WriteEventText.sBackColor"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE .. Ok&#13;&#10;FALSE .. pRoom or pEntry was NIL" Name="WriteEventText.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Gets the text for date and time when a event occured and outputs it on a specific position." Name="WriteEventTime"/>
	FUNCTION WriteEventTime
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="WriteEventTime.pEntry"/>
			pRoom 	: ^_ROOM;			//! <Variable Comment="Pointer to the position data of the entry" Name="WriteEventTime.pRoom"/>
			sFont 	: _FONT;			//! <Variable Comment="Font of the list entry" Name="WriteEventTime.sFont"/>
			sTextColor 	: _COLOR;			//! <Variable Comment="Text color" Name="WriteEventTime.sTextColor"/>
			sBackColor 	: _COLOR;			//! <Variable Comment="Background color" Name="WriteEventTime.sBackColor"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE .. Ok&#13;&#10;FALSE .. pRoom or pEntry was NIL" Name="WriteEventTime.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Gets the text for the parameter 1 of an event and outputs it on a specific position." Name="WriteParameter1"/>
	FUNCTION WriteParameter1
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="WriteParameter1.pEntry"/>
			pRoom 	: ^_ROOM;			//! <Variable Comment="Pointer to the position data of the entry" Name="WriteParameter1.pRoom"/>
			sFont 	: _FONT;			//! <Variable Comment="Font of the list entry" Name="WriteParameter1.sFont"/>
			sTextColor 	: _COLOR;			//! <Variable Comment="Textcolor" Name="WriteParameter1.sTextColor"/>
			sBackColor 	: _COLOR;			//! <Variable Comment="Background color" Name="WriteParameter1.sBackColor"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE .. Ok&#13;&#10;FALSE .. pRoom or pEntry was NIL" Name="WriteParameter1.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Gets the text for the parameter 2 (user level) of an event and outputs it on a specific position." Name="WriteParameter2"/>
	FUNCTION WriteParameter2
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="WriteParameter2.pEntry"/>
			pRoom 	: ^_ROOM;			//! <Variable Comment="Pointer to the position data of the entry" Name="WriteParameter2.pRoom"/>
			sFont 	: _FONT;			//! <Variable Comment="Font of the list entry" Name="WriteParameter2.sFont"/>
			sTextColor 	: _COLOR;			//! <Variable Comment="Text color" Name="WriteParameter2.sTextColor"/>
			sBackColor 	: _COLOR;			//! <Variable Comment="Background color" Name="WriteParameter2.sBackColor"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE .. Ok&#13;&#10;FALSE .. pRoom or pEntry was NIL" Name="WriteParameter2.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Exporting events to csv file" Name="ExportEvents"/>
	FUNCTION VIRTUAL GLOBAL ExportEvents
		VAR_INPUT
			ExportFilter 	: BDINT;			//! <Variable Comment="Filter for exporting the event types&#13;&#10;Bit 0 = System Messsage Cat.1&#13;&#10;Bit 1 = System Messsage Cat.2&#13;&#10;Bit 2 = System Messsage Cat.3&#13;&#10;Bit 3 = System Messsage Cat.4&#13;&#10;Bit 4 = Alarm&#13;&#10;Bit 5 = System On/Off&#13;&#10;Bit 6 = Login/Logout&#13;&#10;Bit 7 = value changes&#13;&#10;Bit 8 = User-Event&#13;&#10;Bit 9 = switching operation mode" Name="ExportEvents.ExportFilter"/>
			ExFilt_Date1 	: HDINT;			//! <Variable Comment="begin-date for export" Name="ExportEvents.ExFilt_Date1"/>
			ExFilt_Date2 	: HDINT;			//! <Variable Comment="end-date for export" Name="ExportEvents.ExFilt_Date2"/>
			ExFilt_Time1 	: HDINT;			//! <Variable Comment="begin-time for export" Name="ExportEvents.ExFilt_Time1"/>
			ExFilt_Time2 	: HDINT;			//! <Variable Comment="end-time for export" Name="ExportEvents.ExFilt_Time2"/>
		END_VAR
		VAR_OUTPUT
			eRetcode 	: iprStates;			//! <Variable Comment="BUSY .. Export is running&#13;&#10;ERROR .. Error during export&#13;&#10;READY .. Export successfull done" Name="ExportEvents.eRetcode"/>
		END_VAR;
				//! <Function Comment="Checks if a event should be output, based on the configuration of the filter (Server DisplayFilter)." Name="ChkEventDispFilter"/>
	FUNCTION ChkEventDispFilter
		VAR_INPUT
			pEventEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the list entry" Name="ChkEventDispFilter.pEventEntry"/>
		END_VAR
		VAR_OUTPUT
			FilterOK 	: BOOL;			//! <Variable Comment="TRUE .. Output event&#13;&#10;FALSE .. Don&apos;t output event" Name="ChkEventDispFilter.FilterOK"/>
		END_VAR;
	
	FUNCTION SplitPath
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DisplayFilter::Write
		VAR_INPUT
			input (EAX) 	: EventJournal::T_BITS;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: EventJournal::T_BITS;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib
#pragma usingLtd String
#pragma usingLtd SystemLogging
#pragma usingLtd TitleLine


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB EventJournal::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EVENTJOURNAL
1$UINT, 2$UINT, (SIZEOF(::EventJournal))$UINT, 
2$UINT, 8$UINT, 0$UINT, 
TO_UDINT(2671722124), "EventJournal", //Class
TO_UDINT(1738954212), "_AlarmDisplay", 0$UINT, 9$UINT, //Baseclass
//Servers:
(::EventJournal.DisplayFilter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3537939087), "DisplayFilter", 
(::EventJournal.ExportProgress.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(766264334), "ExportProgress", 
//Clients:
(::EventJournal.coFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(940542775), "coFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
(::EventJournal.coStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3815072667), "coStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::EventJournal.coSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1750761597), "coSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 14$UINT, 
(::EventJournal.ColumnChoice.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3823519998), "ColumnChoice", 
(::EventJournal.coEventTitle.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4166352852), "coEventTitle", TO_UDINT(112430022), "TitleLine", 1$UINT, 1$UINT, 
(::EventJournal.coSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(292037947), "coSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 4$UINT, 
(::EventJournal.coDriveLetter.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2932290194), "coDriveLetter", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::EventJournal.ccNewEvent.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1081042515), "ccNewEvent", 
END_FUNCTION


#define USER_CNT_EventJournal 30

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_EventJournal] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION EventJournal::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _AlarmDisplay::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_EventJournal;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #AddEntry();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #GetEventText();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #ExportEvents();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DisplayFilter.pMeth			:= StoreMethod( #M_RD_DIRECT(), #DisplayFilter::Write() );
	IF DisplayFilter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION __CDECL VIRTUAL GLOBAL EventJournal::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR

  if (IsCon_coEventTitle = True) then    // KaiAnd
    if (bGetTheurgeData = FALSE) then
      bGetTheurgeData := coEventTitle.GetTitleTxtScheme(pTxtScheme:=#EventConfig.EventTitleTextScheme);
    end_if;
  end_if;
    
  // Prüfen ob sich die Auswahl der Spalten geändert hat
  //-----------------------------------------------------------------------------------------
  if (ColumnChoice <> ColumnChoice.Read()) then
    
    // Konfiguration speichern
    ColumnChoice := ColumnChoice.Read();
    
    // neue horizontale Breite berechnen
    CalcWidth();
    
    // horizontale Position wieder rücksetzen
    Scroll.position.pos    := 0;
    Scroll.position.begin  := 0;
    Scroll.hposition.pos   := 0;
    Scroll.hposition.begin := 0;
    
    // neu zeichnen
    Out(pio);
    
  end_if;

  // Basisklasse aufrufen
  //-----------------------------------------------------------------------------------------
  _AlarmDisplay::IF_Run(pio, input);
                        
END_FUNCTION


FUNCTION VIRTUAL GLOBAL EventJournal::Init

  if (_FirstScan) then
    
    // Methode der Basis-Klasse
    _AlarmDisplay::Init();
        

    //-----------------------------------------------------------------------------------------
    //  check client-connnections and set flags                   KaiAnd
    //-----------------------------------------------------------------------------------------
    if (IsClientConnected(#coSystemLogging)) then
      IsCon_coSystemLogging := TRUE;
    else
      IsCon_coSystemLogging := FALSE;
    end_if;
    if (IsClientConnected(#coEventTitle)) then
      IsCon_coEventTitle := TRUE;
    else
      IsCon_coEventTitle := FALSE;
    end_if;


    // Speicher für Events allokieren
    //-----------------------------------------------------------------------------------------
    pBuffer$^void := coStdLib.Malloc(size := Event_BufferLength);
    if (pBuffer = NIL) then
      if (IsCon_coSystemLogging = True) then    // KaiAnd
        coSystemLogging.LogEventText("EventJournal::Init(): Speicher allokieren für den Puffer zum Dateischreiben fehlgeschlagen" );
      end_if;
      return;
    else
      // Schreibezeiger und Zeiger auf Ende des Puffers setzen
      pWriteBuffer  := pBuffer;
      pEndBuffer    := pBuffer + EVENT_BUFFERLENGTH;
    end_if;

    // Arrays für Dateischreiben setzen
    //-----------------------------------------------------------------------------------------
    aLineEnd[0] := Event_CarriageReturn;
    aLineEnd[1] := Event_LineFeed;
    aLineEnd[2] := 0;
    aBlank[0]   := Event_Blank;
    aBlank[1]   := 0;
    aColSep[0]  := Event_Semikolon;
    aColSep[1]  := Event_Blank;
    aColSep[2]  := 0;
    
    // Länge des der Trennzeichen-Strings bestimmen
    udCommaLength   := StrLen(txt:=#aColSep[0], size:=sizeof(aColSep[0])) * sizeof(_CHAR);
    udLineEndLength := StrLen(txt:=#aLineEnd[0], size:=sizeof(aLineEnd[0])) * sizeof(_CHAR);
    udBlankLength   := StrLen(txt:=#aBlank[0], size:=sizeof(aBlank[0])) * sizeof(_CHAR);
    
    // Horizontale Breite berechnen
    //CalcWidth();
        
  end_if;
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL EventJournal::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  
  if (IsCon_coEventTitle = True) then    // KaiAnd
    if (coEventTitle.GetTitleTxtScheme(pTxtScheme:=#EventConfig.EventTitleTextScheme) = FALSE) then
      bGetTheurgeData := FALSE;
    end_if;
  end_if;
  
  bInitialized := GetTheUrge(pio:=pio);
    
  //----- Basisklasse aufrufen ------------------
  _AlarmDisplay::IF_Start(pio, firsttime);

  //----- Reset vertical Sroll-Position ---------
  Scroll.position.pos    := 0;
  Scroll.position.begin  := 0;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL EventJournal::Draw
	VAR_INPUT
		pio 	: ^_IO;
		pr 	  : ^_RESULT;
		pv 	  : ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR

  // UDC-Parameter schon geholt?
  if (bInitialized) then
  
    // Parameter vom UDC holen
    GetTheUrgeValues(pio:=pio);
    
    // Methode der Basis-Klasse
    retcode := _ScrollArea::Draw(pio, pr, pv, input);

  else
    retcode := _IFAILED;
  end_if;
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL EventJournal::Line
	VAR_INPUT
		ps 	: ^_SCROLL;
		pr 	: ^_ROOM;
		line 	: UINT;
		state 	: BOOL;
	END_VAR
  VAR
    tmpEntry      : ^_SINGLEALARM;
    tmpAlarm      : ^_SINGLE_ALARM;
    tmpNumber     : UINT;
    tmpTextColor  : _COLOR;
    tmpBgColor    : _COLOR;
    lineOffset    : UINT;
    filterOK      : BOOL;
    filterOKcnt   : UINT;
    i             : UDINT;
  END_VAR

  // Anzahl der Einträge in Ringbuffer lesen
  tmpNumber := TO_UINT(no_RINGBUFFER(#Pms^.ringbuffer)); 
  
  // Gültige Zeile und UDC-Parameter geholt?
  if ((line < tmpNumber) & (bInitialized)) then
    

    //=============================================================================================
    // FILTER schleife
    //=============================================================================================
    filterOKcnt := 0;
    filterOK    := FALSE;
    lineOffset  := 0;

    //---------------------------------------------------------------------------------------------
    //  Scroll-Bereich richtig stellen
    //---------------------------------------------------------------------------------------------
    // nur wenn Scroll-Bereich so gross wie Gesamtanzahl (das deutet auf neuen Bildaufbau hin)
    if (scroll.position.no = tmpNumber) then

      for i:=0 to (tmpNumber -1) do

        // Pointer zu Eintrag bilden, zuerst den aktuellsten Eintrag holen (actual -> old)
        tmpEntry := Pms^.ptr + (rpos_RINGBUFFER(#Pms^.ringbuffer, (tmpNumber-i)-1) * sizeof(_SINGLEALARM)); 
    
        if (tmpEntry <> NIL) then
          if (ChkEventDispFilter(tmpEntry) = TRUE) then   // f() checkt Display-Filter (TRUE = Event anzeigen)
          
            filterOKcnt += 1;

          end_if;
        end_if;
    
      end_for;
      scroll.position.no := filterOKcnt +1; // Scroll-Bereich stellen mit Vorspannen

    end_if;
    filterOKcnt := 0;

    //---------------------------------------------------------------------------------------------
    //  ermitteln, wieviele Einträge VOR der gewünschten line rausgefiltert wurden
    //---------------------------------------------------------------------------------------------
    if (line > 0) then
      for i:=0 to (line -1) do

        // Pointer zu Eintrag bilden, zuerst den aktuellsten Eintrag holen (actual -> old)
        tmpEntry := Pms^.ptr + (rpos_RINGBUFFER(#Pms^.ringbuffer, (tmpNumber-i)-1) * sizeof(_SINGLEALARM)); 
    
        if (tmpEntry <> NIL) then
          if (ChkEventDispFilter(tmpEntry) = TRUE) then   // f() checkt Display-Filter (TRUE = Event anzeigen)
             
             filterOKcnt += 1;
          else
            lineOffset += 1;
          end_if;
        end_if;
    
      end_for;
    end_if;


    //---------------------------------------------------------------------------------------------
    //  Schleife bis zum nächsten Eintrag mit gültigem Filter
    //---------------------------------------------------------------------------------------------
    while ( (filterOK = FALSE) & ((line + lineOffset) < tmpNumber) ) do
    
      // Pointer zu Eintrag bilden, zuerst den aktuellsten Eintrag holen (actual -> old)
      tmpEntry := Pms^.ptr + (rpos_RINGBUFFER(#Pms^.ringbuffer, (tmpNumber-line-lineOffset)-1) * sizeof(_SINGLEALARM)); 
    
      if (tmpEntry <> NIL) then
        if (ChkEventDispFilter(tmpEntry) = TRUE) then   // f() checkt Display-Filter (TRUE = Event anzeigen)
             
          filterOKcnt += 1;
          if (filterOKcnt > line) then
            filterOK := TRUE;
          else
            lineOffset += 1;
          end_if;

        //----- wenn Zeile nicht ausgegeben werden soll -----
        else

          lineOffset += 1;

        end_if;
      end_if;

    end_while;
    
    
    //=============================================================================================
    //  Zeile ausgeben
    //=============================================================================================
    if ((tmpEntry <> NIL) & (filterOK = TRUE)) then


      //===========================================================================================
      //  UNTERSCHEIDUNG DER EVENTEINTRÄGE
      //===========================================================================================
      case tmpEntry^.entrytype of
        
        //---------------------------------------------------------------------------------------
        //  System Meldungen Kategorie 1
        //---------------------------------------------------------------------------------------
        Event_SystemCat1:
        
          // Farben für Event bestimmen
          tmpTextColor := EventConfig.aCategorieColors[0].Cat_TextColor;
          tmpBgColor   := EventConfig.aCategorieColors[0].Cat_BgColor;

          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für das Event fehlgeschlagen" );
            end_if;
          end_if;

        //---------------------------------------------------------------------------------------
        //  System Meldungen Kategorie 2
        //---------------------------------------------------------------------------------------
        Event_SystemCat2:

          // Farben für Event bestimmen
          tmpTextColor := EventConfig.aCategorieColors[1].Cat_TextColor;
          tmpBgColor   := EventConfig.aCategorieColors[1].Cat_BgColor;

          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für das Event fehlgeschlagen" );
            end_if;
          end_if;

        //---------------------------------------------------------------------------------------
        //  System Meldungen Kategorie 3
        //---------------------------------------------------------------------------------------
        Event_SystemCat3:

          // Farben für Event bestimmen
          tmpTextColor := EventConfig.aCategorieColors[2].Cat_TextColor;
          tmpBgColor   := EventConfig.aCategorieColors[2].Cat_BgColor;

          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für das Event fehlgeschlagen" );
            end_if;
          end_if;

        //---------------------------------------------------------------------------------------
        //  System Meldungen Kategorie 4
        //---------------------------------------------------------------------------------------
        Event_SystemCat4:

          // Farben für Event bestimmen
          tmpTextColor := EventConfig.aCategorieColors[3].Cat_TextColor;
          tmpBgColor   := EventConfig.aCategorieColors[3].Cat_BgColor;
          
          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für das Event fehlgeschlagen" );
            end_if;
          end_if;

        //---------------------------------------------------------------------------------------
        //  Alarm
        //---------------------------------------------------------------------------------------
        EVENT_ALARM:
        
          // Pointer zu LSE-Informationen von Alarm bilden
          tmpAlarm := get_ANYTHING( x0  := #tmpEntry^.anything, 
                                    x1  := NIL)$^_SINGLE_ALARM;
          
          // Prüfen ob Alarm in LSE verfügbar
          if (tmpAlarm <> NIL) then
            
            // Alarm ist aktiv
            if (tmpEntry^.state = true) then
              
              // Alarm wurde quittiert
              if (tmpEntry^.acknowledge = true) then
                tmpTextColor := GetPenColor(x0 := tmpAlarm^.quit_active);
                tmpBgColor   := GetBackColor(x0 := tmpAlarm^.quit_active);
              // Alarm wurde nicht quittiert
              else
                tmpTextColor := GetPenColor(x0 := tmpAlarm^.active);
                tmpBgColor   := GetBackColor(x0 := tmpAlarm^.active);
              end_if;

              
            // Alarm ist nicht aktiv
            else
              
              // Alarm wurde quittiert
              if (tmpEntry^.acknowledge = true) then
                tmpTextColor := GetPenColor(x0 := tmpAlarm^.quit_passive);
                tmpBgColor   := GetBackColor(x0 := tmpAlarm^.quit_passive);
              // Alarm wurde nicht quittiert
              else
                tmpTextColor := GetPenColor(x0 := tmpAlarm^.passive);
                tmpBgColor   := GetBackColor(x0 := tmpAlarm^.passive);
              end_if;
              
            end_if;
              

          // Alarm im LSE nicht definiert
          else
          
            tmpTextColor := EventConfig.aCategorieColors[0].Cat_TextColor;
            tmpBgColor   := EventConfig.aCategorieColors[0].Cat_BgColor;
            
          end_if;

          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für einen Alarm fehlgeschlagen" );
            end_if;
          end_if;
          
        //---------------------------------------------------------------------------------------
        //  System Ein/Aus
        //---------------------------------------------------------------------------------------
        EVENT_SWITCHOFF, EVENT_SWITCHON:
        
          // Farben für Event bestimmen
          tmpTextColor := EventConfig.aCategorieColors[0].Cat_TextColor;
          tmpBgColor   := EventConfig.aCategorieColors[0].Cat_BgColor;
          
          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für das Event fehlgeschlagen" );
            end_if;
          end_if;
            
        //---------------------------------------------------------------------------------------
        //  Login/Logout
        //---------------------------------------------------------------------------------------
        EVENT_USERLOGIN, EVENT_USERLOGOUT:

          // Farben für Event bestimmen
          tmpTextColor := EventConfig.aCategorieColors[0].Cat_TextColor;
          tmpBgColor   := EventConfig.aCategorieColors[0].Cat_BgColor;
          
          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für das Event Login bzw. Logout fehlgeschlagen" );
            end_if;
          end_if; 
          
        //---------------------------------------------------------------------------------------
        // Wertänderungen
        //---------------------------------------------------------------------------------------
        EVENT_MENUCHANGE, EVENT_DATECHANGE, EVENT_VALUECHANGE, EVENT_TIMECHANGE:

          // Farben für Event bestimmen
          tmpTextColor := EventConfig.aCategorieColors[5].Cat_TextColor; 
          tmpBgColor   := EventConfig.aCategorieColors[5].Cat_BgColor;
          
          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für das Event einer Wertänderung fehlgeschlagen" );
            end_if;
          end_if;
          
        //---------------------------------------------------------------------------------------
        // Benutzer-Event
        //---------------------------------------------------------------------------------------
        EVENT_USEREVENT:

          // Farben für Event bestimmen
          tmpTextColor := EventConfig.aCategorieColors[4].Cat_TextColor; 
          tmpBgColor   := EventConfig.aCategorieColors[4].Cat_BgColor;
          
          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für das Benutzer-Event fehlgeschlagen" );
            end_if;
          end_if; 
          
        //---------------------------------------------------------------------------------------
        // Umschalten Betriebsart
        //---------------------------------------------------------------------------------------
        EVENT_OPCHANGE:
        
          // Farben für Event bestimmen
          tmpTextColor := EventConfig.aCategorieColors[0].Cat_TextColor; 
          tmpBgColor   := EventConfig.aCategorieColors[0].Cat_BgColor;
          
          // Zeile ausgeben
          if (WriteEventEntry(pEntry     := tmpEntry, 
                              pRoom      := pr, 
                              sFont      := ps^.font, 
                              sTextColor := tmpTextColor, 
                              sBackColor := tmpBgColor) = false) then
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::Line(): Ausgeben der Zeile für das Event einer Wertänderung fehlgeschlagen" );
            end_if;
          end_if;  
        
        //---------------------------------------------------------------------------------------
        // Nicht unterstütztes Event
        //---------------------------------------------------------------------------------------
        else
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::Line(): Eintrag aus EventJournal nicht unterstützt" );
          end_if;
      end_case;
    
    else
      if (IsCon_coSystemLogging = True) then    // KaiAnd
        coSystemLogging.LogEventText("EventJournal::Line(): keine Informationen zum Event verfügbar" );
      end_if;
    end_if;
    
  end_if; 
  
  
  // Farbe für Spalten-Unterteilung bestimmen
  tmpTextColor := Graphic.MakeColor(fgcol := ps^.color_activ, 
                                    bgcol := ps^.color_activ);
  
  if (iOldScrollOffset <> pr^.xy1.x) then
      iOldScrollOffset := pr^.xy1.x;
      // Aktuellen Zeilenbeginn für EventTitle speichern
      if (IsCon_coEventTitle = True) then    // KaiAnd
        coEventTitle.setActLineBegin(NewScrollOffset := pr^.xy1.x);
      end_if;
    end_if;
    
  // Zeilenunterteilung zeichnen
  if (TableLines(tmpTextColor, pr) = false) then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::Line(): Zeichnen der Zeilenunterteilung fehlgeschlagen" );
    end_if;
  end_if;
    
  // Rahmen erneut zeichnen, falls Scrollliste horizontal verschoben wurde
  DrawButton(#ps^.out_room, T_FILL or T_COPY or T_SOLID, ps^.frametype, INVISIBLE, ps^.frame_out);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL EventJournal::ExportEvents
	VAR_INPUT
		ExportFilter 	: BDINT;
		ExFilt_Date1 	: HDINT;
		ExFilt_Date2 	: HDINT;
		ExFilt_Time1 	: HDINT;
		ExFilt_Time2 	: HDINT;
	END_VAR
	VAR_OUTPUT
		eRetcode 	: iprStates;
	END_VAR
  VAR
    tmpDirHandle      : DINT;
    tmpLength         : UDINT;
    tmpFilenameLength : UDINT;
    tmpStringLength   : UDINT;
    tmpPreAlarmLength : UDINT;
    pString           : ^_CHAR;
    tmpTime           : _TIME;
    tmpDate           : _DATE;
    tmpSingleAlarm    : ^_SINGLEALARM;
    tmpString         : ARRAY[0..Event_TempBufferLength] OF _CHAR;
    filterOK          : BOOL;
    tmpRetcode        : DINT;
  END_VAR
  
  eRetcode := BUSY;
  
  //===============================================================================================
  //  Schrittschaltwerk für das asynchrone Schreiben in eine Datei
  //===============================================================================================
  case eEventFileState of


    //===========================================================================================
    EventJournal_STARTEXPORT:  
    
      // Ladebalken-Fenster Öffnen
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=Event_WindowNr, x2:=0);
      
      uiCreatedFolderCnt := 1;
      
      aFilename[0] := 0;
      tmpLength := coDriveLetter.GetLength();
      
      if tmpLength > 0 then
        
        // Laufwerksbuchstaben lesen
        coDriveLetter.ReadDataOff(udOff:=0, pData:=#aFilename[0], udMax:=sizeof(aFilename));
        aFilename[tmpLength] := 0;
        
      end_if;
      
      // Export Ordnerpfad anhängen
      coSigCLib.StrCat(ps1:=#aFilename[0], ps2:=Event_DefaultPath);
      
      // Export Ordnerpfad aufteilen
      tmpRetcode := SplitPath();
      
      if tmpRetcode = 0 then
        eEventFileState := EventJournal_CREATEDIR;
      else
        eRetcode := ERROR;
      end_if;    
    
    //===========================================================================================
    EventJournal_CREATEDIR:

      if uiCreatedFolderCnt > 0 then
        // Ordner anlegen
        dAsyncID := coFileSys.CreateDirectory_A(Async := 1, dirname := #FolderPathList.FolderPaths[uiCreatedFolderCnt].FolderPath[0]);
        eEventFileState := EventJournal_WAIT4CREATEDIR;
      else
        eRetcode := ERROR;
        eEventFileState := EventJournal_STARTEXPORT;
      end_if;
      
  
    //===========================================================================================
    EventJournal_WAIT4CREATEDIR:
      // Ordner fertig angelegt?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #tmpDirHandle);

      case dAsyncState of
        0:
            //-----------------------------------------------------------------------------------
            //  Ordner fertig angelegt oder schon vorhanden
            //-----------------------------------------------------------------------------------
            if (tmpDirHandle >= 0) | (tmpDirHandle = -36) then
              
              if uiCreatedFolderCnt = FolderPathList.uiFolderNr then
                eEventFileState := EventJournal_FILEOPEN;
              else
                eEventFileState := EventJournal_CREATEDIR;
                uiCreatedFolderCnt += 1;
              end_if;
              
            else
              if (IsCon_coSystemLogging = True) then    // KaiAnd
                coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Erstellen eines Ordners für EventJournal" );
              end_if;
              eRetcode        := ERROR;
              eEventFileState := EventJournal_STARTEXPORT;
            end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Erstellen eines Ordners für EventJournal" );
          end_if;
          eRetcode        := ERROR;
          eEventFileState := EventJournal_STARTEXPORT;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Erstellen eines Ordners für EventJournal" );
        end_if;
        eRetcode        := ERROR;
        eEventFileState := EventJournal_STARTEXPORT;                                
      end_case;
            
            
    //===========================================================================================
    EventJournal_FILEOPEN:
      //---------------------------------------------------------------------------------------
      //  Pfad für die Datei zusammenstellen (mit Datum- und Zeitstempel)
      //---------------------------------------------------------------------------------------      
      tmpFilenameLength := coSigCLib.StrLen(str:=#aFilename[0]);

      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := Event_FilePreFix, 
              x3 := sizeof(char), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));

      // Trennzeichen
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := "_", 
              x3 := sizeof(char), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));
              
      //---------------------------------------------------------------------------------------
      //  Datum holen und als Postfix anhängen
      //---------------------------------------------------------------------------------------
      get_DATE(p0:=#tmpDate);
      DToA(p0 := #tmpString[0], x1 := TO_DINT(tmpDate.year), x2 := 0, x3 := sizeof(_CHAR));
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := #tmpString[0], 
              x3 := sizeof(_CHAR), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));
      // Trennzeichen
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := "-", 
              x3 := sizeof(char), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));
      DToA(p0 := #tmpString[0], x1 := TO_DINT(tmpDate.month), x2 := 2#100000010, x3 := sizeof(_CHAR));
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := #tmpString[0], 
              x3 := sizeof(_CHAR), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));
      // Trennzeichen
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := "-", 
              x3 := sizeof(char), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));
      DToA(p0 := #tmpString[0], x1 := TO_DINT(tmpDate.day), x2 := 2#100000010, x3 := sizeof(_CHAR));
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := #tmpString[0], 
              x3 := sizeof(_CHAR), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));

      // Trennzeichen
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := "_", 
              x3 := sizeof(char), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));
              
      //---------------------------------------------------------------------------------------
      //  Zeit holen und als Postfix anhängen
      //---------------------------------------------------------------------------------------
      get_TIME(p0:=#tmpTime);
      DToA(p0 := #tmpString[0], x1 := TO_DINT(tmpTime.hour), x2 := 2#100000010, x3 := sizeof(_CHAR));
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := #tmpString[0], 
              x3 := sizeof(_CHAR), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));
      DToA(p0 := #tmpString[0], x1 := TO_DINT(tmpTime.minute), x2 := 2#100000010, x3 := sizeof(_CHAR));
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := #tmpString[0], 
              x3 := sizeof(_CHAR), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));

      // Dateityp
      tmpFilenameLength := _strlen(#aFilename[0]);
      StrNCpy(p0 := #aFilename[tmpFilenameLength], 
              x1 := sizeof(aFilename[0]), 
              p2 := Event_FileType, 
              x3 := sizeof(char), 
              ml := Event_MaxFilenameLength-to_uint(tmpFilenameLength));
              
      //---------------------------------------------------------------------------------------
      //  Datei erstellen
      //---------------------------------------------------------------------------------------
      dAsyncID := coFileSys.FileOpen_A(Async:=1, filename:=#aFilename[0], attributes:=ATT_CREATE_ALWAYS);
      eEventFileState := EventJournal_WAIT4FILEOPEN;
    
    
    //===========================================================================================
    EventJournal_WAIT4FILEOPEN:
      // Durch die AsyncID abfragen ob das Anlegen der Datei schon fertig ist
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);

      case dAsyncState of
        0:
          //-------------------------------------------------------------------------------------
          //  Fertig und erstellt
          //-------------------------------------------------------------------------------------
          if (dFileHandle >= 0) then 
          
            // Buffer leeren und Schreibe-Zeiger auf Anfang setzen
            _memset(pBuffer, 0, Event_BufferLength);
            pWriteBuffer := pBuffer;
            
            eEventFileState := EventJournal_WRITEHEADER;
            
          else
          
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Erstellen eines Ordners für EventJournal" );
            end_if;
            eRetcode        := ERROR;
            eEventFileState := EventJournal_STARTEXPORT;
            
          end_if;  
          //-------------------------------------------------------------------------------------
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Erstellen eines Ordners für EventJournal" );
          end_if;
          eRetcode        := ERROR;
          eEventFileState := EventJournal_STARTEXPORT;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Erstellen eines Ordners für EventJournal" );
        end_if;
        eRetcode        := ERROR;
        eEventFileState := EventJournal_STARTEXPORT;                                
      end_case;


    //===========================================================================================
    EventJournal_WRITEHEADER:
      //-----------------------------------------------------------------------------------------
      //  Kopfzeile aus Textliste in der Visu holen
      //-----------------------------------------------------------------------------------------
      udAddedDataLength := 0;

      //-----------------------------------------------------------------------------------------
      //  Eventzeit holen
      //-----------------------------------------------------------------------------------------
      pString$^void := NewDoScheme(x0 := EventConfig.EventTitleTextScheme.list, 
                                   x1 := Event_TitleTextEventTime, 
                                   x2 := EventConfig.EventTitleTextScheme.no);            
      if (pString = NIL) then
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Keinen Text (Eventzeit) gefunden" );
        end_if;
      else
        
        tmpStringLength := StrLen(pString, sizeof(_CHAR)) * sizeof(_CHAR);
        // Überprüfen, ob im Buffer noch genügend Speicher frei ist
        if ((pWriteBuffer + tmpStringLength + udCommaLength) < pEndBuffer) then
          
          // Neue Daten in den Buffer kopieren
          StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=pString, x3:=sizeof(_CHAR));
          // Zeiger auf nächste freien Daten setzen
          pWriteBuffer += tmpStringLength;
          
          // Spalten-Trennzeichen
          StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=#aColSep[0], x3:=sizeof(char));
          // Zeiger auf nächste freien Daten setzen
          pWriteBuffer += udCommaLength;
        
        else
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
          end_if;
        end_if;
        
      end_if;

      //-----------------------------------------------------------------------------------------
      //  Parameter 1 holen
      //-----------------------------------------------------------------------------------------
      pString$^void := NewDoScheme(x0 := EventConfig.EventTitleTextScheme.list, 
                                   x1 := Event_TitleTextParam1, 
                                   x2 := EventConfig.EventTitleTextScheme.no);            
      if (pString = NIL) then
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Keinen Text (Parameter 1) gefunden" );
        end_if;
      else
        
        tmpStringLength := StrLen(pString, sizeof(_CHAR)) * sizeof(_CHAR);
        // Überprüfen, ob im Buffer noch genügend Speicher frei ist
        if ((pWriteBuffer + tmpStringLength + udCommaLength) < pEndBuffer) then
          
          // Neue Daten in den Buffer kopieren
          StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=pString, x3:=sizeof(_CHAR));
          // Zeiger auf nächste freien Daten setzen
          pWriteBuffer += tmpStringLength;

          // Spalten-Trennzeichen
          StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=#aColSep[0], x3:=sizeof(char));
          // Zeiger auf nächste freien Daten setzen
          pWriteBuffer += udCommaLength;
        
        else
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
          end_if;
        end_if;

      end_if;
                          
      //-----------------------------------------------------------------------------------------
      //  Alarmnummer / Bildnummer holen
      //-----------------------------------------------------------------------------------------
      pString$^void := NewDoScheme(x0 := EventConfig.EventTitleTextScheme.list, 
                                   x1 := Event_TitleTextAlarmNo, 
                                   x2 := EventConfig.EventTitleTextScheme.no);            
      if (pString = NIL) then
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Keinen Text (Alarmnummer/Bildnummer) gefunden" );
        end_if;
      else
        
        tmpStringLength := StrLen(pString, sizeof(_CHAR)) * sizeof(_CHAR);
        // Überprüfen, ob im Buffer noch genügend Speicher frei ist
        if ((pWriteBuffer + tmpStringLength + udCommaLength) < pEndBuffer) then
          
          // Neue Daten in den Buffer kopieren
          StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=pString, x3:=sizeof(_CHAR));
          // Zeiger auf nächste freien Daten setzen
          pWriteBuffer += tmpStringLength;

          // Spalten-Trennzeichen
          StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=#aColSep[0], x3:=sizeof(char));
          // Zeiger auf nächste freien Daten setzen
          pWriteBuffer += udCommaLength;
        
        else
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
          end_if;
        end_if;

      end_if;

      //-----------------------------------------------------------------------------------------
      //  Parameter 2 holen
      //-----------------------------------------------------------------------------------------
      pString$^void := NewDoScheme(x0 := EventConfig.EventTitleTextScheme.list, 
                                   x1 := Event_TitleTextParam2, 
                                   x2 := EventConfig.EventTitleTextScheme.no);            
      if (pString = NIL) then
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Keinen Text (Parameter 2) gefunden" );
        end_if;
      else
        
        tmpStringLength := StrLen(pString, sizeof(_CHAR)) * sizeof(_CHAR);
        // Überprüfen, ob im Buffer noch genügend Speicher frei ist
        if ((pWriteBuffer + tmpStringLength + udCommaLength) < pEndBuffer) then
          
          // Neue Daten in den Buffer kopieren
          StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=pString, x3:=sizeof(_CHAR));
          // Zeiger auf nächste freien Daten setzen
          pWriteBuffer += tmpStringLength;

          // Spalten-Trennzeichen
          StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=#aColSep[0], x3:=sizeof(char));
          // Zeiger auf nächste freien Daten setzen
          pWriteBuffer += udCommaLength;
        
        else
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
          end_if;
        end_if;

      end_if;

      //-----------------------------------------------------------------------------------------
      //  Beschreibung holen
      //-----------------------------------------------------------------------------------------
      pString$^void := NewDoScheme(x0 := EventConfig.EventTitleTextScheme.list, 
                                   x1 := Event_TitleTextDescription, 
                                   x2 := EventConfig.EventTitleTextScheme.no);            
      if (pString = NIL) then
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Keinen Text (Beschreibung) gefunden" );
        end_if;
      else
        
        tmpStringLength := StrLen(pString, sizeof(_CHAR)) * sizeof(_CHAR);
        // Überprüfen, ob im Buffer noch genügend Speicher frei ist
        if ((pWriteBuffer + tmpStringLength) < pEndBuffer) then
        
          // Neue Daten in den Buffer kopieren
          StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=pString, x3:=sizeof(_CHAR));
          // Zeiger auf nächste freien Daten setzen
          pWriteBuffer += tmpStringLength;
        
        else
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
          end_if;
        end_if;
        
      end_if;

      // Zeilenende
      StrCpy(p0:=pWriteBuffer, x1:=sizeof(_CHAR), p2:=#aLineEnd[0], x3:=sizeof(char));
      // Zeiger auf nächste freien Daten setzen
      pWriteBuffer += udLineEndLength;
        

      //-----------------------------------------------------------------------------------------
      //  Kopfzeile in Datei schreiben
      //-----------------------------------------------------------------------------------------
      udAddedDataLength := pWriteBuffer$udint - pBuffer$udint;
      dAsyncID := coFileSys.FileWrite_A(Async:=1, handle:=dFileHandle, buffer:=pBuffer, length:=udAddedDataLength);
      eEventFileState := EventJournal_WAIT4WRITEHEADER;
            
            
    //===========================================================================================
    EventJournal_WAIT4WRITEHEADER:
      //-----------------------------------------------------------------------------------------
      //  Schreiben der Kopfzeile fertig?
      //-----------------------------------------------------------------------------------------
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileWrite);

      case dAsyncState of
        0:
          //-------------------------------------------------------------------------------------
          //  Fertig und erstellt
          //-------------------------------------------------------------------------------------
          if (dFileWrite >= 0) then 
            
            // Anzahl der Alarme (Zeilen) ermitteln
            ExportLineNumbers := no_RINGBUFFER(p0 := #Pms^.ringbuffer); 
            ExportActLineNr   := 0;
            ExportProgress    := 0;
            
            udAddedDataLength := 0;
                                
            // Buffer leeren
            _memset(pBuffer, 0, Event_BufferLength);
            pWriteBuffer := pBuffer;
            
            eEventFileState := EventJournal_FILLBUFFER;
            
          else
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Schreiben der Kopfzeile für EventJournal" );
            end_if;
            eRetcode        := ERROR;
            eEventFileState := EventJournal_STARTEXPORT;
            
          end_if;  
          //-------------------------------------------------------------------------------------
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Schreiben der Kopfzeile für EventJournal" );
          end_if;
          eRetcode        := ERROR;
          eEventFileState := EventJournal_STARTEXPORT;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Schreiben der Kopfzeile für EventJournal" );
        end_if;
        eRetcode        := ERROR;
        eEventFileState := EventJournal_STARTEXPORT;                                
      end_case;

       
    //===========================================================================================
    EventJournal_FILLBUFFER:
      //-----------------------------------------------------------------------------------------
      //  Zeit merken, damit der Background-Task nicht länger als xxx ms angehalten wird
      //-----------------------------------------------------------------------------------------
      udTimeStamp := ops.tAbsolute;

      //-----------------------------------------------------------------------------------------
      //  Alle Zeilen geschrieben, Buffer voll oder Zeit abgelaufen
      //-----------------------------------------------------------------------------------------
      while (ExportActLineNr < ExportLineNumbers) & 
            (udAddedDataLength < (EVENT_BUFFERLENGTH - Event_FreeBufferSpace)) & 
            ((ops.tAbsolute - udTimeStamp) < Event_MaxInterruptTime) do
        
        //---------------------------------------------------------------------------------------
        //  Pointer zu aktuellen Alarm holen
        //---------------------------------------------------------------------------------------
        tmpSingleAlarm := Pms^.ptr + (rpos_RINGBUFFER(#Pms^.ringbuffer, ExportActLineNr) * sizeof(_SINGLEALARM)); 
        
        //-------------------------------------------------------------------------------------
        // Export-Filter
        //-------------------------------------------------------------------------------------
        filterOK := FALSE;
        if (tmpSingleAlarm <> NIL) then
          if ( ((tmpSingleAlarm^.entrytype = Event_SystemCat1)  & (ExportFilter and 16#0001)) |
               ((tmpSingleAlarm^.entrytype = Event_SystemCat2)  & (ExportFilter and 16#0002)) |
               ((tmpSingleAlarm^.entrytype = Event_SystemCat3)  & (ExportFilter and 16#0004)) |
               ((tmpSingleAlarm^.entrytype = Event_SystemCat4)  & (ExportFilter and 16#0008)) |
               ((tmpSingleAlarm^.entrytype = EVENT_ALARM)       & (ExportFilter and 16#0010)) |

               ((tmpSingleAlarm^.entrytype = EVENT_SWITCHOFF)   & (ExportFilter and 16#0020)) |
               ((tmpSingleAlarm^.entrytype = EVENT_SWITCHON)    & (ExportFilter and 16#0020)) |
        
               ((tmpSingleAlarm^.entrytype = EVENT_USERLOGIN)   & (ExportFilter and 16#0040)) |
               ((tmpSingleAlarm^.entrytype = EVENT_USERLOGOUT)  & (ExportFilter and 16#0040)) |

               ((tmpSingleAlarm^.entrytype = EVENT_MENUCHANGE)  & (ExportFilter and 16#0080)) |
               ((tmpSingleAlarm^.entrytype = EVENT_DATECHANGE)  & (ExportFilter and 16#0080)) |
               ((tmpSingleAlarm^.entrytype = EVENT_VALUECHANGE) & (ExportFilter and 16#0080)) |
               ((tmpSingleAlarm^.entrytype = EVENT_TIMECHANGE)  & (ExportFilter and 16#0080)) |

               ((tmpSingleAlarm^.entrytype = EVENT_USEREVENT)   & (ExportFilter and 16#0100)) |

               ((tmpSingleAlarm^.entrytype = EVENT_OPCHANGE)    & (ExportFilter and 16#0200)) ) then
             

                //-------------------------------------------------------------------------
                //  Event-Datum/Zeit filtern
                //  ACHTUNG: tmpSingleAlarm^.date_on hat keinen Wochentag (Bit0-3 = 0)
                //-------------------------------------------------------------------------
                if (  (TO_UDINT(tmpSingleAlarm^.date_on) >= (ExFilt_Date1 and 16#FFffFFf0)) & 
                      (TO_UDINT(tmpSingleAlarm^.date_on) <  (ExFilt_Date2 and 16#FFffFFf0)) )  then
                
                  if (TO_UDINT(tmpSingleAlarm^.date_on) > ExFilt_Date1) then
                    filterOK := TRUE;
                  elsif ( (TO_UDINT(tmpSingleAlarm^.time_on) >= ExFilt_Time1) & 
                          (TO_UDINT(tmpSingleAlarm^.date_on) <  ExFilt_Time2) )  then
                    filterOK := TRUE;
                  end_if;
                
                end_if;
                //-----------------------------------------------------------------------
        
            end_if;
          end_if;


        //---------------------------------------------------------------------------------------
        //  Prüfen ob Eintrag verfügbar 
        //---------------------------------------------------------------------------------------
        if ((tmpSingleAlarm <> NIL) & (filterOK = TRUE)) then

          //-------------------------------------------------------------------------------------
          //  Spalte 1: Eventzeit holen
          //-------------------------------------------------------------------------------------
          pString := GetEventTime(pEntry:=tmpSingleAlarm, pRetdDate:=NIL, pRetdTime:=NIL);
          if (pString <> NIL) then
            tmpStringLength := StrLen(pString, sizeof(_CHAR)) * sizeof(_CHAR);
          else
            tmpStringLength := 0;
          end_if;
          
          // Überprüfen, ob im Buffer noch genügend Speicher frei ist
          if ( (pString = NIL) | ((pWriteBuffer + tmpStringLength + udCommaLength) < pEndBuffer) ) then
          
            if (pString = NIL) then
            
              if (IsCon_coSystemLogging = True) then    // KaiAnd
                coSystemLogging.LogEventText("EventJournal::ExportEvents(): Keine Eventzeit gefunden" );
              end_if;
              
              // Platzhalter kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=Event_DatePlaceHolder, x3:=sizeof(char));
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += _strlen(Event_DatePlaceHolder) * sizeof(_CHAR);
              
              // Platzhalter kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=#aBlank[0], x3:=sizeof(char));
              
              // Zeigerauf nächste freien Daten setzen
              pWriteBuffer += udBlankLength;
              
              // Platzhalter kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=Event_TimePlaceHolder, x3:=sizeof(char));
              
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += _strlen(Event_TimePlaceHolder) * sizeof(_CHAR);
              
            else
              
              // Neue Daten in den Buffer kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=pString, x3:=sizeof(pString^));
              
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += tmpStringLength;
              
            end_if;

            // Spalten-Trennzeichen
            StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=#aColSep[0], x3:=sizeof(aColSep[0]));
            // Zeiger auf nächste freien Daten setzen
            pWriteBuffer += udCommaLength;
            
          else
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
            end_if;
          end_if;
          
          //-------------------------------------------------------------------------------------
          //  Spalte 2: Parameter 1 holen
          //-------------------------------------------------------------------------------------
          pString := GetParameter1(pEntry:=tmpSingleAlarm, pRetDINT:=NIL);
          if (pString <> NIL) then
            tmpStringLength := StrLen(pString, sizeof(pString^)) * sizeof(_CHAR);
          else
            tmpStringLength := 0;
          end_if;
          
          // Überprüfen, ob im Buffer noch genügend Speicher frei ist
          if ((pString = NIL) | (pWriteBuffer + tmpStringLength + udCommaLength) < pEndBuffer) then
          
            if (pString = NIL) then
                                
              // Platzhalter kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=#aBlank[0], x3:=sizeof(aBlank[0]));
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += udBlankLength;
                                
            else
              
              // Neue Daten in den Buffer kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=pString, x3:=sizeof(pString^));
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += tmpStringLength;

            end_if;

            // Spalten-Trennzeichen
            StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=#aColSep[0], x3:=sizeof(aColSep[0]));
            // Zeiger auf nächste freien Daten setzen
            pWriteBuffer += udCommaLength;
          
          else
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
            end_if;
          end_if;
          
          //-------------------------------------------------------------------------------------
          //  Spalte 3: Alarmnummer / Bildnummer holen
          //-------------------------------------------------------------------------------------
          pString := GetAlarmNo(pEntry:=tmpSingleAlarm, pRetDINT:=NIL);
          if (pString <> NIL) then
            tmpStringLength := StrLen(pString, sizeof(pString^)) * sizeof(_CHAR);
          else
            tmpStringLength := 0;
          end_if;
          
          // Überprüfen, ob im Buffer noch genügend Speicher frei ist
          if ((pString = NIL) | (pWriteBuffer + tmpStringLength + udCommaLength) < pEndBuffer) then
          
            if (pString = NIL) then
                
              // Platzhalter kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=#aBlank[0], x3:=sizeof(aBlank[0]));
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += udBlankLength;
                                
            else
              
              // Neue Daten in den Buffer kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=pString, x3:=sizeof(pString^));
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += tmpStringLength;

            end_if;

            // Spalten-Trennzeichen
            StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=#aColSep[0], x3:=sizeof(aColSep[0]));
            // Zeiger auf nächste freien Daten setzen
            pWriteBuffer += udCommaLength;
            
          else
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
            end_if;
          end_if;
          
          //-------------------------------------------------------------------------------------
          //  Spalte 4: Parameter 2 holen
          //-------------------------------------------------------------------------------------
          pString := GetParameter2(pEntry:=tmpSingleAlarm, pRetDINT:=NIL);
          if (pString <> NIL) then
            tmpStringLength := StrLen(pString, sizeof(pString^)) * sizeof(_CHAR);
          else
            tmpStringLength := 0;
          end_if;
          
          // Überprüfen, ob im Buffer noch genügend Speicher frei ist
          if ((pString = NIL) | (pWriteBuffer + tmpStringLength + udCommaLength) < pEndBuffer) then
          
            if (pString = NIL) then
                                
              // Platzhalter kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=#aBlank[0], x3:=sizeof(aBlank[0]));
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += udBlankLength;
                                
            else
              
              // Neue Daten in den Buffer kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=pString, x3:=sizeof(pString^));
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += tmpStringLength;

            end_if;

            // Spalten-Trennzeichen
            StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=#aColSep[0], x3:=sizeof(aColSep[0]));
            // Zeiger auf nächste freien Daten setzen
            pWriteBuffer += udCommaLength;
          
          else
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
            end_if;
          end_if;
          
          //-------------------------------------------------------------------------------------
          //  Spalte 5: Beschreibung holen
          //-------------------------------------------------------------------------------------
          pString := GetEventText(pEntry:=tmpSingleAlarm);
          if (pString <> NIL) then
            tmpStringLength   := StrLen(pString, sizeof(pString^)) * sizeof(_CHAR);
            tmpPreAlarmLength := StrLen(Event_AlarmInactive, sizeof(char)) * sizeof(_CHAR);
          else
            tmpStringLength := 0;
          end_if;
          
          // Überprüfen, ob im Buffer noch genügend Speicher frei ist
          if ((pString = NIL) | (pWriteBuffer + tmpStringLength + udCommaLength + tmpPreAlarmLength) < pEndBuffer) then
          
            if (pString = NIL) then
               
              // Platzhalter kopieren
              StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=Event_NoAlarmInfo, x3:=sizeof(char));
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += _strlen(Event_NoAlarmInfo) * sizeof(_CHAR);
              
            else
              
              // Präfix bei Alarmen hinzufügen (Alarm gekommen/gegangen)
              if (tmpSingleAlarm^.state = 0) & (tmpSingleAlarm^.entrytype = Event_Alarm) then
                StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=Event_AlarmInactive, x3:=sizeof(char));
                // Zeiger auf nächste freien Daten setzen
                pWriteBuffer += _strlen(Event_AlarmInactive) * sizeof(_CHAR);

              elsif (tmpSingleAlarm^.state = 1) & (tmpSingleAlarm^.entrytype = Event_Alarm) then
                StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=Event_AlarmActive, x3:=sizeof(char));
                // Zeiger auf nächste freien Daten setzen
                pWriteBuffer += _strlen(Event_AlarmActive) * sizeof(_CHAR);
              end_if;
              
              // Neue Daten in den Buffer kopieren
              StrCpy(p0:=pWriteBuffer,x1:=sizeof(pWriteBuffer^), p2:=pString, x3:=sizeof(pString^));
              // Zeiger auf nächste freien Daten setzen
              pWriteBuffer += tmpStringLength;
              
            end_if;

            // Zeilenende
            StrCpy(p0:=pWriteBuffer, x1:=sizeof(pWriteBuffer^), p2:=#aLineEnd[0], x3:=sizeof(aLineEnd[0]));
            // Zeiger auf nächste freien Daten setzen
            pWriteBuffer += udLineEndLength;
            
          else
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::ExportEvents(): Buffer voll, restliche Daten gehen verloren" );
            end_if;
          end_if;
          //-------------------------------------------------------------------------------------
          
        else
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Eintrag aus EventJournal nicht unterstützt" );
          end_if;
        end_if;
        
        // Aktuelle Zeile hochzählen
        ExportActLineNr += 1;
        ExportProgress  := 1000 * ExportActLineNr / ExportLineNumbers;
        
        // Größe der aktuellen Daten im Buffer erhöhen
        udAddedDataLength := pWriteBuffer$udint - pBuffer$udint;
        
      end_while;

      eEventFileState := EventJournal_FILEWRITE;
            
            
    //===========================================================================================
    EventJournal_FILEWRITE:
      dAsyncID := coFileSys.FileWrite_A(Async:=1, handle:=dFileHandle, buffer:=pBuffer, length:=udAddedDataLength);
      eEventFileState := EventJournal_WAIT4FILEWRITE;
            
            
    //===========================================================================================
    EventJournal_WAIT4FILEWRITE:
      // Schreiben der Kopfzeile fertig?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileWrite);

      case dAsyncState of
        0:
          //-------------------------------------------------------------------------------------
          //  Fertig geschrieben?
          //-------------------------------------------------------------------------------------
          if (ExportActLineNr >= ExportLineNumbers) & (dFileWrite >= 0) then
            
            eEventFileState := EventJournal_FILECLOSE;
            
          //-------------------------------------------------------------------------------------
          //  Buffer leeren und mit neuen Daten füllen
          //-------------------------------------------------------------------------------------
          elsif (ExportActLineNr < ExportLineNumbers) & (dFileWrite >= 0) then 
            
            // Buffer für neue Daten leeren und Schreibezeiger auf Anfang setzen
            _memset(pBuffer, 0, Event_BufferLength);
            pWriteBuffer      := pBuffer;
            udAddedDataLength := 0;
              
            eEventFileState := EventJournal_FILLBUFFER;
              
          else
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Schreiben der Kopfzeile für EventJournal" );
            end_if;
            eRetcode        := ERROR;
            eEventFileState := EventJournal_STARTEXPORT;
              
          end_if;  
          //-------------------------------------------------------------------------------------
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Schreiben der Daten für EventJournal" );
          end_if;
          eRetcode        := ERROR;
          eEventFileState := EventJournal_STARTEXPORT;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Schreiben der Daten für EventJournal" );
        end_if;
        eRetcode        := ERROR;
        eEventFileState := EventJournal_STARTEXPORT;                                
      end_case;

            
    //===========================================================================================
    EventJournal_FILECLOSE:            
      dAsyncID := coFileSys.FileClose_A(Async := 1, handle := dFileHandle);
      eEventFileState := EventJournal_WAIT4FILECLOSE;
            
            
    //===========================================================================================
    EventJournal_WAIT4FILECLOSE:
      // Datei schon geschlossen?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);

      case dAsyncState of
        0:
          //-------------------------------------------------------------------------------------
          //  Fertig und geschlossen?
          //-------------------------------------------------------------------------------------
          if (dFileHandle >= 0) then
              
            // schließe das aktuelle Fenster 
            InsertCmd(x0:=CMD_CLOSE, x1:=0, x2:=0);
            
            // Server zurücksetzen
            ExportActLineNr   := 0;
            ExportLineNumbers := 0;
            ExportProgress    := 0;
              
            eRetcode        := READY;
            eEventFileState := EventJournal_STARTEXPORT;
              
          else
            
            if (IsCon_coSystemLogging = True) then    // KaiAnd
              coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Schließen der Datei für EventJournal" );
            end_if;
            eRetcode        := ERROR;
            eEventFileState := EventJournal_STARTEXPORT;
              
          end_if;  
          //-------------------------------------------------------------------------------------
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Schließen der Datei für EventJournal" );
          end_if;
          eRetcode        := ERROR;
          eEventFileState := EventJournal_STARTEXPORT;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::ExportEvents(): Fehler beim Schließen der Datei für EventJournal" );
        end_if;
        eRetcode        := ERROR;
        eEventFileState := EventJournal_STARTEXPORT;                                
      end_case;
            
  end_case;
  
END_FUNCTION


FUNCTION EventJournal::TableLines
	VAR_INPUT
		sColor 	: _COLOR;
		pRoom 	: ^_ROOM;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpRoom   : _ROOM;
  END_VAR

  // Übergabeparameter prüfen
  if (pRoom = NIL) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
  
  
  // Bereich definieren
  tmpRoom.xy1.x := iOldScrollOffset;
  tmpRoom.xy1.y := pRoom^.xy1.y;
  tmpRoom.xy2.x := iOldScrollOffset;
  tmpRoom.xy2.y := pRoom^.xy2.y;
  
  
  //-----------------------------------------------------------------------------------------
  //  Trennline zwischen Spalte 1 und Spalte 2
  //-----------------------------------------------------------------------------------------
  if (ColumnChoice AND 2#00001) then
    
    // Koordinaten bestimmen
    tmpRoom.xy1.x += to_int(EventConfig.aColumnWidths[0]);
    tmpRoom.xy2.x += to_int(EventConfig.aColumnWidths[0]);

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := sColor);
  
  end_if;

  //-----------------------------------------------------------------------------------------
  //  Trennline zwischen Spalte 2 und Spalte 3
  //-----------------------------------------------------------------------------------------
  if (ColumnChoice AND 2#00010) then
    
    // Koordinaten bestimmen
    tmpRoom.xy1.x += to_int(EventConfig.aColumnWidths[1]);
    tmpRoom.xy2.x += to_int(EventConfig.aColumnWidths[1]);

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := sColor);
  
  end_if;

  //-----------------------------------------------------------------------------------------
  //  Trennline zwischen Spalte 3 und Spalte 4
  //-----------------------------------------------------------------------------------------
  if (ColumnChoice AND 2#00100) then
    
    // Koordinaten bestimmen
    tmpRoom.xy1.x += to_int(EventConfig.aColumnWidths[2]);
    tmpRoom.xy2.x += to_int(EventConfig.aColumnWidths[2]);

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := sColor);
  
  end_if;

  //-----------------------------------------------------------------------------------------
  //  Trennline zwischen Spalte 4 und Spalte 5
  //-----------------------------------------------------------------------------------------
  if (ColumnChoice AND 2#01000) then
    
    // Koordinaten bestimmen
    tmpRoom.xy1.x += to_int(EventConfig.aColumnWidths[3]);
    tmpRoom.xy2.x += to_int(EventConfig.aColumnWidths[3]);

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := sColor);
  
  end_if;

  //-----------------------------------------------------------------------------------------

END_FUNCTION


FUNCTION VIRTUAL EventJournal::GetEventText
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		pEventTxt 	: ^_CHAR;
	END_VAR
  VAR
    pText       : ^_CHAR;
    tmpColor    : _COLOR;
    tmpIndex    : UINT;
   	MemVarLabel	: _MEM_VARLABEL;			// pointer to structure to get variables or constants 
  END_VAR

  //===============================================================================================
  //  INIT
  //===============================================================================================
  pEventTxt := NIL;
  
  //===============================================================================================
  //  Übergabeparameter prüfen
  //===============================================================================================
  if (pEntry = NIL) then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::GetEventText(): Übergabeparameter pEntry = NIL" );
    end_if;
    return;
  end_if;

  //===============================================================================================
  //  create the memvarlabel for the defined text
  //===============================================================================================
 	init_MEM_VARLABEL(#MemVarLabel);

  if (pEntry^.ptr <> NIL) then
		// allocate the memory 
    if ((Graphic.Memory(#MemVarLabel.ptr, sizeof(_VARLABEL))) <> NIL) then
            
      MemVarLabel.no := 1;
      MemVarLabel.ptr^.no := 1;
      MemVarLabel.ptr^.info[0].state := POINTER_CHAR;
      MemVarLabel.ptr^.info[0].value := pEntry^.ptr$DINT;
    end_if;
  end_if;
  
  //===============================================================================================
  //  UNTERSCHEIDUNG DER VERSCHIEDENEN EINTRÄGE
  //===============================================================================================
  case (pEntry^.entrytype) of
  
      //=======================================================================================
      //  Steuerung wurde eingeschaltet
      //---------------------------------------------------------------------------------------
      EVENT_SWITCHON:
        
        pEventTxt$^void := NewDoScheme(x0 := EventConfig.SystemOnOff.list, 
                                      x1 := EVENT_TEXTSWITCHON, 
                                      x2 := EventConfig.SystemOnOff.no);
        
        if (pEventTxt = NIL) then
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="System on", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
          pEventTxt := #tmpEvTxt[0];
        end_if;

      //=======================================================================================
      //  Steuerung wurde ausgeschaltet
      //---------------------------------------------------------------------------------------
      EVENT_SWITCHOFF:
        
        pEventTxt$^void := NewDoScheme(x0 := EventConfig.SystemOnOff.list, 
                                      x1 := EVENT_TEXTSWITCHOFF, 
                                      x2 := EventConfig.SystemOnOff.no);

        if (pEventTxt = NIL) then
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="System off", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
          pEventTxt := #tmpEvTxt[0];
        end_if;

      //=======================================================================================
      //  Betriebsart wurde umgeschaltet
      //---------------------------------------------------------------------------------------
      EVENT_OPCHANGE:
        
        // je nach Betriebsart anderen Text aus Liste holen
        case (pEntry^.para[2]$t_e_OPMode) of
          OPMode_Init:      tmpIndex := EVENT_TEXTOPMODEINIT;
          OPMode_Stop:      tmpIndex := EVENT_TEXTOPMODESTOP;
          OPMode_Setup:     tmpIndex := EVENT_TEXTOPMODESETUP;
          OPMode_Manual:    tmpIndex := EVENT_TEXTOPMODEMANUAL;
          OPMode_SemiAuto:  tmpIndex := EVENT_TEXTOPMODESEMIAUTO;
          OPMode_Automatic: tmpIndex := EVENT_TEXTOPMODEAUTOMATIC;
        else
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::GetEventText(): unbekannter Betriebsmodus eingetragen" );
          end_if;
          tmpIndex := EVENT_TEXTOPMODEINIT;
        end_case;

        // Text aus Textliste holen
        pEventTxt$^void := NewDoScheme(x0 := EventConfig.OPMode.list, 
                                       x1 := tmpIndex, 
                                       x2 := EventConfig.OPMode.no);
        
        // Prüfen ob Text gefunden wurde
        if (pEventTxt = NIL) then
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="change OP mode", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
          pEventTxt := #tmpEvTxt[0];
        end_if;
        
      //=======================================================================================
      //  Login
      //---------------------------------------------------------------------------------------
      EVENT_USERLOGIN:
               	
        pText := StupidTextScheme(Event_TextLogin, EventConfig.LoginLogout.no);
        pText := make_parameterstring(pText, #MemVarLabel, _TRUE);
          
        // Prüfen ob Text verfügbar
        if (pText = NIL) then
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="user login text not found", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        else
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        end_if;
        pEventTxt := #tmpEvTxt[0];
        
      //=======================================================================================
      //  Logout
      //---------------------------------------------------------------------------------------
      EVENT_USERLOGOUT:
        
        // Alarmtext bestimmen
        pText := StupidTextScheme(EVENT_TEXTLOGOUT, EventConfig.LoginLogout.no);
        pText := make_parameterstring(pText, #MemVarLabel, _TRUE);
                
        // Prüfen ob Text verfügbar
        if (pText = NIL) then
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="user logout text not found", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        else
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        end_if;
        pEventTxt := #tmpEvTxt[0];
  
      //=======================================================================================
      //  Benutzer-Event
      //---------------------------------------------------------------------------------------
      EVENT_USEREVENT:
                        
        pEventTxt$^void := pEntry^.ptr;
        
      //=======================================================================================
      //  Datumsänderung
      //---------------------------------------------------------------------------------------
      EVENT_DATECHANGE:
        
        pEventTxt := GetTextEventDateChange(pEntry);
        
      //=======================================================================================
      //  Zeitänderung
      //---------------------------------------------------------------------------------------
      EVENT_TIMECHANGE:
      
        pEventTxt := GetTextEventTimeChange(pEntry);

      //=======================================================================================
      //  Wertänderung
      //---------------------------------------------------------------------------------------
      EVENT_VALUECHANGE:
      
        pEventTxt := GetTextEventValueChange(pEntry);
        
      //=======================================================================================
      //  Menüeintrags-Änderung
      //---------------------------------------------------------------------------------------
      EVENT_MENUCHANGE:
      
        pEventTxt := GetTextEventMenueChange(pEntry);
        
      //=======================================================================================
      //  Alarm
      //---------------------------------------------------------------------------------------
      EVENT_ALARM :
        // Alarmtext bestimmen
        pEventTxt := create_alarmtext(p0:= pEntry, x1:=false, p2:=#tmpColor);
        
        // Prüfen ob Text verfügbar
        if (pEventTxt = NIL) then
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::GetEventText(): Text für den Alarm nicht gefunden" );          
          end_if;
        end_if;

      //=======================================================================================
      //  System Meldungen Kategorie 1
      //---------------------------------------------------------------------------------------
      Event_SystemCat1 :
      
        // Alarmtext bestimmen
        pText := StupidTextScheme(pEntry^.para[2], EventConfig.SystemEntryCategory1.no);
        pText := make_parameterstring(pText, #MemVarLabel, _TRUE);
          
        // Prüfen ob Text verfügbar
        if (pText = NIL) then
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="system text cat1 not found", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        else
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        end_if;
        pEventTxt := #tmpEvTxt[0];
                
      //=======================================================================================
      //  System Meldungen Kategorie 2
      //---------------------------------------------------------------------------------------
      Event_SystemCat2 :
      
        // Alarmtext bestimmen
        pText := StupidTextScheme(pEntry^.para[2], EventConfig.SystemEntryCategory2.no);
        pText := make_parameterstring(pText, #MemVarLabel, _TRUE);
          
        // Prüfen ob Text verfügbar
        if (pText = NIL) then
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="system text cat2 not found", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        else
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        end_if;
        pEventTxt := #tmpEvTxt[0];

      //=======================================================================================
      //  System Meldungen Kategorie 3
      //---------------------------------------------------------------------------------------
      Event_SystemCat3 :
      
        // Alarmtext bestimmen
        pText := StupidTextScheme(pEntry^.para[2], EventConfig.SystemEntryCategory3.no);
        pText := make_parameterstring(pText, #MemVarLabel, _TRUE);
          
        // Prüfen ob Text verfügbar
        if (pText = NIL) then
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="system text cat3 not found", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        else
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        end_if;
        pEventTxt := #tmpEvTxt[0];

      //=======================================================================================
      //  System Meldungen Kategorie 4
      //---------------------------------------------------------------------------------------
      Event_SystemCat4 :
      
        // Alarmtext bestimmen
        pText := StupidTextScheme(pEntry^.para[2], EventConfig.SystemEntryCategory4.no);
        pText := make_parameterstring(pText, #MemVarLabel, _TRUE);
          
        // Prüfen ob Text verfügbar
        if (pText = NIL) then
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="system text cat4 not found", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        else
          StrNCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
        end_if;
        pEventTxt := #tmpEvTxt[0];
        
      //=======================================================================================
      // Nicht unterstütztes Event     
      //---------------------------------------------------------------------------------------
      else
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::GetEventText(): Eintrag aus EventJournal nicht unterstützt" );
        end_if;
        
  end_case;

	// frees the memory
	free_MEM_VARLABEL(#MemVarLabel);

END_FUNCTION


FUNCTION EventJournal::GetEventTime
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
		pRetdDate 	: ^DINT;    // V.1.2
		pRetdTime 	: ^DINT;    // V.1.2
	END_VAR
	VAR_OUTPUT
		pString 	: ^_CHAR;
	END_VAR
  VAR
    tmpLength : UDINT;
  	tmpDate   : _DATE;
    tmpTime   : _TIME;
    tmpHlpTxt : ARRAY [0..20] OF _CHAR;
  END_VAR

  // Rückgabewert initialisieren
  pString := NIL;
  if (pRetdDate <> NIL) then     // V.1.2
    pRetdDate^ := 0;
  end_if;
  if (pRetdTime <> NIL) then     // V.1.2
    pRetdTime^ := 0;
  end_if;
  
  // Übergabeparameter prüfen
  if (pEntry = NIL) then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::GetEventTime(): Übergabeparameter pEntry = NIL");
    end_if;
    return;
  end_if;
  
  // Datum wandeln
  lasal_to_DATE(p0:=#tmpDate, x1:=pEntry^.date_on);
                
  // String erzeugen
  format_date(p0:=#tmpHlpTxt[0], p1:=#tmpDate, x2:=SIZE_DDMMYY);
              
  // String anfügen
  StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=#tmpHlpTxt[0], x3:=sizeof(_CHAR));
  
  // Seperator einfügen
  StrCat(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=" ", x3:=1);
          
  // Zeit wandeln
  lasal_to_TIME(p0:=#tmpTime, x1:=pEntry^.time_on);
  
  // String erzeugen
  format_time(p0:=#tmpHlpTxt[0], p1:=#tmpTime, x2:=SIZE_HHMMSS);
              
  // String anfügen
  StrCat(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=#tmpHlpTxt[0], x3:=sizeof(_CHAR));

  // Länge bestimmen + 0 - Abschluss
  tmpLength := StrLen(txt:=#tmpEvTxt[0], size:=sizeof(_CHAR)) + 1;

  // Pointer auf String zurück liefern
  pString := #tmpEvTxt[0];
          
  // return also Date and Time as values   V.1.2, KaiAnd
  if (pRetdDate <> NIL) then
    pRetdDate^ := pEntry^.date_on;
  end_if;
  if (pRetdTime <> NIL) then
    pRetdTime^ := pEntry^.time_on;
  end_if;

END_FUNCTION


FUNCTION EventJournal::GetParameter1
	VAR_INPUT
		pEntry 	 : ^_SINGLEALARM;
		pRetDINT : ^DINT;    // V.1.2
	END_VAR
	VAR_OUTPUT
		pString  : ^_CHAR;
	END_VAR
  VAR
    tmpPara1 : DINT;
  END_VAR

  // Rückgabewert initialisieren
  pString  := NIL;
  tmpPara1 := 0;
  if (pRetDINT <> NIL) then     // V.1.2
    pRetDINT^ := 0;
  end_if;
  
  // Übergabeparameter prüfen
  if (pEntry = NIL) then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::GetParameter1(): Übergabeparameter pEntry = NIL");
    end_if;
    return;
  end_if;

  // Länge prüfen
  #pragma warning(disable:69); // disable warning 
  if ( sizeof(tmpEvTxt) < 20 ) then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::GetParameter1(): Länge des Zielstrings zu klein");
    end_if;
    return;
  end_if;
  #pragma warning(default:69); 
  
  //*****************************************************************************
  //** UNTERSCHEIDUNG DER EVENTS                                               **
  //*****************************************************************************
  
  case pEntry^.entrytype of
  
    // Alarm
    //*****************************************************************************
    EVENT_ALARM:
      
      // Prüfen ob Parameter1 verfügbar
      if (pEntry^.no_para >= 1) then
        // Parameter1 steht am letzten Parameter
        tmpPara1 := pEntry^.para[pEntry^.no_para -1];
      else
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::GetParameter1(): Kein Parameter1 für Event verfügbar");
        end_if;
      end_if;
    
      
    // Alles andere
    //*****************************************************************************
    else
      
      // Prüfen ob Parameter1 verfügbar
      if (pEntry^.no_para >= 1) then
        // Parameter1 steht immer am ersten Parameter
        tmpPara1 := pEntry^.para[0];
      else
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("EventJournal::GetParameter1(): Kein Parameter1 für Event verfügbar");
        end_if;
      end_if;
      
  end_case;
  
  // Nummer zu Text wandeln
  DToA(p0:=#tmpEvTxt[0], x1:=tmpPara1, x2:=Event_ConfigParam1, x3:=sizeof(_CHAR));
  pString := #tmpEvTxt[0];

  // return also value     V.1.2, KaiAnd
  if (pRetDINT <> NIL) then
    pRetDINT^ := tmpPara1;
  end_if;
        
END_FUNCTION


FUNCTION EventJournal::GetAlarmNo
	VAR_INPUT
		pEntry 	 : ^_SINGLEALARM;
		pRetDINT : ^DINT;    // V.1.2
	END_VAR
	VAR_OUTPUT
		pString  : ^_CHAR;
	END_VAR
  VAR
    tmpAlaNo : DINT;
  END_VAR

  // Rückgabewert initialisieren
  pString  := NIL;
  tmpAlaNo := 0;
  if (pRetDINT <> NIL) then     // V.1.2
    pRetDINT^ := 0;
  end_if;
  
  // Übergabeparameter prüfen
  if (pEntry = NIL) then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::GetAlarmNo(): Übergabeparameter pEntry = NIL");
    end_if;
    return;
  end_if;
  
  // Länge prüfen
  #pragma warning(disable:69); // disable warning 
  if ( sizeof(tmpEvTxt) < 20 ) then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::GetAlarmNo(): Länge des Zielstrings zu klein");
    end_if;
    return;
  end_if;
  #pragma warning(default:69); 

  //*****************************************************************************
  //** UNTERSCHEIDUNG DER VERSCHIEDENEN EINTRÄGE                               **
  //*****************************************************************************
  
  case (pEntry^.entrytype) of
  
    // Eventeintrag ist ein Alarm bzw. Wertänderung
    //*****************************************************************************
    EVENT_ALARM:
    
      tmpAlaNo := pEntry^.no;

      // Alarmnummer bzw. Bildnummer zu Text wandeln
      DToA(p0:=#tmpEvTxt[0], x1:=pEntry^.no, x2:=EVENT_CONFIGALARMNO, x3:=sizeof(_CHAR));
      pString := #tmpEvTxt[0];
    
    // Alles Andere
    //*****************************************************************************
    else
      
      // es wird keine Zahl dargestellt
      StrCpy(p0:=#tmpEvTxt[0], x1:= sizeof(_CHAR), p2:=" ", x3:=1);  
      pString := #tmpEvTxt[0];
    
  end_case;

  // return also value     V.1.2, KaiAnd
  if (pRetDINT <> NIL) then
    pRetDINT^ := tmpAlaNo;
  end_if;

END_FUNCTION


FUNCTION EventJournal::GetParameter2
	VAR_INPUT
		pEntry 	 : ^_SINGLEALARM;
		pRetDINT : ^DINT;    // V.1.2
	END_VAR
	VAR_OUTPUT
		pString  : ^_CHAR;
	END_VAR
  VAR
    tmpPara2 : DINT;
  END_VAR

  // Rückgabewert initialisieren
  pString  := NIL;
  tmpPara2 := 0;
  if (pRetDINT <> NIL) then     // V.1.2
    pRetDINT^ := 0;
  end_if;
  
  // Übergabeparameter prüfen
  if (pEntry = NIL) then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::GetParameter2(): Übergabeparameter pEntry = NIL");
    end_if;
    return;
  end_if;

  // Länge prüfen
  #pragma warning(disable:69); // disable warning 
  if ( sizeof(tmpEvTxt) < 20 ) then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::GetParameter2(): Länge des Zielstrings zu klein");
    end_if;
    return;
  end_if;
  #pragma warning(default:69); 
  
  //*****************************************************************************
  //** UNTERSCHEIDUNG DER VERSCHIEDENEN EINTRÄGE                               **
  //*****************************************************************************
  
  case pEntry^.entrytype of
  
    // Eventeintrag prüfen, ob Parameter2 verfügbar ist
    //*****************************************************************************
    Event_SystemCat1, Event_SystemCat2,
    Event_SystemCat3, Event_SystemCat4,
    Event_UserLogout, Event_UserLogin,
    EVENT_DATECHANGE, EVENT_TIMECHANGE,
    Event_OPChange, Event_MenuChange,
    Event_UserEvent, Event_EventEntry,
    Event_ValueChange:
    
      tmpPara2 := pEntry^.para[1];

      // Parameter2 zu Text wandeln
      DToA(p0:=#tmpEvTxt[0], x1:=pEntry^.para[1], x2:=EVENT_CONFIGPARAM2, x3:=sizeof(_CHAR));
      pString := #tmpEvTxt[0];
      
    // Alles Andere
    //*****************************************************************************
    else
      
      // es wird keine Zahl dargestellt
      StrCpy(p0:=#tmpEvTxt[0], x1:= sizeof(_CHAR), p2:=" ", x3:=1);  
      pString := #tmpEvTxt[0];
      
  end_case;

  // return also value     V.1.2, KaiAnd
  if (pRetDINT <> NIL) then
    pRetDINT^ := tmpPara2;
  end_if;

END_FUNCTION


FUNCTION EventJournal::GetTextEventDateChange
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		pString 	: ^_CHAR;
	END_VAR
  VAR
    pText       : ^_CHAR;
    tmpLength   : UDINT;
    tmpHlpTxt   : ARRAY[0..49] OF _CHAR;
    tmpVariable : _VARIABLE;
    tmpDate     : _DATE;
    szValueTxt  : ARRAY[0..199] of _CHAR;
  END_VAR
  
  // Variableninformation vom Server holen
  if (VarList_GetSingleVariable(p0:=#tmpVariable, x1:=to_udint(pEntry^.para[2])) = true) then
  
    // Variablentext holen
    //*****************************************************************************
    pText := VarList_GetTextByNo(x0:=to_udint(pEntry^.para[2]), x1:=0);
                                    
    // Prüfen ob UnitText verfügbar
    if (pText <> NIL) then
      // String auf Ziel kopieren
      StrNCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
    else
      // String auf Ziel kopieren
      StrNCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no text defined", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
    end_if;
    
    tmpLength := StrSize(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR));
    
    
    //*****************************************************************************
    // Wertänderung zusammenbauen
    //*****************************************************************************
    
    // Alten Wert wandeln
    lasal_to_DATE(p0:=#tmpDate, x1:=pEntry^.para[3]);
    format_date(#tmpHlpTxt[0], #tmpDate, SIZE_DDMMYYYY);   
     
    StrCpy(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:=": ", x3:=1);
        
    StrCat(p0:=#szValueTxt[0] ,x1:=sizeof(_CHAR), p2 := #tmpHlpTxt[0], x3:=sizeof(_CHAR));
      
    // Neuen Wert wandeln
    lasal_to_DATE(p0:=#tmpDate, x1:=pEntry^.para[4]);
    format_date(#tmpHlpTxt[0], #tmpDate, SIZE_DDMMYYYY);   
    
    StrCat(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:= " -> ", x3 := 1);
    StrCat(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:= #tmpHlpTxt[0], x3 := sizeof(_CHAR));
    
    tmpLength += StrSize(p0:=#szValueTxt[0], x1:=sizeof(szValueTxt[0])) + sizeof(szValueTxt[0]);
    
    if (tmpLength <= sizeof(tmpEvTxt)) then 
      StrCat(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=#szValueTxt[0], x3:=sizeof(_CHAR));
    else
      StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="text too long", x3:=1);
    end_if;
      
  else
      StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no variable defined", x3:=1);
  end_if;

  // Pointer mit Ergebnis zurück liefern
  pString := #tmpEvTxt[0];

END_FUNCTION


FUNCTION EventJournal::GetTextEventTimeChange
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		pString 	: ^_CHAR;
	END_VAR
  VAR
    pText       : ^_CHAR;
    tmpLength   : UDINT;
    tmpHlpTxt   : ARRAY[0..49] OF _CHAR;
    tmpVariable : _VARIABLE;
    tmpTime     : _TIME;
    szValueTxt  : ARRAY[0..199] of _CHAR;
  END_VAR
  
  // Variableninformation vom Server holen
  if (VarList_GetSingleVariable(p0:=#tmpVariable, x1:=to_udint(pEntry^.para[2])) = true) then
  
    // Variablentext holen
    //*****************************************************************************
    pText := VarList_GetTextByNo(x0:=to_udint(pEntry^.para[2]), x1:=0);
                                    
    // Prüfen ob UnitText verfügbar
    if (pText <> NIL) then
      // String auf Ziel kopieren
      StrNCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
    else
      // String auf Ziel kopieren
      StrNCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no text defined", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
    end_if;
    
    tmpLength := StrSize(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR));
    
    
    //*****************************************************************************
    // Wertänderung zusammenbauen
    //*****************************************************************************
    
    // alten Wert wandeln
    lasal_to_TIME(p0:=#tmpTime, x1:=pEntry^.para[3]);
    format_time(#tmpHlpTxt[0], #tmptime, SIZE_HHMMSS);   
     
    StrCpy(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:=": ", x3:=1);
        
    StrCat(p0:=#szValueTxt[0] ,x1:=sizeof(_CHAR), p2:=#tmpHlpTxt[0], x3:=sizeof(_CHAR));
      
    // neuen Wert wandeln
    lasal_to_TIME(p0:=#tmpTime, x1:=pEntry^.para[4]);
    format_time(#tmpHlpTxt[0], #tmpTime, SIZE_HHMMSS);   
    
    StrCat(p0:= #szValueTxt[0], x1:=sizeof(_CHAR), p2:=" -> ", x3:=1);
    StrCat(p0:= #szValueTxt[0], x1:=sizeof(_CHAR), p2:=#tmpHlpTxt[0], x3:=sizeof(_CHAR));
    
    tmpLength += StrSize(p0:=#szValueTxt[0], x1:=sizeof(szValueTxt[0])) + sizeof(szValueTxt[0]);
    
    if (tmpLength <= sizeof(tmpEvTxt)) then
      StrCat(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=#szValueTxt[0], x3:=sizeof(_CHAR));
    else
      StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="text too long", x3:=1);
    end_if;

  else
      StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no variable defined", x3:=1);
  end_if;

  // Pointer mit Ergebnis zurück liefern
  pString := #tmpEvTxt[0];

END_FUNCTION


FUNCTION EventJournal::GetTextEventValueChange
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		pString 	: ^_CHAR;
	END_VAR
  VAR
    pText       : ^_CHAR;
    tmpLength   : UDINT;
    tmpResult   : _RESULT;
    tmpHlpTxt   : ARRAY[0..49] OF _CHAR;
    tmpVariable : _VARIABLE;
    szValueTxt  : ARRAY[0..199] of _CHAR;
    szUnitTxt   : ARRAY[0..49] of _CHAR; 
  END_VAR
  
  // Variableninformation vom Server holen
  if (VarList_GetSingleVariable(p0:=#tmpVariable, x1:=to_udint(pEntry^.para[2])) = true) then
  
    // Variablentext holen
    //*****************************************************************************
    pText := VarList_GetTextByNo(x0:=to_udint(pEntry^.para[2]), x1:=0);
                                    
    // Prüfen ob UnitText verfügbar
    if (pText <> NIL) then
      // String auf Ziel kopieren
      StrNCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
    else
      // String auf Ziel kopieren
      StrNCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no text defined", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
    end_if;
    
    tmpLength := StrSize(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR));
    
    
    //*****************************************************************************
    // Wertänderung zusammenbauen
    //*****************************************************************************
    
    //Unit holen
    pText := VarList_GetTextByNo(x0:=to_udint(pEntry^.para[2]), x1:=5);
    if (pText = NIL)  then  // KaiAnd: unit is fine but not needed!!
    
      StrCpy(p0:=#szUnitTxt[0], x1:=sizeof(_CHAR), p2:=" [ ] ", x3:=1);

    else
        
      // [ einfügen
      StrCpy(p0:=#szUnitTxt[0], x1:=sizeof(_CHAR), p2:=" [", x3:=1);
      // String mit Unit-Text kopieren
      StrCat(p0:=#szUnitTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR));            
      // ] einfügen
      StrCat(p0:=#szUnitTxt[0], x1:=sizeof(_CHAR), p2:="] ", x3:=1);

    end_if;


    // Alten Wert wandeln
    tmpResult.ftype := RES_NUMERIC;
    tmpResult.value := pEntry^.para[3];
      
    // Wert mit eingestellter Einheit umrechnen
    recalculate(p0:=#tmpResult, p1:=#tmpVariable, x2:=TRUE);
        
    // Wert mit eingestellter Unit formatieren
    format_value(p0:=#tmpHlpTxt[0], x1:=tmpResult.value, p2:=#tmpVariable.info, p3:=NIL);   
       
    StrCpy(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:=": ", x3:=1);
    StrCat(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:=#tmpHlpTxt[0], x3:=sizeof(_CHAR));
    StrCat(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:=#szUnitTxt[0], x3:= sizeof(_CHAR));
      
    // Neuen Wert wandeln
    tmpResult.value := pEntry^.para[4];
      
    // Wert mit eingestellter Einheit umrechnen
    recalculate(p0:=#tmpResult, p1:=#tmpVariable, x2:=TRUE);
        
    // Wert mit eingestellter Unit formatieren
    format_value(p0:=#tmpHlpTxt[0], x1:=tmpResult.value, p2:=#tmpVariable.info, p3:=NIL);  
      
    StrCat(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:=" -> ", x3:=1);
    StrCat(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:=#tmpHlpTxt[0], x3:=sizeof(_CHAR));   
    StrCat(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:=#szUnitTxt[0], x3:=sizeof(_CHAR));
      
    tmpLength += StrSize(p0:=#szValueTxt[0], x1:=sizeof(szValueTxt[0])) + sizeof(szValueTxt[0]);
      
    if (tmpLength <= sizeof(tmpEvTxt)) then
      StrCat(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=#szValueTxt[0], x3:=sizeof(_CHAR));
    else
      StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="text too long", x3:=1);
    end_if;

  else
      StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no variable defined", x3:=1);
  end_if;

  // Pointer mit Ergebnis zurück liefern
  pString := #tmpEvTxt[0];

END_FUNCTION


FUNCTION EventJournal::GetTextEventMenueChange
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		pString 	: ^_CHAR;
	END_VAR
  VAR
    pText       : ^_CHAR;
    tmpLength   : UDINT;
    tmpVariable : _VARIABLE;
    szValueTxt  : ARRAY[0..199] of _CHAR;
    pMenue      : ^_LSEMENU;
    pLine       : ^_LINEINFO;
    pMenuText   : ^void;
  END_VAR
  
  // Variableninformation vom Server holen
  if (VarList_GetSingleVariable(p0:=#tmpVariable, x1:=to_udint(pEntry^.para[2])) = true) then
  
    // Variablentext holen
    //*****************************************************************************
    pText := VarList_GetTextByNo(x0:=to_udint(pEntry^.para[2]), x1:=0);
                                    
    // Prüfen ob UnitText verfügbar
    if (pText <> NIL) then
      // String auf Ziel kopieren
      StrNCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=pText, x3:=sizeof(_CHAR), ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
    else
      // String auf Ziel kopieren
      StrNCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no text defined", x3:=1, ml:=sizeof(tmpEvTxt)/sizeof(_CHAR));
    end_if;
    
    tmpLength := StrSize(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR));
    
    
    //*****************************************************************************
    // Wertänderung zusammenbauen
    //*****************************************************************************
    
    // Zeiger auf Menü holen
    pMenue := get_LSEMENU(pEntry^.para[5]$UDINT);
    
    if (pMenue <> NIL) then
      
      // Alten Wert wandeln
      // Zeiger auf erste Menüzeile holen
      pLine := pMenue^.mem_lineinfo.ptr;
      
      if (pLine <> NIL) then
      
        // Zeiger auf gewünschte Zeilennummer bilden
        pLine += pEntry^.para[3] * sizeof(_LINEINFO);
        
        // Zeiger auf Menü-Text holen
        pMenuText := get_ANYTHING(#pLine^.anypara.anything, NIL);
        
        if (pMenuText <> NIL) then
        
          StrCpy(p0:=#szValueTxt[0], x1:=sizeof(_CHAR), p2:=": ", x3:=1);  
          StrCat(p0:=#szValueTxt[0] ,x1:=sizeof(_CHAR), p2:=pMenuText, x3:=sizeof(_CHAR));
            
          // Neuen Wert wandeln
          // Zeiger auf gewünschte Zeilennummer bilden
          pLine -= pEntry^.para[3] * sizeof(_LINEINFO); 
          pLine += pEntry^.para[4] * sizeof(_LINEINFO);
          
          // Zeiger auf Menü-Text holen
          pMenuText := get_ANYTHING(#pLine^.anypara.anything, NIL);
          
          StrCat(p0:= #szValueTxt[0] ,x1:=sizeof(_CHAR), p2:=" -> ", x3 := 1);
          StrCat(p0:= #szValueTxt[0] ,x1:=sizeof(_CHAR), p2:=pMenuText, x3 := sizeof(_CHAR));
          
          tmpLength += StrSize(p0:=#szValueTxt[0], x1:=sizeof(szValueTxt[0])) + sizeof(szValueTxt[0]);
          
          if (tmpLength <= sizeof(tmpEvTxt)) then
            StrCat(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=#szValueTxt[0], x3:=sizeof(_CHAR));
          end_if;
          
        else
          StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no variable defined", x3:=1);  
        end_if;
        
      else
        StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no variable defined", x3:=1);
      end_if;

    else
      StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no variable defined", x3:=1);
    end_if;

    if (tmpLength <= sizeof(tmpEvTxt)) then  
      StrCat(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:=#szValueTxt[0], x3:=sizeof(_CHAR));
    end_if;

  else
      StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="no variable defined", x3:=1);
  end_if;

  // Pointer mit Ergebnis zurück liefern
  pString := #tmpEvTxt[0];     

END_FUNCTION



FUNCTION EventJournal::GetTheUrgeValues
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpCounter  : USINT;
    tmpResult   : _RESULT;
    tmpVariable : _VARIABLE;
    tmpVarLabel : _VARLABEL;
  END_VAR
  
  bSuccessful := true;
  
  // loop to check all variables
  for tmpCounter := 0 to sizeof(aVarSingle) / sizeof(aVarSingle[0]) - 1 do
  
    // check if variable is a dataserver
    if (aVarSingle[tmpCounter].state = VAR_VAL) then
      
      // build varlabel
      tmpVarLabel.no      := 1;
      tmpVarLabel.info[0] := aVarSingle[tmpCounter];
    
      // get server-value
      if VarList_GetSystemData( p0 := #tmpResult, 
                                p1 := #tmpVariable, 
                                p2 := #tmpVarLabel, 
                                x3 := false) = true then
        
        // save the new value + change checksum
        EventConfig.aColumnWidths[tmpCounter] := tmpResult.value;
      
      else
        bSuccessful := false;
      end_if;

    end_if;

  end_for;  
    
END_FUNCTION


FUNCTION EventJournal::GetTheUrge
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpCounter      : USINT;
	  pVarLabel       : ^_VARLABEL;
    pColor          : ^_COLOR;
    pHelpAnyThing   : ^_ANYTHING;
    tmpIndex        : UINT;
    tmpCount        : UINT;
    tmpColType      : UINT;
  END_VAR

  // Gültiger Übergabeparameter?
  if (pio <> NIL) & (pio^.theurge <> NIL) then
    
    // Richtige Version des UDCs?
    if (pio^.theurge^.info = Event_UDCVersion) then
  
      bSuccessful := true;
      
      // variable informations
      //--------------------------------------------------------------
      // check number of variables
      if (pio^.theurge^.memvarlabel.no = Event_VariableNo) then
        
        // pointer to variable informations
        pVarLabel := pio^.theurge^.memvarlabel.ptr;
        
        // loop to store all parameter
        for tmpCounter:=0 to (sizeof(aVarSingle)/sizeof(aVarSingle[0]) -1) do
        
          // save variable informations
          aVarSingle[tmpCounter] := pVarLabel^.info[0];
          
          // check for constant
          if (aVarSingle[tmpCounter].state = CONST_VAL) then
            EventConfig.aColumnWidths[tmpCounter] := aVarSingle[tmpCounter].value;
          end_if;

          // step to next variable
          pVarLabel += sizeof(_VARLABEL);
          
        end_for;

      else
        bSuccessful := false;
      end_if;

      
      // Index des Textschemas holen
      //-----------------------------------------------------------------------------------------
      if (pio^.theurge^.memanything.no = Event_TextschemeNo) then
        
        pHelpAnyThing := pio^.theurge^.memanything.ptr;
        
        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          EventConfig.SystemOnOff.list := pHelpAnyThing^.list;
          EventConfig.SystemOnOff.no   := pHelpAnyThing^.no;
        else
          EventConfig.SystemOnOff.list := DEFLST;
          EventConfig.SystemOnOff.no   := DEFSCOPE;
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Verweis auf Textliste konnte nicht bestimmt werden");
          end_if;
        end_if;

        pHelpAnyThing += sizeof(_ANYTHING);
        
        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          EventConfig.OPMode.list := pHelpAnyThing^.list;
          EventConfig.OPMode.no   := pHelpAnyThing^.no;
        else
          EventConfig.OPMode.list := DEFLST;
          EventConfig.OPMode.no   := DEFSCOPE;
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Verweis auf Textliste konnte nicht bestimmt werden");
          end_if;
        end_if;

        pHelpAnyThing += sizeof(_ANYTHING);
        
        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          EventConfig.LoginLogout.list := pHelpAnyThing^.list;
          EventConfig.LoginLogout.no   := pHelpAnyThing^.no;
        else
          EventConfig.LoginLogout.list := DEFLST;
          EventConfig.LoginLogout.no   := DEFSCOPE;
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Verweis auf Textliste konnte nicht bestimmt werden");
          end_if;
        end_if;

        pHelpAnyThing += sizeof(_ANYTHING);
        
        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          EventConfig.SystemEntryCategory1.list := pHelpAnyThing^.list;
          EventConfig.SystemEntryCategory1.no   := pHelpAnyThing^.no;
        else
          EventConfig.SystemEntryCategory1.list := DEFLST;
          EventConfig.SystemEntryCategory1.no   := DEFSCOPE;
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Verweis auf Textliste konnte nicht bestimmt werden");
          end_if;
        end_if;

        pHelpAnyThing += sizeof(_ANYTHING);
        
        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          EventConfig.SystemEntryCategory2.list := pHelpAnyThing^.list;
          EventConfig.SystemEntryCategory2.no   := pHelpAnyThing^.no;
        else
          EventConfig.SystemEntryCategory2.list := DEFLST;
          EventConfig.SystemEntryCategory2.no   := DEFSCOPE;
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Verweis auf Textliste konnte nicht bestimmt werden" );
          end_if;
        end_if;

        pHelpAnyThing += sizeof(_ANYTHING);

        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          EventConfig.SystemEntryCategory3.list := pHelpAnyThing^.list;
          EventConfig.SystemEntryCategory3.no   := pHelpAnyThing^.no;
        else
          EventConfig.SystemEntryCategory3.list := DEFLST;
          EventConfig.SystemEntryCategory3.no   := DEFSCOPE;
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Verweis auf Textliste konnte nicht bestimmt werden" );
          end_if;
        end_if;

        pHelpAnyThing += sizeof(_ANYTHING);
        
        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          EventConfig.SystemEntryCategory4.list := pHelpAnyThing^.list;
          EventConfig.SystemEntryCategory4.no   := pHelpAnyThing^.no;
        else
          EventConfig.SystemEntryCategory4.list := DEFLST;
          EventConfig.SystemEntryCategory4.no   := DEFSCOPE;
          if (IsCon_coSystemLogging = True) then    // KaiAnd
            coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Verweis auf Textliste konnte nicht bestimmt werden" );
          end_if;
        end_if;

        pHelpAnyThing += sizeof(_ANYTHING);
        
      else
        bSuccessful := false;
      end_if;

      
      // color informations
      //--------------------------------------------------------------
      // check number of colors
      tmpCount := 0;
      if (pio^.theurge^.memcolor.no = Event_ColorNo) then
        
        // pointer to color informations
        pColor := pio^.theurge^.memcolor.ptr;
        
        while (tmpCount < pio^.theurge^.memcolor.no) do

          // Jede Kategorie hat 2 Farben
          tmpIndex   := tmpCount / 2;     
          // Typ der Farbe (BgColor und TxtColor abwechseln im UDC eingetragen)
          tmpColType := tmpCount MOD 2;   
          
          // Textfarbe oder Hintergrundfarbe
          case (tmpColType) of
            
            0:
                EventConfig.aCategorieColors[tmpIndex].Cat_TextColor := pColor^;
            
            1:
                EventConfig.aCategorieColors[tmpIndex].Cat_BgColor   := pColor^;

          end_case;
          
          pColor   += sizeof(_COLOR);
          tmpCount += 1;
        end_while;
      
      else
        bSuccessful := false;
      end_if;    

    else
      bSuccessful := false;
      if (IsCon_coSystemLogging = True) then    // KaiAnd
        coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Falsche Version des UDCs");
      end_if;
    end_if;
  
  else
    bSuccessful := false;
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Ungültiger Übergabeparameter");
    end_if;
  end_if;
  
END_FUNCTION



FUNCTION EventJournal::WriteEventTime
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful : BOOL;
	END_VAR
  VAR
    pString    : ^_CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if ((pEntry = NIL) | (pRoom = NIL) )then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;

  // Text bestimmen
  pString := GetEventTime(pEntry:=pEntry, pRetdDate:=NIL, pRetdTime:=NIL);
  
  // Wenn kein Text verfügbar ist
  if (pString = NIL) then
    StrCpy(p0:= #tmpEvTxt[0], x1:=sizeof(_CHAR), p2:="01.01.70  00:00", x3:=1);
    pString := #tmpEvTxt[0];
  end_if;
  
  // Text ausgeben
  OutTextAlign( p0 := pString, 
                x1 := 0,
                p1 := pRoom, 
                x2 := sFont, 
                x3 := EVENT_ATTRSTANDARD OR EVENT_ATTRTIME, 
                x9 := _DEFFRAME, 
                x4 := sTextColor, 
                x5 := sBackColor, 
                x6 := sBackColor, 
                x7 := sizeof(pString^));
 
END_FUNCTION


FUNCTION EventJournal::WriteParameter1
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful : BOOL;
	END_VAR
  VAR
    pString     : ^_CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if ((pEntry = NIL) | (pRoom = NIL)) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
  
  // Text bestimmen
  pString := GetParameter1(pEntry:=pEntry, pRetDINT:=NIL);
  
  // Wenn kein Text verfügbar ist
  if (pString = NIL) then
    StrCpy(p0:=#tmpEvTxt[0], x1:=sizeof(_CHAR), p2:= "------", x3:=1);
    pString := #tmpEvTxt[0];
  end_if;
  
  // Text ausgeben
  OutTextAlign( p0 := pString, 
                x1 := 0,
                p1 := pRoom, 
                x2 := sFont, 
                x3 := EVENT_ATTRSTANDARD OR Event_AttrParam1, 
                x9 := _DEFFRAME, 
                x4 := sTextColor, 
                x5 := sBackColor, 
                x6 := sBackColor, 
                x7 := sizeof(pString^));
  
END_FUNCTION


FUNCTION EventJournal::WriteAlarmNo
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful : BOOL;
	END_VAR
  VAR
    pString     : ^_CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if ((pEntry = NIL) | (pRoom = NIL)) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
  
  // Text bestimmen
  pString := GetAlarmNo(pEntry:=pEntry, pRetDINT:=NIL);
  
  // Prüfen ob Text verfügbar ist
  if (pString <> NIL) then
    
    // Text ausgeben
    OutTextAlign( p0 := pString, 
                  x1 := 0,
                  p1 := pRoom, 
                  x2 := sFont, 
                  x3 := EVENT_ATTRSTANDARD OR EVENT_ATTRALARMNO, 
                  x9 := _DEFFRAME, 
                  x4 := sTextColor, 
                  x5 := sBackColor, 
                  x6 := sBackColor, 
                  x7 := sizeof(pString^));
  end_if;
  
END_FUNCTION


FUNCTION EventJournal::WriteParameter2
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful	: BOOL;
	END_VAR
  VAR
    pString     : ^_CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if ((pEntry = NIL) | (pRoom = NIL)) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
  
  // Text bestimmen
  pString := GetParameter2(pEntry:=pEntry, pRetDINT:=NIL);
  
  // Prüfen ob Text verfügbar ist
  if (pString <> NIL) then
  
    // Text ausgeben
    OutTextAlign( p0 := pString, 
                  x1 := 0,
                  p1 := pRoom, 
                  x2 := sFont, 
                  x3 := EVENT_ATTRSTANDARD OR EVENT_ATTRPARAM2, 
                  x9 := _DEFFRAME, 
                  x4 := sTextColor, 
                  x5 := sBackColor, 
                  x6 := sBackColor, 
                  x7 := sizeof(pString^));
  end_if;
  
END_FUNCTION


FUNCTION EventJournal::WriteEventText
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful : BOOL;
	END_VAR
  VAR
    pString     : ^_CHAR;
    tmpTest     :  DINT;
  END_VAR

  // Übergabeparameter prüfen
  //-----------------------------------------------------------------------------------------
  if ((pEntry = NIL) | (pRoom = NIL)) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;

  tmpTest := 1989;  
  
  // Text besorgen
  pString := GetEventText(pEntry:=pEntry);

  if (tmpTest <> 1989) then
    TRACE_ERR("Achtung: Speicherschreiber am Stack");
    (0)$^DINT^ := 0;
  end_if;

  // Prüfen ob Text verfügbar ist
  if (pString = NIL) then
  
    // Infotext bauen, wenn kein Text verfügbar ist
    StrNCpy(p0 := #tmpText[0],  
            x1 := sizeof(_CHAR), 
            p2 := " TEXT IS NOT DEFINED IN LSE", 
            x3 := 1, // HubChr hardcoded source string is always ascii
            ml := sizeof(tmpText)/sizeof(_CHAR));

    pString := #tmpText[0];
      
  else
    // shift text in order to put a BLANK in front of the text  HubChr
    StrNCpy(p0 := #tmpText[1],  
            x1 := sizeof(_CHAR), 
            p2 := pString, 
            x3 := sizeof(_CHAR),
            ml := sizeof(tmpText)/sizeof(_CHAR));
    tmpText[0] := ' '; // put BLANK in first character

    pString := #tmpText[0];
  
  end_if; 
  
  // Text ausgeben
  OutTextAlign(p0 := pString, 
               x1 := 0,
               p1 := pRoom, 
               x2 := sFont, 
               x3 := EVENT_ATTRSTANDARD OR EVENT_ATTRTEXT, 
               x9 := _DEFFRAME, 
               x4 := sTextColor, 
               x5 := sBackColor, 
               x6 := sBackColor, 
               x7 := sizeof(pString^));

END_FUNCTION


FUNCTION EventJournal::WriteEventEntry
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful : BOOL;
	END_VAR
  VAR
  	tmpRoom    : _ROOM;
  END_VAR

  // Übergabeparameter prüfen
  if ((pEntry = NIL) | (pRoom = NIL)) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;  
  
  // Leere Zeile ausgeben mit den richtigen Farben falls zuwenig Spalten für die gesamte Breite definiert sind
  Graphic.Beam(x1:=pRoom^.xy1.x, y1:=pRoom^.xy1.y, x2:=pRoom^.xy2.x, y2:=pRoom^.xy2.y, attrib:=EVENT_ATTRSTANDARD  , color:= sBackColor);
  
  // Platz definieren
  tmpRoom.xy1.x := pRoom^.xy1.x;
  tmpRoom.xy1.y := pRoom^.xy1.y;
  tmpRoom.xy2.x := pRoom^.xy1.x;
  tmpRoom.xy2.y := pRoom^.xy2.y;
  
  
  // Eventzeit schreiben
  //------------------------------------------------------------
  // Prüfen ob Zeit dargestellt werden soll
  if (ColumnChoice AND 2#00001) then
    
    // Platz für Eventzeit bestimmen
    tmpRoom.xy1.x := tmpRoom.xy1.x;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(EventConfig.aColumnWidths[0]);
    
    // Eventzeit schreiben
    if (WriteEventTime(pEntry     := pEntry, 
                       pRoom      := #tmpRoom, 
                       sFont      := sFont, 
                       sTextColor := sTextColor, 
                       sBackColor := sBackColor) = false) then
      bSuccessful := false;
    end_if;
  end_if;

 
  // Parameter1
  //------------------------------------------------------------
  // Prüfen ob Parameter1 dargestellt werden soll
  if (ColumnChoice AND 2#00010) then
    
    // Platz für Parameter1 bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(EventConfig.aColumnWidths[1]);
    
    // Parameter1 ausgeben
    if (WriteParameter1(pEntry    := pEntry, 
                       pRoom      := #tmpRoom,
                       sFont      := sFont,
                       sTextColor := sTextColor, 
                       sBackColor := sBackColor) = false) then
      bSuccessful := false; 
    end_if;
  
  end_if;
 
 
  // Alarmnummer schreiben
  //------------------------------------------------------------
  // Prüfen ob Alarmnummer dargestellt werden soll
  if (ColumnChoice AND 2#00100) then
    
    // Platz für Alarmnummer bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(EventConfig.aColumnWidths[2]);

    // Alarmcode ausgeben
    if (WriteAlarmNo(pEntry     := pEntry, 
                     pRoom      := #tmpRoom, 
                     sFont      := sFont, 
                     sTextColor := sTextColor, 
                     sBackColor := sBackColor) = false) then
      bSuccessful := false;
    end_if;
  
  end_if;


  // Parameter2 schreiben
  //------------------------------------------------------------
  // Prüfen ob Parameter2 dargestellt werden soll
  if (ColumnChoice AND 2#01000) then
    
    // Platz für Parameter2 bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(EventConfig.aColumnWidths[3]);

    // Parameter2 ausgeben
    if (WriteParameter2(pEntry     := pEntry, 
                        pRoom      := #tmpRoom, 
                        sFont      := sFont, 
                        sTextColor := sTextColor, 
                        sBackColor := sBackColor) = false) then
      bSuccessful := false;
    end_if;
  
  end_if;


  // Eventtext
  //------------------------------------------------------------
  // Prüfen ob Eventtext dargestellt werden soll
  if (ColumnChoice AND 2#10000) then
    
    // Platz für Eventtext
    tmpRoom.xy1.x := tmpRoom.xy2.x + Event_TextOffset;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(EventConfig.aColumnWidths[4]);
    if (tmpRoom.xy2.x > (pRoom^.xy2.x)) then
      tmpRoom.xy2.x := pRoom^.xy2.x;
    end_if;
      
    // Eventtext ausgeben
    if (WriteEventText(pEntry     := pEntry, 
                       pRoom      := #tmpRoom, 
                       sFont      := sFont, 
                       sTextColor := sTextColor, 
                       sBackColor := sBackColor) = false) then
      bSuccessful := false; 
    end_if;
  
  end_if;

END_FUNCTION


FUNCTION EventJournal::CalcWidth
  
  // Breite der Zeile berechnen
  //--------------------------------------------------------------------------------------------
  
  // Konfiguration der Spalten lesen
  ColumnChoice := ColumnChoice.Read();
  
  LineWidth := 0;
  
  // Eventzeit
  if (ColumnChoice AND 2#00001) then
    LineWidth += EventConfig.aColumnWidths[0];
  end_if;

  // Parameter1
  if (ColumnChoice AND 2#00010) then
    LineWidth += EventConfig.aColumnWidths[1];
  end_if;
  
  // Alarmnummer
  if (ColumnChoice AND 2#00100) then
    LineWidth += EventConfig.aColumnWidths[2];
  end_if;
  
  // Parameter2
  if (ColumnChoice AND 2#01000) then
    LineWidth += EventConfig.aColumnWidths[3];
  end_if;
  
  // Beschreibung
  if (ColumnChoice AND 2#10000) then
    LineWidth += EventConfig.aColumnWidths[4];
  end_if;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL EventJournal::DisplayFilter::Write
	VAR_INPUT
		input (EAX) 	: EventJournal::T_BITS;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: EventJournal::T_BITS;
	END_VAR

  VAR
    mydat : UDINT; 
	  para  : UDINT; 
  END_VAR 


  mydat := DisplayFilter$UDINT; 
  para  := input$UDINT; 

  if(para and 16#80000000) then
    if(para = 16#80000000) then
	    mydat := mydat or 16#80000000; 
	  else   
      mydat := mydat or (para and 16#7FFFFFFF);  
    end_if; 
  else
    if(para = 0) then
      mydat := mydat and 16#7FFFFFFF; 
    else
	  mydat := mydat and (16#FFFFFFFF xor para); 
	  end_if; 
  end_if; 

  result        := mydat;
  DisplayFilter := mydat; 

END_FUNCTION


FUNCTION EventJournal::ChkEventDispFilter
	VAR_INPUT
		pEventEntry : ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		FilterOK 	: BOOL;
	END_VAR

  FilterOK := FALSE;
  
  if (pEventEntry <> NIL) then

    if ( ((pEventEntry^.entrytype = Event_SystemCat1)  & (DisplayFilter and 16#0001)) |
         ((pEventEntry^.entrytype = Event_SystemCat2)  & (DisplayFilter and 16#0002)) |
         ((pEventEntry^.entrytype = Event_SystemCat3)  & (DisplayFilter and 16#0004)) |
         ((pEventEntry^.entrytype = Event_SystemCat4)  & (DisplayFilter and 16#0008)) |
         ((pEventEntry^.entrytype = EVENT_ALARM)       & (DisplayFilter and 16#0010)) |
         
         ((pEventEntry^.entrytype = EVENT_SWITCHOFF)   & (DisplayFilter and 16#0020)) |
         ((pEventEntry^.entrytype = EVENT_SWITCHON)    & (DisplayFilter and 16#0020)) |

         ((pEventEntry^.entrytype = EVENT_USERLOGIN)   & (DisplayFilter and 16#0040)) |
         ((pEventEntry^.entrytype = EVENT_USERLOGOUT)  & (DisplayFilter and 16#0040)) |

         ((pEventEntry^.entrytype = EVENT_MENUCHANGE)  & (DisplayFilter and 16#0080)) |
         ((pEventEntry^.entrytype = EVENT_DATECHANGE)  & (DisplayFilter and 16#0080)) |
         ((pEventEntry^.entrytype = EVENT_VALUECHANGE) & (DisplayFilter and 16#0080)) |
         ((pEventEntry^.entrytype = EVENT_TIMECHANGE)  & (DisplayFilter and 16#0080)) |

         ((pEventEntry^.entrytype = EVENT_USEREVENT)   & (DisplayFilter and 16#0100)) |

         ((pEventEntry^.entrytype = EVENT_OPCHANGE)    & (DisplayFilter and 16#0200)) ) then
     
      FilterOK := TRUE;

    else

      FilterOK := FALSE;

    end_if;

  end_if;


END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL EventJournal::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
VAR
    doit : BOOL; 
	eat : BOOL;
END_VAR

  retcode := _IDLE; 

  if(Focus = TRUE) then
    eat := false; 
    if(pe^.ftype = _EVENT_KEYPRESS) then
      doit := FALSE; 
      case pe^.scancode of
        _UP   : if(Scroll.position.pos > 0) then
                  doit := TRUE; 
                end_if; 
        _DOWN : if(Scroll.position.pos < (Scroll.position.no - 1)) then
                  doit := TRUE; 
                end_if; 
        _RIGHT: if(Scroll.hlevel.active = TRUE) then
                  if(Scroll.hposition.pos < (Scroll.hposition.no - 1)) then
//                    Scroll.hposition.pos += (Scroll.out_room.xy2.x - Scroll.out_room.xy1.x) / 4; 
                    pe^.scancode := _PGRIGHT; 
                    doit := TRUE; 
                  end_if; 
                end_if; 
        _LEFT : if(Scroll.hlevel.active = TRUE) then
                  if(Scroll.hposition.pos > 0) then
//                    Scroll.hposition.pos -= (Scroll.out_room.xy2.x - Scroll.out_room.xy1.x) / 4; 
                    pe^.scancode := _PGLEFT; 
                    doit := TRUE; 
                  end_if; 
                end_if; 
        _PGLEFT, 
        _PGRIGHT, 
        _PGUP, 
        _PGDOWN : doit := TRUE; 
      end_case; 
    elsif(pe^.ftype = _EVENT_SHUTTLEDEC) then
      if(Scroll.position.pos > 0) then
        doit := TRUE; 
        eat  := TRUE;
      end_if; 
    elsif(pe^.ftype = _EVENT_SHUTTLEINC) then
      if(Scroll.position.pos < (Scroll.position.no - 1)) then
        doit := TRUE; 
        eat  := TRUE;
      end_if; 
    else
      doit := TRUE; 
      if((pe^.ftype = _EVENT_HIDMOVE)&(FocusJustGiven = TRUE)) then
        if((pe^.dot.x >= Scroll.out_room.xy1.x)&(pe^.dot.x <= Scroll.out_room.xy2.x)&
           (pe^.dot.y >= Scroll.out_room.xy1.y)&(pe^.dot.y <= Scroll.out_room.xy2.y)) then
          pe^.ftype := _EVENT_HIDPRESS; 
          eat       := TRUE; 
        end_if; 
      end_if;   
    end_if; 

    FocusJustGiven := FALSE; 

    if(doit = TRUE) then
    
      // --- HubChr 31.05.2016 we don't have a cursor so we don't want to scroll line by line -> set position to first or last visible entry upon scroll event
      if pe^.ftype = _EVENT_HIDPRESS & 
        ((pe^.dot.x >= Scroll.level.room.xy1.x) & (pe^.dot.x <= Scroll.level.room.xy2.x)) then // is the x-coord of the press event within the scrollbar?
        
        if((pe^.dot.y >= Scroll.level.room.xy1.y+(LEVELBUTTON_HEIGHT*Scroll.level.pguppgdown)) & (pe^.dot.y <= Scroll.level.room.xy1.y+LEVELBUTTON_HEIGHT+(LEVELBUTTON_HEIGHT*Scroll.level.pguppgdown))) then // upper scrollbutton
          Scroll.position.pos := scroll.position.begin;
        elsif
          ((pe^.dot.y >= Scroll.level.room.xy2.y-LEVELBUTTON_HEIGHT-(LEVELBUTTON_HEIGHT*Scroll.level.pguppgdown)) & (pe^.dot.y <= scroll.level.room.xy2.y-(LEVELBUTTON_HEIGHT*Scroll.level.pguppgdown))) then // lower scrollbutton
          Scroll.position.pos := Scroll.position.begin + Scroll.position.height-1;
        end_if;
      end_if;
      // --- End HubChr
    
      Run_SCROLL(#Scroll, pe);

      case(pe^.ftype) of
        _EVENT_KEYPRESS   : eat := TRUE; 
        _EVENT_HIDPRESS, 
        _EVENT_HIDMOVE, 
        _EVENT_HIDRELEASE : if((pe^.dot.x >= Scroll.out_room.xy1.x)&(pe^.dot.x <= Scroll.out_room.xy2.x)&
                               (pe^.dot.y >= Scroll.out_room.xy1.y)&(pe^.dot.y <= Scroll.out_room.xy2.y)) then
                              eat := TRUE; 
                            end_if;  

      end_case; 

      if(eat = TRUE) then
        init_EVENT(pe);     // eat event
        retcode := _IDIDIT;
      end_if; 
    end_if;
    
    ActPos := Scroll.position.pos;
  end_if; 


END_FUNCTION


FUNCTION EventJournal::SplitPath
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
VAR
	tmpLength : UDINT;
  tmpCounter : USINT;
  i : USINT;
END_VAR

  // ***************************************************************
  // Diese Methode teilt den String mit dem Ordnerpfad in Teile auf,
  // um danach die einzelnen Ordner erstellen zu können.
  // Zum Beispiel: "C:\Hugo\Sepp\Hans", wird aufgeteilt in:
  //    1. Ordnerpfad -> "C:\Hugo"
  //    2. Ordnerpfad -> "C:\Hugo\Sepp"
  //    3. Ordnerpfad -> "C:\Hugo\Sepp\Hans"
  // ***************************************************************
  
  retcode := 0;
  
  tmpCounter := 0;
  
  // Länge des Ordnerpfades holen
  tmpLength := coSigCLib.StrLen(str:=#aFilename[0]);
  
  if tmpLength <= 0 then
    retcode := -1;
    return;
  end_if;

  
  for i := 0 to tmpLength - 1 do
    
    // Schauen ob im Ordnerpfad ein "\" steht
    if aFilename[i] = '\' then
      
      if tmpCounter = 0 then
      
      elsif tmpCounter > 0 then
        
        // Speichern des Ordnerpfades in einer Struktur
        coSigCLib.StrNCpy(dst0:=#FolderPathList.FolderPaths[tmpCounter].FolderPath[0] , src0:=#aFilename[0], count:=i);   
        
      end_if;

      tmpCounter += 1;
      
      // Kontrollieren ob das Array groß genug ist
      if tmpCounter > (sizeof(FolderPathList.FolderPaths) / sizeof(FolderPathList.FolderPaths[1])) then
        
        retcode := -2;

        if (IsCon_coSystemLogging = TRUE) then
          coSystemLogging.LogEventText(pChar:="EventJournal::SplitPath(): Array für die Ordnerpfade ist zu klein!");
        end_if;        
        
        return;
      end_if;

    
    end_if;
    
    // Letztes Zeichen
    if i = (tmpLength -1) then
      
      // Letzten Ordnerpfad speichern (ist der einzige wenn nur ein Ordner im Pfad enthalten ist)
      if tmpCounter > 0 then
        coSigCLib.StrCpy(dst0:=#FolderPathList.FolderPaths[tmpCounter].FolderPath[0], src0:=#aFilename[0]);
        FolderPathList.uiFolderNr := tmpCounter;
      end_if;
    
    end_if;
  
  end_for;

END_FUNCTION


//*******************************************************************************************************************************
//  Add e new event for external use    V.1.2, KaiAnd
//*******************************************************************************************************************************
FUNCTION __CDECL VIRTUAL GLOBAL EventJournal::AddEntry
	VAR_INPUT
		ptr 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		retcode (AL) 	: BOOL;
	END_VAR
  VAR
	  NiGive	:	CmdStruct;
  	NiGet		:	Results;
    dDate   : DINT;
    dTime   : DINT;
    dValue  : DINT;
pText : ^_CHAR;
  END_VAR
 
  // share the new event
  if (IsClientConnected(#ccNewEvent)) then

    NiGive.uiCmd    := 11;            // Command
    NiGive.aPara[0] := (ptr)$DINT;    // pointer to original _SINGLEALARM

    // type of the event
    NiGive.aPara[1] := ptr^.entrytype;

    // Date and Time of the event
    GetEventTime(pEntry:=ptr, pRetdDate:=#dDate, pRetdTime:=#dTime);    
    NiGive.aPara[2] := dDate;
    NiGive.aPara[3] := dTime;

    // Parameter 1 of the event
    GetParameter1(pEntry:=ptr, pRetDINT:=#dValue);
    NiGive.aPara[4] := dValue;

    // Alarm-No of the Event
    GetAlarmNo(pEntry:=ptr, pRetDINT:=#dValue);
    NiGive.aPara[5] := dValue;

    // Parameter 2 of the event
    GetParameter2(pEntry:=ptr, pRetDINT:=#dValue);
    NiGive.aPara[6] := dValue;

    // Text of the event
pText  := GetEventText(pEntry:=ptr);
    NiGive.aPara[7] := (GetEventText(pEntry:=ptr))$DINT;
    
    ccNewEvent.NewInst(#NiGive, #NiGet);

  end_if;

  // call the base function
  retcode := _AlarmDisplay::AddEntry(ptr:=ptr);

END_FUNCTION
