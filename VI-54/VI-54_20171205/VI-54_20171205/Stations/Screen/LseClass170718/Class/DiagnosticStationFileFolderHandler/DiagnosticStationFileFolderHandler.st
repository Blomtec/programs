//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DiagnosticStationFileFolderHandler_MaxStationNr  10
#define DiagnosticStationFileFolderHandler_MaxNameLength  100
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "DiagnosticStationFileFolderHandler"
	Revision           = "1.1"
	GUID               = "{EF54AE02-0490-481B-B11F-908DE1492045}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(690,360)"
	Comment            = "This class handles the file and folder transfer, in case of a diagnostic export.">
	<Channels>
		<Server Name="sFunctionName" GUID="{038E6D5C-B070-4486-A7DB-35E9B2520763}" Class="StringInternal" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Name of the function."/>
		<Server Name="sStationName" GUID="{D8753DCA-2DB0-4F9A-B7FE-219022FCCAE7}" Class="StringInternal" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Name of the station."/>
		<Server Name="sStatus" GUID="{1C5B880D-206D-4344-993C-93CCE8587418}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual status."/>
		<Client Name="cDiagnostic" Required="true" Internal="false" Comment="Object channel to Diagnostic."/>
		<Client Name="cFileSys" Required="false" Internal="false" Comment="Object channel to _FileSys. Does not have to be connected."/>
		<Client Name="cFileTransfer" Required="true" Internal="false" Comment="Object channel to FileTransfer."/>
		<Client Name="cFolderTransfer" Required="true" Internal="false" Comment="Object channel to FolderTransfer."/>
		<Client Name="cSigCLib" Required="false" Internal="false" Comment="Object channel to SigCLib. Does not have to be connected."/>
		<Client Name="FunctionName" Required="true" Internal="true"/>
		<Client Name="StationName" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.1" Date="2016-06-14" Author="GreJoh" Company="Sigmatek" Description="Folder Transfer -&gt; if an error occured, the state of sStatus was set to ERROR before the folder transfer finished, and it started to get the next file or folder too early."/>
		<Dokumentation Revision="1.0" Date="2016-04-25" Author="GreJoh" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
	<Network Name="DiagnosticStationFileFolderHandler">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "FunctionName"
				GUID       = "{ACA20344-F8B9-46F5-83C7-7529A06D163C}"
				Class      = "String"
				Position   = "(180,300)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StationName"
				GUID       = "{E2E0C465-60EB-4C2D-B416-1AF230411C7A}"
				Class      = "String"
				Position   = "(180,480)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.FunctionName" Destination="FunctionName.Data"/>
			<Connection Source="this.StationName" Destination="StationName.Data"/>
			<Connection Source="this.sFunctionName" Destination="FunctionName.Data" Vertices="(908,270),(736,390),"/>
			<Connection Source="this.sStationName" Destination="StationName.Data" Vertices="(908,330),(736,570),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
DiagnosticStationFileFolderHandler : CLASS
	TYPE
#pragma pack(push, 1)
	  _Entry : STRUCT
	    Name : ARRAY [0..199] OF CHAR;
	    IsFile : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _FileFolderList : STRUCT
	    Nr : UDINT;
	    Entry : ARRAY [0..DiagnosticStationFileFolderHandler_MaxStationNr] OF _Entry;
	  END_STRUCT;
#pragma pack(pop)
	  _ssw_DSFFH :
	  (
	    _DSFFH_WaitForTrigger,
	    _DSFFH_CheckInstalledStation,
	    _DSFFH_CreateStationFolder,
	    _DSFFH_CheckNextStation,
	    _DSFFH_CallNextStation,
	    _DSFFH_WaitForResponse:=5
	  )$UDINT;
	END_TYPE
  //Servers:
	sStatus 	: SvrChCmd_iprStates;
	sFunctionName 	: SvrChCmd_UDINT;
	sStationName 	: SvrChCmd_UDINT;
  //Clients:
	cSigCLib 	: CltChCmd_SigCLib;
	cFileSys 	: CltChCmd__FileSys;
	cDiagnostic 	: CltChCmd_Diagnostic;
	cFileTransfer 	: CltChCmd_FileTransfer;
	cFolderTransfer 	: CltChCmd_FolderTransfer;
	FunctionName 	: CltChCmd_String;
	StationName 	: CltChCmd_String;
  //Variables:
		NameOfFunction 	: _DiagString;
		NameOfStation 	: _DiagString;
		FileFolderList 	: _FileFolderList;			//! <Variable Comment="List where every added file or folder has an entry." Name="FileFolderList"/>
		ssw 	: _ssw_DSFFH;
		ActualStationIndex 	: UDINT;
		DrivePathFunction 	: _DiagString;			//! <Variable Comment="Path, in which the files and folder get copied." Name="DrivePathFunction"/>
		SourceFileNE : ARRAY [0..199] OF CHAR;
			//! <Variable Comment="File name + ending." Name="SourceFileNE"/>
		SourceFileDP : ARRAY [0..199] OF CHAR;
			//! <Variable Comment="Path of the file which should be added." Name="SourceFileDP"/>
		oldErrorCode 	: FileTransferHandle::_FT_State;
		DestFolderDPNE : ARRAY [0..199] OF CHAR;
			//! <Variable Comment="Destination path and name of the added folder." Name="DestFolderDPNE"/>
		Fault 	: _DiagErrorCode;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="This method returns the actual state of the station." Name="GetWorkState"/>
	FUNCTION VIRTUAL GLOBAL GetWorkState
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Actual status." Name="GetWorkState.retcode"/>
		END_VAR;
				//! <Function Comment="Add a file or a folder which will be copied in case of a diagnostic export." Name="AddFileFolder"/>
	FUNCTION VIRTUAL GLOBAL AddFileFolder
		VAR_INPUT
			pDPNE 	: ^CHAR;			//! <Variable Comment="Pointer to the path of the file or folder." Name="AddFileFolder.pDPNE"/>
			IsFile 	: BOOL;			//! <Variable Comment="TRUE..Add a file.&#13;&#10;FALSE..Add a folder" Name="AddFileFolder.IsFile"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="-1..Max. number of added files or folder reached.&#13;&#10;1..Ok, file or folder added." Name="AddFileFolder.dRetcode"/>
		END_VAR;
				//! <Function Comment="Get the name of the function." Name="GetFunctionName"/>
	FUNCTION VIRTUAL GetFunctionName
		VAR_OUTPUT
			pName 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the function." Name="GetFunctionName.pName"/>
		END_VAR;
				//! <Function Comment="Call the method SetError from DiagnosticBase, with your error number and your error code." Name="SetError"/>
	FUNCTION GLOBAL SetError
		VAR_INPUT
			ErrorNr 	: DINT;			//! <Variable Comment="Error number." Name="SetError.ErrorNr"/>
			ErrorCode 	: DINT;			//! <Variable Comment="Error code." Name="SetError.ErrorCode"/>
		END_VAR;
				//! <Function Comment="Start with process to get added files or folder." Name="StartAction"/>
	FUNCTION VIRTUAL GLOBAL StartAction
		VAR_INPUT
			pDP 	: ^CHAR;			//! <Variable Comment="Path of the function. (for example: C:\Diagnostic\MyFunction)." Name="StartAction.pDP"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0..Error&#13;&#10;1..Ok" Name="StartAction.retcode"/>
		END_VAR;
				//! <Function Comment="This class builds the path and the file name + ending of the input string. (for example &quot;C:\MyFile.dat&quot; -&gt; path:&quot;C:\&quot;, filename: &quot;MyFile.dat&quot;)" Name="GetSourceDPNE"/>
	FUNCTION GetSourceDPNE
		VAR_INPUT
			pDPNE 	: ^CHAR;			//! <Variable Comment="Pointer to the string with the path and the file name." Name="GetSourceDPNE.pDPNE"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="1..OK&#13;&#10;-1..Error" Name="GetSourceDPNE.dRetcode"/>
		END_VAR;
				//! <Function Comment="This method builds the destination path for the folder transfer." Name="GetDestFolderDPNE"/>
	FUNCTION GetDestFolderDPNE;
				//! <Function Comment="Get the name of the station." Name="GetStationName"/>
	FUNCTION GetStationName
		VAR_OUTPUT
			pName 	: ^CHAR;			//! <Variable Comment="Pointer to the station name." Name="GetStationName.pName"/>
		END_VAR;
				//! <Function Comment="Call the method LogFunction from the DiagnosticBase class, to create an entry in the diagnostic-log file." Name="LogFunction"/>
	FUNCTION LogFunction
		VAR_INPUT
			bState 	: BOOL;			//! <Variable Comment="State of the function.&#13;&#10;TRUE..Function finished&#13;&#10;FALSE..Error" Name="LogFunction.bState"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _FileSys
#pragma usingLtd Diagnostic
#pragma usingLtd FileTransfer
#pragma usingLtd FolderTransfer
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DiagnosticStationFileFolderHandler::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_DIAGNOSTICSTATIONFILEFOLDERHANDLER
1$UINT, 1$UINT, (SIZEOF(::DiagnosticStationFileFolderHandler))$UINT, 
3$UINT, 7$UINT, 0$UINT, 
TO_UDINT(254991556), "DiagnosticStationFileFolderHandler", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DiagnosticStationFileFolderHandler.sStatus.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3043700589), "sStatus", 
(::DiagnosticStationFileFolderHandler.sFunctionName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1513072947), "sFunctionName", 
(::DiagnosticStationFileFolderHandler.sStationName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(4172946281), "sStationName", 
//Clients:
(::DiagnosticStationFileFolderHandler.cSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1539399991), "cSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 14$UINT, 
(::DiagnosticStationFileFolderHandler.cFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(194275965), "cFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
(::DiagnosticStationFileFolderHandler.cDiagnostic.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(910439362), "cDiagnostic", TO_UDINT(4058224054), "Diagnostic", 1$UINT, 0$UINT, 
(::DiagnosticStationFileFolderHandler.cFileTransfer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2395918110), "cFileTransfer", TO_UDINT(4196971158), "FileTransfer", 1$UINT, 2$UINT, 
(::DiagnosticStationFileFolderHandler.cFolderTransfer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3141091287), "cFolderTransfer", TO_UDINT(1725388019), "FolderTransfer", 1$UINT, 2$UINT, 
(::DiagnosticStationFileFolderHandler.FunctionName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2597220961), "FunctionName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::DiagnosticStationFileFolderHandler.StationName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2735596566), "StationName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_DiagnosticStationFileFolderHandler 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DiagnosticStationFileFolderHandler] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DiagnosticStationFileFolderHandler::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DiagnosticStationFileFolderHandler, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetWorkState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #AddFileFolder();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetFunctionName();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #StartAction();

#pragma warning (default : 74)
	sStatus.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF sStatus.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, sFunctionName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #sFunctionName::M_WR_DIRECT();
	sFunctionName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF sFunctionName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, sStationName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #sStationName::M_WR_DIRECT();
	sStationName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF sStationName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION GLOBAL PT_STARTACTION_FNC_DiagnosticStationFileFolderHandler
	VAR_INPUT
		pthis 	: ^void;
    pDP     : ^char;
	END_VAR
  var_output
    retcode : dint;
  end_var
  
  retcode := pthis$^DiagnosticStationFileFolderHandler^.StartAction(pDP);
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL DiagnosticStationFileFolderHandler::StartAction
	VAR_INPUT
		pDP 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := 0;
  if FileFolderList.Nr > 0 & ssw = _DSFFH_WaitForTrigger then
    retcode := 1;
    cSigCLib.StrCpy(dst0:=#DrivePathFunction[0], src0:=pDP);
    sStatus := BUSY;
    ssw := _DSFFH_CheckInstalledStation;
  end_if;


END_FUNCTION


FUNCTION GLOBAL PT_GETSTATE_FNC_DiagnosticStationFileFolderHandler
	VAR_INPUT
		pthis 	: ^void;
	END_VAR
  var_output
    retcode : iprStates;
  end_var

  retcode := pthis$^DiagnosticStationFileFolderHandler^.GetWorkState();
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiagnosticStationFileFolderHandler::GetWorkState
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR
  
  retcode := sStatus;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DiagnosticStationFileFolderHandler::Init


  if _FirstScan then
  
    // Login at the Diagnostic class, so it will be called when the export starts
    cDiagnostic.InstallFunction(pName:=GetFunctionName(), 
                                pThis:=this, 
                                pFct_StartAction:=#PT_STARTACTION_FNC_DiagnosticStationFileFolderHandler(), 
                                pFct_GetState:=#PT_GETSTATE_FNC_DiagnosticStationFileFolderHandler());
                                
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL DiagnosticStationFileFolderHandler::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	tmpLength : UDINT;
    tmpStr : ARRAY[0..199] OF CHAR;
    tmpRetcode : DINT;
    ErrorCode 	: FileTransferHandle::_FT_State;    
  END_VAR
 
 
  case ssw of
    
    // Wait for Trigger to start Export
    _DSFFH_WaitForTrigger:
    
    
    // Check if there are files or folder which we should get
    _DSFFH_CheckInstalledStation:
    
      Fault.ErrorNr := 0;
      Fault.ErrorCode := 0;
    
      if FileFolderList.Nr > 0 then
        ActualStationIndex := 0;
        ssw := _DSFFH_CreateStationFolder;
      else
        // Finished, no file or folder to get
        ssw := _DSFFH_WaitForTrigger;
        sStatus := READY;

      end_if;    
    
  
    // Create a folder where the files and folder which are registered will be copied into
    _DSFFH_CreateStationFolder: 
    
      tmpLength := StationName.GetLength();
      if tmpLength > 0 then
        StationName.ReadDataOff(udOff:=0, pData:=#tmpStr[0], udMax:=tmpLength+1);
        tmpStr[tmpLength] :=0;
        
        cSigCLib.StrCat(ps1:=#DrivePathFunction[0], ps2:=#tmpStr[0]);
        
        tmpRetcode := cFileSys.CreateDirectory(dirname:=#DrivePathFunction[0]);
        
        cSigCLib.StrCat(ps1:=#DrivePathFunction[0], ps2:="\");
        
        case tmpRetcode of
          RTF_NO_ERROR,
          RTF_FILE_EXISTS : 
          
            ssw := _DSFFH_CheckNextStation;
        
        else
          // Error
          sStatus := ERROR;
          ssw := _DSFFH_WaitForTrigger;
        end_case;

        
      else

        sStatus := ERROR;
        ssw := _DSFFH_WaitForTrigger;        

      end_if;  
    
    
    _DSFFH_CheckNextStation: // Check if we have finished, otherwise continue with the next file or folder
    
      if ActualStationIndex <= (FileFolderList.Nr-1) then
        ssw := _DSFFH_CallNextStation;
      else
        // Finished, all files and folder finished
        ssw := _DSFFH_WaitForTrigger;
        
        // Error 
        if Fault.ErrorCode <> 0 then
          LogFunction(bState:=FALSE);
          sStatus := ERROR;
        // No error
        else
          LogFunction(bState:=TRUE);
          sStatus := READY;        
        end_if;
      end_if;    
    
    
    _DSFFH_CallNextStation: // call of the file or folder transfer
    
        
      case FileFolderList.Entry[ActualStationIndex].IsFile of
        
        // Folder Transfer
        FALSE:
          
          // get the string for the destination path
          GetDestFolderDPNE();
          
          cSigCLib.StrCpy(dst0:=#tmpStr[0], src0:=#FileFolderList.Entry[ActualStationIndex].Name[0]);
          cSigCLib.StrCat(ps1:=#tmpStr[0], ps2:="\");

          // call method to start the folder transfer
          tmpRetcode := cFolderTransfer.GetFolder(pSourceDP:=#tmpStr[0], pDestDP:=#DestFolderDPNE[0]);

          if tmpRetcode = 1 then
            // folder transfer started
            ssw := _DSFFH_WaitForResponse;
          else
            Fault.ErrorNr := -2;
            Fault.ErrorCode := (to_dint(ActualStationIndex+1)*(-1));
            ActualStationIndex += 1;
            ssw := _DSFFH_CheckNextStation;               
          end_if;
        
        // File Transfer
        TRUE:
        
          // Get source path of the file, and the file name with the ending
          tmpRetcode := GetSourceDPNE(pDPNE:=#FileFolderList.Entry[ActualStationIndex].Name[0]);
        
          if tmpRetcode <> 1 then
            
            ActualStationIndex += 1;
            ssw := _DSFFH_CheckNextStation;       
          
          elsif tmpRetcode = 1 then
          
          
            // call method to start the file transfer
            tmpRetcode := cFileTransfer.GetFile(pSourceDP:=#SourceFileDP[0], pSourceNE:=#SourceFileNE[0], pDestinationDP:=#DrivePathFunction[0]);
        
            if tmpRetcode = 1 then
              // file transfer started
              ssw := _DSFFH_WaitForResponse;
            else
              Fault.ErrorNr := -2;
              Fault.ErrorCode := (to_dint(ActualStationIndex+1)*(-1));
              ActualStationIndex += 1;
              ssw := _DSFFH_CheckNextStation;               
            end_if;

        
          end_if;
        
      end_case;

    
    _DSFFH_WaitForResponse: // Check when function has finished

      case FileFolderList.Entry[ActualStationIndex].IsFile of
      
        // Folder transfer
        FALSE:
          
          // Get status of the folder transfer
          ErrorCode := cFolderTransfer.GetStateOfProcess();
          
          if ErrorCode = FileTransferHandle::FT_WaitForResponseGetFile then
            oldErrorCode := ErrorCode;
          end_if;

          // Error occured, continue with next file or folder
          if ErrorCode = FT_Error &
             cFolderTransfer.sSubState <> FileTransferHandle::FT_SUB_OperationReady &
             cFolderTransfer.sSubState <> FileTransferHandle::FT_SUB_NoAction then
             
            Fault.ErrorNr := -2;
            Fault.ErrorCode := (to_dint(ActualStationIndex+1)*(-1));
            ActualStationIndex += 1;
            ssw := _DSFFH_CheckNextStation;
          
          // Folder transfer completed, continue with next file or folder
          elsif ErrorCode = FileTransferHandle::FT_OperationReady & oldErrorCode = FileTransferHandle::FT_WaitForResponseGetFile then
            oldErrorCode := ErrorCode;
            ActualStationIndex += 1;
            ssw := _DSFFH_CheckNextStation;
          end_if; 
        
        // File transfer
        TRUE:
          
          // Get status of the file transfer
          ErrorCode := cFileTransfer.GetStateOfProcess();
          
          // Error occured, continue with next file or folder
          if ErrorCode = FT_Error then
            Fault.ErrorNr := -2;
            Fault.ErrorCode := (to_dint(ActualStationIndex+1)*(-1));
            ActualStationIndex += 1;
            ssw := _DSFFH_CheckNextStation;
           
          // File transfer completed, continue with next file or folder
          elsif ErrorCode = FileTransferHandle::FT_OperationReady then
            ActualStationIndex += 1;
            ssw := _DSFFH_CheckNextStation;
          end_if; 
      
      end_case;
  
  
  end_case;


	state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiagnosticStationFileFolderHandler::AddFileFolder
	VAR_INPUT
		pDPNE 	: ^CHAR;
		IsFile 	: BOOL;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  
  // max amount of files and folders reached
  dRetcode := -1; 
  
  if FileFolderList.Nr < DiagnosticStationFileFolderHandler_MaxStationNr then
    
    // Insert data to the list
    cSigCLib.StrNCpy(dst0:=#FileFolderList.Entry[FileFolderList.Nr].Name[0], src0:=pDPNE, count:=DiagnosticStationFileFolderHandler_MaxNameLength);
    FileFolderList.Entry[FileFolderList.Nr].IsFile := IsFile;
    // increment the amount of the added files or folder
    FileFolderList.Nr += 1;
    // File or folder successfully added
    dRetcode := 1;    
  
  else
    Fault.ErrorNr := -1;
    Fault.ErrorCode := -1;
    SetError(ErrorNr:=Fault.ErrorNr, ErrorCode:=Fault.ErrorCode);    
  end_if;
  

  
  
END_FUNCTION


FUNCTION VIRTUAL DiagnosticStationFileFolderHandler::GetFunctionName
	VAR_OUTPUT
		pName 	: ^CHAR;
	END_VAR
  

  FunctionName.ReadDataOff(udOff:=0, pData:=#NameOfFunction[0], udMax:=sizeof(NameOfFunction));
  pName := #NameOfFunction[0];

END_FUNCTION


FUNCTION GLOBAL DiagnosticStationFileFolderHandler::SetError
	VAR_INPUT
		ErrorNr 	: DINT;
		ErrorCode 	: DINT;
	END_VAR
  
  cDiagnostic.SetError(pFunctionName:=GetFunctionName(), GetStationName(), ErrorNr, ErrorCode);
  
END_FUNCTION



FUNCTION DiagnosticStationFileFolderHandler::GetSourceDPNE
	VAR_INPUT
		pDPNE 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  VAR
    tmpStr : ARRAY[0..199] of CHAR;
    tmpLength : UDINT;
    i : UDINT;
    udLastBackSlash : UDINT;
  END_VAR
  
  
  dRetcode := -1;
  
  cSigCLib.StrCpy(dst0:=#tmpStr[0], src0:=pDPNE);

  tmpLength := cSigCLib.StrLen(str:=#tmpStr[0]);
  
  // look where the last backslash is
  for i:=0 to tmpLength do
    
    if tmpStr[i] = '\' then
      udLastBackSlash := i;
      dRetcode := 1;
    end_if;
    
  end_for;  
  
  // the string after the last backslash is the name + ending of the file
  cSigCLib.StrCpy(dst0:=#SourceFileNE[0], src0:=#tmpStr[udLastBackSlash+1]);
  
  tmpStr[udLastBackSlash+1] := 0;
  
  // the string before the last backslash is the path of the file
  cSigCLib.StrCpy(dst0:=#SourceFileDP[0], src0:=#tmpStr[0]);


END_FUNCTION


FUNCTION DiagnosticStationFileFolderHandler::GetDestFolderDPNE
  VAR
    tmpStr : ARRAY[0..199] of CHAR;
    tmpLength : UDINT;
    i : UDINT;
    udLastBackSlash : UDINT;
  END_VAR
  
  cSigCLib.StrCpy(dst0:=#tmpStr[0], src0:=#FileFolderList.Entry[ActualStationIndex].Name[0]);

  tmpLength := cSigCLib.StrLen(str:=#tmpStr[0]);
  
  // look where the last backslash is
  for i:=0 to tmpLength do
    
    if tmpStr[i] = '\' then
      udLastBackSlash := i;
    end_if;
    
  end_for;
  
  cSigCLib.StrCpy(dst0:=#DestFolderDPNE[0], src0:=#DrivePathFunction[0]);
  // add the string after the last backslash. This will be the name of the folder
  cSigCLib.StrCat(ps1:=#DestFolderDPNE[0], ps2:=#tmpStr[udLastBackSlash+1]);
  
END_FUNCTION


FUNCTION DiagnosticStationFileFolderHandler::GetStationName
	VAR_OUTPUT
		pName 	: ^CHAR;
	END_VAR

  
  StationName.ReadDataOff(udOff:=0, pData:=#NameOfStation[0], udMax:=sizeof(NameOfStation));
  pName := #NameOfStation[0];
  
  
END_FUNCTION


FUNCTION DiagnosticStationFileFolderHandler::LogFunction
	VAR_INPUT
		bState 	: BOOL;
	END_VAR

  cDiagnostic.LogFunction(GetFunctionName(), GetStationName(), bState);

END_FUNCTION
