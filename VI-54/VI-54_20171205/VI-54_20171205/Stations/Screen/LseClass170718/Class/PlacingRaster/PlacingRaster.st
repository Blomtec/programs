//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "PlacingRaster"
	Revision           = "0.0"
	GUID               = "{E36271E5-94A9-4AF5-89B0-CAC1301610DA}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(600,300)">
	<Channels>
		<Server Name="BetweenButtons" GUID="{2650C0C3-1EE9-42FA-B658-6C974E095A8F}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="File"/>
		<Client Name="ActLayer" Required="true" Internal="false"/>
		<Client Name="NbrOfLayers" Required="false" Internal="false"/>
		<Client Name="NbrOfPositions" Required="false" Internal="false"/>
		<Client Name="ResetPositions" Required="true" Internal="false"/>
		<Client Name="ShootMovement" Required="false" Internal="false"/>
		<Client Name="ShuttleTrigger" Required="true" Internal="false"/>
		<Client Name="Standard2" Required="true" Internal="true"/>
		<Client Name="WindowEnd1" Required="true" Internal="true"/>
	</Channels>
	<Network Name="PlacingRaster">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{B28D6E6D-E2AB-45C0-96F8-EB001BFB3426}"
				Class      = "_MyIO"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="Graphic"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
			<Object
				Name           = "Standard2"
				GUID           = "{BEFACF57-AD76-49A9-B4DA-5D1B56E99FD7}"
				Class          = "Standard"
				Position       = "(210,330)"
				Visualized     = "false"
				BackgroundTime = "1000 ms">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "WindowEnd1"
				GUID       = "{43E2BE78-943A-4606-927A-B139991BBC6C}"
				Class      = "WindowEnd"
				Position   = "(210,480)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Server0">
						<OPCSettings WriteProtected="false"/>
					</Server>
					<Client Name="Lse"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(690,270),(518,270),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="this.Standard2" Destination="Standard2.ClassSvr"/>
			<Connection Source="this.WindowEnd1" Destination="WindowEnd1.Server0"/>
			<Connection Source="WindowEnd1.Lse" Destination="this.Lse" Vertices="(210,570),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _MyIO

PlacingRaster : CLASS
: _MyIO
	TYPE
#pragma pack(push, 1)
	  ButtonPtr : STRUCT
	    pRoom : _ROOM;
	    Attrib : _ATTRIB;
	    txt : ^void;
	    ColText : _COLOR;
	    ColBack : _COLOR;
	    ColFrame : _COLOR;
	    Font : _FONT;
	    FrameType : _FRAMETYPE;
	    CharSize : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  sSpace : STRUCT
	    XMin : _KOORD;
	    YMin : _KOORD;
	    XMax : _KOORD;
	    YMax : _KOORD;
	    ButtonWidth : _KOORD;
	    ButtonHeight : _KOORD;
	    TotalWidth : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	BetweenButtons 	: SvrCh_DINT;
  //Clients:
	NbrOfPositions 	: CltCh_DINT;
	NbrOfLayers 	: CltCh_DINT;
	ShootMovement 	: CltCh_DINT;
	Standard2 	: CltChCmd_Standard;
	WindowEnd1 	: CltChCmd_WindowEnd;
	ActLayer 	: CltCh_DINT;
	ResetPositions 	: CltCh_DINT;
	ShuttleTrigger 	: CltCh_DINT;
  //Variables:
		vActualScreen 	: _NEWSCREEN;
		vPio 	: ^_IO;
		pButton : ARRAY [0..30] OF ButtonPtr;

		vSpace 	: sSpace;
		vBackgroundColorTransparent 	: UDINT;
		vTextAttributes 	: UDINT;
		vTextColor 	: UDINT;
		EventPtr 	: ^_EVENT;
		Code 	: UINT;
		NumberOfButtons 	: DINT;
		Activate 	: DINT;
		Input1 	: ^_EVENT;
		PressedButton 	: DINT;
		OldX_Places 	: DINT;
		OldActivate 	: BOOL;
		WindowNbr 	: DINT;
		StringValue : ARRAY [0..10] OF CHAR;

  //Functions:
				//! <Function Comment="this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... &#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
	
	FUNCTION GLOBAL _PreCalculate
		VAR_INPUT
			iSpace 	: _ROOM;
		END_VAR;
	
	FUNCTION GLOBAL _DrawButton
		VAR_INPUT
			bButton 	: ^ButtonPtr;
		END_VAR;
	
	FUNCTION GLOBAL _Gettext
		VAR_INPUT
			LayerNbr 	: DINT;
			ptxt 	: ^pVoid;
		END_VAR;
	
	FUNCTION GLOBAL _DrawInterface
		VAR_INPUT
			iActivate 	: BOOL;
			Pio 	: ^_IO;
		END_VAR;
	
	FUNCTION _SetButtonDetails
		VAR_INPUT
			Pio 	: ^_IO;
		END_VAR;
	
	FUNCTION GLOBAL ButtonCollor;
	
	FUNCTION GLOBAL CheckLayer
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ResetValues;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Standard
#pragma using WindowEnd


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB PlacingRaster::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_PLACINGRASTER
0$UINT, 0$UINT, (SIZEOF(::PlacingRaster))$UINT, 
1$UINT, 8$UINT, 0$UINT, 
TO_UDINT(15051463), "PlacingRaster", //Class
TO_UDINT(2980745877), "_MyIO", 0$UINT, 3$UINT, //Baseclass
//Servers:
(::PlacingRaster.BetweenButtons.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2395094870), "BetweenButtons", 
//Clients:
(::PlacingRaster.NbrOfPositions.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4098379318), "NbrOfPositions", 
(::PlacingRaster.NbrOfLayers.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1501963807), "NbrOfLayers", 
(::PlacingRaster.ShootMovement.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3743984543), "ShootMovement", 
(::PlacingRaster.Standard2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(380985726), "Standard2", TO_UDINT(3603188683), "Standard", 6$UINT, 1$UINT, 
(::PlacingRaster.WindowEnd1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(555280434), "WindowEnd1", TO_UDINT(2742482723), "WindowEnd", 0$UINT, 0$UINT, 
(::PlacingRaster.ActLayer.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3074698408), "ActLayer", 
(::PlacingRaster.ResetPositions.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2670567441), "ResetPositions", 
(::PlacingRaster.ShuttleTrigger.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1350984300), "ShuttleTrigger", 
END_FUNCTION


#define USER_CNT_PlacingRaster 17

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_PlacingRaster] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION PlacingRaster::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _MyIO::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_PlacingRaster;
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BetweenButtons.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF BetweenButtons.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION __CDECL VIRTUAL GLOBAL PlacingRaster::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  
  if firsttime = True then
    OldActivate := False;
  end_if;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL PlacingRaster::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR
  
  NbrOfPositions := NbrOfPositions.Read();
  NbrOfLayers    := NbrOfLayers.Read();
  ShootMovement  := ShootMovement.Read();
  ActLayer       := ActLayer.Read();
  ResetPositions := ResetPositions.Read();
  ShuttleTrigger := ShuttleTrigger.Read();
  
  // Check for window end
  if WindowEnd1.Read_WindowEnd(Reset:= 0) = 1 then
    OldActivate := False;
    WindowEnd1.Read_WindowEnd(Reset:= 1);
  end_if;
  
  // Check if raster will be changed
  if (OldX_Places <> NbrOfPositions) then
    _PreCalculate(iSpace:= Pio^.space); 
    _SetButtonDetails(pio:= Pio);
    OldX_Places := NbrOfPositions;
    OldActivate := False;
  end_if;
  
  // Reset values
  if Standard2.R_TRIG(CLK:= ResetPositions) then
    ResetValues();
  end_if;
  
  // Change button collor
  if Standard2.R_TRIG(CLK:= ShuttleTrigger) then
    if CheckLayer() = true then
      ButtonCollor();
    end_if;
    OldActivate       := False;
  end_if;
    
  vPio := pio;
  
  push_screen(#vActualScreen);
  
  // _DrawInterface(iActivate:= True);
  _DrawInterface(iActivate:= True, Pio:= Pio);
  
  pop_screen(#vActualScreen);
  copy_screen(#vActualScreen, #pio^.space);

END_FUNCTION

FUNCTION GLOBAL PlacingRaster::_PreCalculate
	VAR_INPUT
		iSpace 	: _ROOM;
	END_VAR

  // Set space settings
  vSpace.XMin                 := iSpace.xy1.x;
  vSpace.YMin                 := iSpace.xy1.y;
  vSpace.XMax                 := iSpace.xy2.x;
  vSpace.YMax                 := iSpace.xy2.y;
  vSpace.TotalWidth           := (iSpace.xy2.x - iSpace.xy1.x);
  vSpace.ButtonHeight         := 100;
  
  // Set color settings
  vBackgroundColorTransparent := 16#FFFE SHL 16;
  vTextAttributes             := T_SOLID or T_PROP;
  vTextColor                  := LSE_COLOR256 SHL 16 OR DARKGRAY;

END_FUNCTION

FUNCTION PlacingRaster::_SetButtonDetails
	VAR_INPUT
		Pio 	: ^_IO;
	END_VAR
  VAR
    i, p, bKolum      : Dint;
    ExtraWidth        : int;
  END_VAR

  // Set values
  i      := 0;
  bKolum := 0;
  p      := 0;
  
  // Fill the button pointer..
  while i < NbrOfPositions do
    // Calculate extra width between the buttons (kolom width)
    ExtraWidth := to_int(BetweenButtons * (NbrOfPositions - 1));

    // Calculate button width
    if NbrOfPositions > 0 then
      vSpace.ButtonWidth := to_int((vSpace.TotalWidth - to_dint ExtraWidth) / NbrOfPositions); 
    end_if;

    // Set room into pointer
    pButton[i].pRoom.xy1.x := to_int(vSpace.XMin + (to_dint BetweenButtons * i) + (vSpace.ButtonWidth * i));
    pButton[i].pRoom.xy1.y := to_int(vSpace.YMin);
    pButton[i].pRoom.xy2.x := to_int(vSpace.XMin + (to_dint BetweenButtons * i) + vSpace.ButtonWidth + (vSpace.ButtonWidth * i));
    pButton[i].pRoom.xy2.y := to_int(vSpace.YMin + vSpace.ButtonHeight);
    // Set tekst into pointer
    pButton[i].txt := "0"; // Init value is '0'
    // _GetText(TxtID:= (i + 1), ptxt:= #pButton[i].txt);
    // Set colors into pointer
    pButton[i].ColText  := Black;
    pButton[i].ColBack  := Graphic.MakeColor(LIGHTGRAY, LIGHTGRAY);
    pButton[i].ColFrame := LIGHTBLUE;
    
    
    // Set font into pointer
    pButton[i].Font := Pio^.font;
    pButton[i].CharSize := 1;
    // Set attrib into pointer
    pButton[i].Attrib := T_COPY or T_SOLID or T_MIDBOUND or T_CENTERBOUND;
    // Set frame into pointer
    pButton[i].FrameType := 37;
            
    i += 1;
    p += 1;
    
  end_while;

END_FUNCTION

FUNCTION GLOBAL PlacingRaster::_DrawInterface
	VAR_INPUT
		iActivate 	: BOOL;
		Pio 	: ^_IO;
	END_VAR
  VAR
    xxx  : dint;
  END_VAR
  
  if iActivate <> OldActivate then  
    // Set background
    Graphic.Beam(x1:= vSpace.XMin, 
                 y1:= vSpace.YMin, 
                 x2:= vSpace.XMax, 
                 y2:= vSpace.YMax, 
                 attrib:= vPio^.attrib, 
                 color:= vPio^.colback);
    for xxx := 0 to (NbrOfPositions - 1) do 
      _DrawButton(bButton:= #pButton[xxx]);
    end_for;
    OldActivate := iActivate; 
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL PlacingRaster::_DrawButton
	VAR_INPUT
		bButton 	: ^ButtonPtr;
	END_VAR

  OutMultiTextAlign(bButton^.txt, 
                    0, 
                    #bButton^.pRoom, 
                    bButton^.Font, 
                    bButton^.Attrib, 
                    bButton^.FrameType, 
                    bButton^.ColText, 
                    bButton^.ColBack, 
                    bButton^.ColFrame, 
                    bButton^.CharSize);

END_FUNCTION

FUNCTION GLOBAL PlacingRaster::_Gettext
	VAR_INPUT
		LayerNbr 	: DINT;
		ptxt 	: ^pVoid;
	END_VAR
  
  ptxt^ := NIL; 
  
  case LayerNbr of
    01:
      pTxt^ := "1";
    02:
      pTxt^ := "2";
    03:
      pTxt^ := "3";
    04:
      pTxt^ := "4";
    05:
      pTxt^ := "5";
    06:
      pTxt^ := "6";
    07:
      pTxt^ := "7";
    08:
      pTxt^ := "8";
    09:
      pTxt^ := "9";
    10:
      pTxt^ := "10";
    11:
      pTxt^ := "11";
    12:
      pTxt^ := "12";
    13:
      pTxt^ := "13";
    14:
      pTxt^ := "14";
    15:
      pTxt^ := "15";
    16:
      pTxt^ := "16";
    17:
      pTxt^ := "17";
    18:
      pTxt^ := "18";
    19:
      pTxt^ := "19";
    20:
      pTxt^ := "20";
    21:
      pTxt^ := "21";
    22:
      pTxt^ := "22";
    23:
      pTxt^ := "23";
    24:
      pTxt^ := "24";
    25:
      pTxt^ := "25";
    26:
      pTxt^ := "26";
    27:
      pTxt^ := "27";
    28:
      pTxt^ := "28";
    29:
      pTxt^ := "29";
    30:
      pTxt^ := "30"; 
  end_case;

END_FUNCTION

FUNCTION GLOBAL PlacingRaster::ButtonCollor

  // Set button collors
  if ShootMovement > 0 then
    pButton[ShootMovement - 1].ColBack  := Graphic.MakeColor(Green, Green);
  end_if;

END_FUNCTION

FUNCTION GLOBAL PlacingRaster::CheckLayer
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := False; 
  
  if (ActLayer + 1) >= NbrOfLayers then
    Retcode := True;
  end_if;
  
  if ShootMovement > 0 then
    _Gettext(LayerNbr:= (ActLayer + 1), ptxt:= #pButton[ShootMovement - 1].txt);
  end_if;

END_FUNCTION

FUNCTION GLOBAL PlacingRaster::ResetValues
  VAR
  	i : Dint;
  END_VAR
  
  // Reset positions to '0'
  for i := 0 to NbrOfPositions do 
    pButton[i].txt := "0";
    pButton[i].ColBack  := Graphic.MakeColor(LIGHTGRAY, LIGHTGRAY);
  end_for;   
  
END_FUNCTION
