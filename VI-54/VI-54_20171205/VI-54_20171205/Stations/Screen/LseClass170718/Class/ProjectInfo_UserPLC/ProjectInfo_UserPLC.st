//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "ProjectInfo_UserPLC"
	Revision           = "1.1"
	GUID               = "{B469504F-73F5-4D65-9EEC-4DD83242FDF4}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(422,120)"
	Comment            = "This class is used to get the project information.">
	<Channels>
		<Client Name="ASCII_BIN" Required="true" Internal="true"/>
		<Client Name="cSigCLib" Required="false" Internal="false" Comment="Object channel to SigCLib. Does not have to be connected."/>
		<Client Name="cStdLib" Required="false" Internal="false" Comment="Object channel to _StdLib. Does not have to be connected."/>
		<Client Name="ocLinker" Required="false" Internal="false" Comment="Object channel to _Linker. Does not have to be connected."/>
		<Client Name="ocProjectName" Required="true" Internal="false" Comment="Connect this client to a string with the project name."/>
		<Client Name="SCL_GetClassVersion" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.1" Date="2016-06-15" Author="HasHan" Company="Sigmatek" Description="placed the SCLGetClassVersion Object into the complex class"/>
		<Dokumentation Revision="1.0" Date="2016-04-25" Author="GreJoh" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
	<Network Name="ProjectInfo_UserPLC">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{CBEE3422-7392-464F-BE0C-977EECD8C22B}"
				Class      = "DiagnosticUserFunction_PLC"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="sStatus"/>
				</Channels>
			</Object>
			<Object
				Name       = "ASCII_BIN"
				GUID       = "{E093BA51-C234-4214-BEE7-27F6CF65A0F4}"
				Class      = "ASCII_BIN"
				Position   = "(360,360)"
				Visualized = "false">
				<Channels>
					<Server Name="Obj_channel"/>
				</Channels>
			</Object>
			<Object
				Name       = "SCL_GetClassVersion"
				GUID       = "{00F73829-9D51-4FEA-A1D6-89C5E7012C42}"
				Class      = "SCL_GetClassVersion"
				Position   = "(870,360)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="cConvert" Value="0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.sStatus" Destination="_base.sStatus" Vertices="(1482,210),(774,210),"/>
			<Connection Source="this.ASCII_BIN" Destination="ASCII_BIN.Obj_channel"/>
			<Connection Source="this.SCL_GetClassVersion" Destination="SCL_GetClassVersion.ClassSvr"/>
			<Connection Source="SCL_GetClassVersion.cConvert" Destination="ASCII_BIN.Obj_channel" Vertices="(870,450),(754,450),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using DiagnosticUserFunction_PLC

ProjectInfo_UserPLC : CLASS
: DiagnosticUserFunction_PLC
  //Servers:
  //Clients:
	ocProjectName 	: CltChCmd_String;
	ocLinker 	: CltChCmd__Linker;
	cStdLib 	: CltChCmd__StdLib;
	cSigCLib 	: CltChCmd_SigCLib;
	SCL_GetClassVersion 	: CltChCmd_SCL_GetClassVersion;
	ASCII_BIN 	: CltChCmd_ASCII_BIN;
  //Variables:
		ssw_ProjectInfo 	: DINT;
		Fault 	: _DiagErrorCode;			//! <Variable Comment="Struct for error." Name="Fault"/>
		ProjectInfo_PLC 	: _Diag_ProjectInfo;			//! <Variable Comment="Struct with the project informations." Name="ProjectInfo_PLC"/>
		udLength 	: UDINT;
		dClassAmount 	: DINT;			//! <Variable Comment="Amount of all classes in the project." Name="dClassAmount"/>
		pData 	: ^SCL_GetClassVersion::_CR_OneEntry;
		udStrLen 	: UDINT;
  //Functions:
				//! <Function Comment="Is called when the diagnostic export starts." Name="StartWork"/>
	FUNCTION VIRTUAL GLOBAL StartWork
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Ready..Continue with the work methode&#13;&#10;Error..ssw is in a wrong step" Name="StartWork.retcode"/>
		END_VAR;
				//! <Function Comment="This method will be called cyclic when the diagnostic export is started. The project information data are get in this method." Name="WorkMethode"/>
	FUNCTION VIRTUAL GLOBAL WorkMethode;
				//! <Function Comment="Get the actual state of the function." Name="GetWorkState"/>
	FUNCTION VIRTUAL GLOBAL GetWorkState
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Actual state." Name="GetWorkState.retcode"/>
		END_VAR;
				//! <Function Comment="Method to get the actual error code." Name="GetErrorCode"/>
	FUNCTION VIRTUAL GLOBAL GetErrorCode
		VAR_OUTPUT
			retcode 	: _DiagErrorCode;			//! <Variable Comment="Error code." Name="GetErrorCode.retcode"/>
		END_VAR;
				//! <Function Comment="Method to get the size of the data which should be send." Name="GetDataSize"/>
	FUNCTION VIRTUAL GLOBAL GetDataSize
		VAR_OUTPUT
			retcode 	: UDINT;			//! <Variable Comment="Size of the data." Name="GetDataSize.retcode"/>
		END_VAR;
				//! <Function Comment="Method to get the pointer to the data of the user function." Name="GetDataPtr"/>
	FUNCTION VIRTUAL GLOBAL GetDataPtr
		VAR_OUTPUT
			dataPtr 	: ^void;			//! <Variable Comment="Pointer to the user data." Name="GetDataPtr.dataPtr"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using ASCII_BIN
#pragma using SCL_GetClassVersion
#pragma usingLtd _Linker
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib
#pragma usingLtd String


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ProjectInfo_UserPLC::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_PROJECTINFO_USERPLC
1$UINT, 1$UINT, (SIZEOF(::ProjectInfo_UserPLC))$UINT, 
0$UINT, 6$UINT, 0$UINT, 
TO_UDINT(3139337827), "ProjectInfo_UserPLC", //Class
TO_UDINT(4200646535), "DiagnosticUserFunction_PLC", 1$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::ProjectInfo_UserPLC.ocProjectName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3049519367), "ocProjectName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::ProjectInfo_UserPLC.ocLinker.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3261748820), "ocLinker", TO_UDINT(1793552568), "_Linker", 0$UINT, 4$UINT, 
(::ProjectInfo_UserPLC.cStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2073677046), "cStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::ProjectInfo_UserPLC.cSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1539399991), "cSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 14$UINT, 
(::ProjectInfo_UserPLC.SCL_GetClassVersion.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3283476102), "SCL_GetClassVersion", TO_UDINT(3283476102), "SCL_GetClassVersion", 1$UINT, 1$UINT, 
(::ProjectInfo_UserPLC.ASCII_BIN.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2897291062), "ASCII_BIN", TO_UDINT(2897291062), "ASCII_BIN", 1$UINT, 20$UINT, 
END_FUNCTION


#define USER_CNT_ProjectInfo_UserPLC 7

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ProjectInfo_UserPLC] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ProjectInfo_UserPLC::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= DiagnosticUserFunction_PLC::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DiagnosticUserFunction_PLC::sStatus.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DiagnosticUserFunction_PLC::sStatus.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_ProjectInfo_UserPLC;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #StartWork();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #WorkMethode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetWorkState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetErrorCode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetDataSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #GetDataPtr();

#pragma warning (default : 74)
	DiagnosticUserFunction_PLC::sStatus.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DiagnosticUserFunction_PLC::sStatus.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL ProjectInfo_UserPLC::WorkMethode
  VAR
    i : DINT;
    dSizeOfType : DINT;
    dArraySize : DINT;
    tmpPtr : ^SCL_GetClassVersion::_CR_OneEntry;
  END_VAR

    
  case ssw_ProjectInfo of
  
    // Idle
    //**********************************************************************
    0:
    
    
    // Get the data
    //**********************************************************************
    1: 

        // Get the project name
        udLength := ocProjectName.GetLength();
        ocProjectName.ReadDataOff(udOff:=0, pData:=#ProjectInfo_PLC.ProjectName[0], udMax:=udLength);
        
                
        // Get the Project CRC
        ProjectInfo_PLC.ProjectCRC := ocLinker.GetProjectChksum();
        
        // Get the amount of all classes in the project
        dClassAmount := SCL_GetClassVersion.GetNrOfEntries();
        
        // The amount must be bigger than 0, otherwise an error occured
        if dClassAmount <= 0 then
          Fault.ErrorNr := 1;
          Fault.ErrorCode := -1;
          ssw_ProjectInfo := 3;
          return;
        end_if;

        ProjectInfo_PLC.ClassAmount := dClassAmount;

        dSizeOfType := sizeof(SCL_GetClassVersion::_CR_OneEntry);
        
        // allocate memory for all classes in the project
        pData$pVoid := cStdLib.Malloc(size:=to_udint(dClassAmount*dSizeOfType));
        if pData = NIL then
          Fault.ErrorNr := 1;
          Fault.ErrorCode := -2;
          ssw_ProjectInfo := 3;
          return;
        else
          tmpPtr := pData;
        end_if;
       
        // call method to get all class names and revisions
        if SCL_GetClassVersion.GetAllClassesAndRevisions(pData:=tmpPtr) <= 0 then
          Fault.ErrorNr := 1;
          Fault.ErrorCode := -3;
          ssw_ProjectInfo := 3;
          return;
        end_if; 
        
        for i := 0 to dClassAmount-1 do
      
          udStrLen := cSigCLib.StrLen(str:=#tmpPtr^.ClassName[0]);
          dArraySize := sizeof(ProjectInfo_PLC.ClsVersCRC[i].ClsName);
          if udStrLen >= to_udint(dArraySize - 1) then
            // Insert "<" as last sign if the class name is longer than the array  
            cSigCLib.StrCpy(dst0:=#tmpPtr^.ClassName[dArraySize-1], src0:="<"); 
          end_if;
        
          // Copy data from the pointer to the struct
          cSigCLib.StrCpy(dst0:=#ProjectInfo_PLC.ClsVersCRC[i].ClsName[0], src0:=#tmpPtr^.ClassName[0]);
          cSigCLib.StrCpy(dst0:=#ProjectInfo_PLC.ClsVersCRC[i].ClsRevision[0], src0:=#tmpPtr^.RevisionTxt[0]);
          
          // call method to get the checksum of a class
          ProjectInfo_PLC.ClsVersCRC[i].ClsCRC := ocLinker.GetChkSumFromClassName(ClassName:=#tmpPtr^.ClassName[0]);
          
          // set pointer to the next entry
          tmpPtr += dSizeOfType;
          
        end_for;
        
        cStdLib.Free(mptr:=pData$pVoid);
        pData := NIL;
        
        ssw_ProjectInfo := 2;
        
      
    // Finished
    //**********************************************************************  
    2:
        sStatus := READY;
        ssw_ProjectInfo := 0;


    // Error
    //**********************************************************************
    3:
        sStatus := ERROR;
        ssw_ProjectInfo := 0;
    
  end_case;
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectInfo_UserPLC::GetDataSize
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  
    retcode := sizeof( ProjectInfo_PLC );    

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectInfo_UserPLC::GetDataPtr
	VAR_OUTPUT
		dataPtr 	: ^void;
	END_VAR
  
  dataPtr := #ProjectInfo_PLC;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectInfo_UserPLC::GetWorkState
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR
  
  retcode := sStatus;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectInfo_UserPLC::StartWork
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR
  
  if ssw_ProjectInfo = 0 then
    ssw_ProjectInfo := 1;
    retcode := Ready;
    sStatus:= BUSY;
  else
    retcode := ERROR;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectInfo_UserPLC::GetErrorCode
	VAR_OUTPUT
		retcode 	: _DiagErrorCode;
	END_VAR
  
  retcode := Fault;

END_FUNCTION
