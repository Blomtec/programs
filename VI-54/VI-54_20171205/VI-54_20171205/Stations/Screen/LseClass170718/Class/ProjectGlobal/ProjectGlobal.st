//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES


// Eigenschaften der Bildschirm-Informationen
//----------------------------------------------------------------------------------
#define Global_NumScreenInfos                            100                                 // Anzahl der reservierten Einträge für die Bildschirminformation

#define Global_MenueScreenNr                             10                                  // Bildschirm-Nummer des Menüs (Startseite)

#define Global_MenueMin                                  5                                   // Bildschirm-Nummer Alarme(*Ez0999*)

#define Global_MenueMax                                  4410                                // Bildschirm-Nummer Login Screens(*Ez0999*)



#define     CMD_GETIPOverStation      1000
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "ProjectGlobal"
	Revision           = "1.9"
	GUID               = "{32CE6A2A-4575-47CD-8859-2C4DBEC739BB}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,600)"
	Comment            = "project global issues">
	<Channels>
		<Server Name="ActScreen" GUID="{1342D1AE-314F-4B0F-B51F-58F3FCDB408E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="number of the active screen"/>
		<Server Name="ActWindow" GUID="{72DAFE04-32FA-4626-B614-883E53F3DA1F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="number of the active window"/>
		<Server Name="IP4Communication" GUID="{228006C1-E72C-430A-A718-0EACC137345C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Command Channel to get the ip address over station number"/>
		<Server Name="StationNumber" GUID="{1DD9F31D-E79E-4F89-80BB-C0797FA27AA2}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="station number for getting the IP-address"/>
		<Client Name="coEventQueue" Required="true" Internal="false" Comment="object channel to the EventQueue of the EventJournal"/>
		<Client Name="coSigCLib" Required="false" Internal="false" Comment="object channel to SigCLib (don&apos;t connect)"/>
		<Client Name="coSystemLogging" Required="false" Internal="false" Comment="object channel to SystemLogging (optional)"/>
		<Client Name="OffDate" Required="true" Internal="true"/>
		<Client Name="OffTime" Required="true" Internal="true"/>
		<Client Name="ProjectReady" Required="true" Internal="false" Comment="true = Visu started successful "/>
		<Client Name="SysDate" Required="true" Internal="false" Comment="system date"/>
		<Client Name="SysTime" Required="true" Internal="false" Comment="system time"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.9" Date="2016-07-12" Author="HasHan" Company="Sigmatek" Description="add ActWindow server"/>
		<Dokumentation Revision="1.8" Date="2016-05-19" Author="GreJoh" Company="Sigmatek" Description="Client coSystemLogging must not be connected."/>
		<Dokumentation Revision="1.7" Date="2016-02-22" Author="Roskri" Company="Sigmatek" Description="Removed uneccesary Methods, servers and clients for switching between screens."/>
		<Dokumentation Revision="1.6" Date="2015-09-29" Author="BraLis" Company="Sigmatek" Description="insert the method SystemLogging::LogEventText instead of TRACE-Messages"/>
		<Dokumentation Revision="1.5" Date="2015-09-22" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
	<Network Name="ProjectGlobal">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{FDF7FBF3-7B29-4010-BA5F-F7F4F7C2B928}"
				Class      = "_Global"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
			<Object
				Name       = "OffDate"
				GUID       = "{98FA88F6-930B-4CC6-8AE9-F02D5DB59415}"
				Class      = "Ram"
				Position   = "(390,480)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "OffTime"
				GUID       = "{174EEAFB-6D7C-4C2C-84EA-F68038040918}"
				Class      = "Ram"
				Position   = "(390,660)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(1148,210),(518,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="this.OffDate" Destination="OffDate.Data"/>
			<Connection Source="this.OffTime" Destination="OffTime.Data"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Global

ProjectGlobal : CLASS
: _Global
	TYPE
#pragma pack(push, 1)
	  t_s_ScreenInfo : STRUCT
	    uiScreenNr : UINT;
	    usLevel : USINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ActScreen 	: SvrCh_UDINT;
	ActWindow 	: SvrCh_UDINT;
	IP4Communication 	: SvrChCmd_DINT;
	StationNumber 	: SvrCh_DINT;
  //Clients:
	coSigCLib 	: CltChCmd_SigCLib;
	ProjectReady 	: CltCh_DINT;
	SysDate 	: CltCh_HDINT;
	SysTime 	: CltCh_HDINT;
	OffDate 	: CltChCmd_Ram;
	OffTime 	: CltChCmd_Ram;
	coEventQueue 	: CltChCmd_EventQueue;
	coSystemLogging 	: CltChCmd_SystemLogging;
  //Variables:
		bFirstInit 	: BOOL;
		uiStartPicture 	: UINT;
		bProjectReady 	: BOOL;
		dOldValue 	: DINT;
		dNewValue 	: DINT;
		udVarNo 	: UDINT;
		bLogValue 	: BOOL;
		pComPort 	: ^_COMPORT;
		pIP_Adress : ARRAY [0..16] OF CHAR;

		IPAdressValid 	: SINT;
		ProjectReadyVar 	: BOOL;
		udTimeStamp 	: UDINT;
		IsCon_coSystemLogging 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowStart
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			firsttime 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowRun
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="methode will be called after lse-project is successfully loaded and &#13;&#10;possibly given communication to extern plc is stable" Name="IF_ProjectReady"/>
	FUNCTION VIRTUAL GLOBAL IF_ProjectReady
		VAR_INPUT
			state 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_InputIsSaved
		VAR_INPUT
			pi 	: ^_INPUT;
			pr 	: ^_RESULT;
		END_VAR;
				//! <Function Comment="this method is called before a value is written into the system&#13;&#10;set return parameter with FALSE if you want to prohibit&#13;&#10;otherwise value will be written into system&#13;&#10;" Name="IF_Write"/>
	FUNCTION VIRTUAL GLOBAL IF_Write
		VAR_INPUT
			pres 	: ^_RESULT;
			pvar 	: ^_VARIABLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Delivers the screen number of the start screen as return value." Name="GetStartPicture"/>
	FUNCTION GLOBAL GetStartPicture
		VAR_OUTPUT
			uiStartPictureNr 	: UINT;			//! <Variable Comment="Number of the start screen" Name="GetStartPicture.uiStartPictureNr"/>
		END_VAR;
				//! <Function Comment="Get the IP-adress by the station number." Name="GetIpAdressOfStation"/>
	FUNCTION GLOBAL GetIpAdressOfStation
		VAR_INPUT
			pIpAdress 	: ^CHAR;			//! <Variable Comment="Pointer to a text with the IP-adress of the station" Name="GetIpAdressOfStation.pIpAdress"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SINT;			//! <Variable Comment="0.. Project loading hasn&apos;t finished&#13;&#10;-1.. No IP-adress set&#13;&#10;1.. Ok" Name="GetIpAdressOfStation.retcode"/>
		END_VAR;
				//! <Function Comment="Add an event for turning on the PLC to the event journal." Name="SwitchOn"/>
	FUNCTION SwitchOn
		VAR_INPUT
			hdTime 	: HDINT;			//! <Variable Comment="event time" Name="SwitchOn.hdTime"/>
			hdDate 	: HDINT;			//! <Variable Comment="event date" Name="SwitchOn.hdDate"/>
		END_VAR;
				//! <Function Comment="Add an event for turning off the plc to the event journal." Name="SwitchOff"/>
	FUNCTION SwitchOff
		VAR_INPUT
			hdTime 	: HDINT;			//! <Variable Comment="event time" Name="SwitchOff.hdTime"/>
			hdDate 	: HDINT;			//! <Variable Comment="event date" Name="SwitchOff.hdDate"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IP4Communication::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Ram
#pragma usingLtd EventQueue
#pragma usingLtd SigCLib
#pragma usingLtd SystemLogging


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ProjectGlobal::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_PROJECTGLOBAL
1$UINT, 9$UINT, (SIZEOF(::ProjectGlobal))$UINT, 
4$UINT, 8$UINT, 0$UINT, 
TO_UDINT(1462004836), "ProjectGlobal", //Class
TO_UDINT(3788417926), "_Global", 0$UINT, 14$UINT, //Baseclass
//Servers:
(::ProjectGlobal.ActScreen.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3239971925), "ActScreen", 
(::ProjectGlobal.ActWindow.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2511770808), "ActWindow", 
(::ProjectGlobal.IP4Communication.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4090129760), "IP4Communication", 
(::ProjectGlobal.StationNumber.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1650626075), "StationNumber", 
//Clients:
(::ProjectGlobal.coSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1750761597), "coSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 14$UINT, 
(::ProjectGlobal.ProjectReady.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3641930940), "ProjectReady", 
(::ProjectGlobal.SysDate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1714210210), "SysDate", 
(::ProjectGlobal.SysTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2737203869), "SysTime", 
(::ProjectGlobal.OffDate.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2631048100), "OffDate", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::ProjectGlobal.OffTime.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1507341467), "OffTime", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::ProjectGlobal.coEventQueue.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2896066780), "coEventQueue", TO_UDINT(915169004), "EventQueue", 1$UINT, 3$UINT, 
(::ProjectGlobal.coSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(292037947), "coSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_ProjectGlobal 44

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ProjectGlobal] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ProjectGlobal::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Global::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Global::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Global::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_ProjectGlobal;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #IF_WindowStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IF_WindowRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #IF_ProjectReady();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #IF_InputIsSaved();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #IF_Write();

#pragma warning (default : 74)
	_Global::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Global::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, IP4Communication.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.NewInstr		:= #IP4Communication::NewInst();
	IP4Communication.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF IP4Communication.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StationNumber.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF StationNumber.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::Init
  
  // Methode der Basis-Klasse
  _Global::Init();
  
  if _FirstScan then
    
    //-----------------------------------------------------------------------------------------
    //  check client-connnections and set flags                                                
    //-----------------------------------------------------------------------------------------
    if (IsClientConnected(#coSystemLogging)) then
      IsCon_coSystemLogging := TRUE;
    else
      IsCon_coSystemLogging := FALSE;
    end_if;    
    
  end_if;

  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_WindowStart
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
		firsttime 	: BOOL;
	END_VAR

  // Methode der Basis-Klasse
  _Global::IF_WindowStart(whoami, pic, firsttime);
  
  //--------------------------------------------------------------------------------------------------
  if bFirstInit = false then
    bFirstInit := true;
    uiStartPicture := to_uint(whoami^.no);
  end_if;
  
  
  //*****************************************************************************
  //** UNTERSCHEIDUNG DER KOMMANDOS                                            **
  //*****************************************************************************
  case whoami^.ima of
    
    // Screen
    //--------------------------------------------------------------------------------------------------
    IMA_PICTURE:
    
      // aktuelles Bildnummer darstellen
      ActScreen := whoami^.no;
      
    // Window
    //--------------------------------------------------------------------------------------------------
    IMA_WINDOW:
    
      // aktuelle Windownummer darstellen
      ActWindow := whoami^.no;
      
  end_case;
  
END_FUNCTION

FUNCTION GLOBAL ProjectGlobal::GetStartPicture
	VAR_OUTPUT
		uiStartPictureNr 	: UINT;
	END_VAR

  
  // Nr des Start-Bildschirms
  uiStartPictureNr := uiStartPicture;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_ProjectReady
	VAR_INPUT
		state 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmpDate : HDINT;
    tmpTime : HDINT;
  END_VAR

  // aktuelle Zeit lesen
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();
  
  // System wurde gerade gestartet
  //-------------------------------------------------------
  
    // Datum + Zeit vom Ausschalten lesen
    tmpDate := (OffDate.Data.Read())$HDINT;
    tmpTime := (OffTime.Data.Read())$HDINT;
    
    // Event für Ausschalten vom System
    SwitchOff(hdTime  := tmpTime, hdDate  := tmpDate);
    
    // Event für Einschalten vom System
    SwitchOn( hdTime  := SysTime, hdDate  := SysDate);
 
  ProjectReadyVar := TRUE;

  ProjectReady.Write(input:=1);
  
    // Visualisierung ist erfolgreich hochgefahren
  bProjectReady := true;
  
  IPAdressValid := GetIpAdressOfStation(#pIP_Adress[0]);
  
  // Rückgabewert setzen
  retcode := state;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_Write
	VAR_INPUT
		pres 	: ^_RESULT;
		pvar 	: ^_VARIABLE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmpResult     : _RESULT;
    tmpParameter  : UDINT;
  END_VAR

  // Rückgabewert setzen
  // => Wert darf immer geändert werden
  retcode := true;
  
  bLogValue := false;
  
  // Prüfen ob Projekt bereit hochgefahren ist
  if bProjectReady then
      
    // Einstellungen vom Parameter lesen
    tmpParameter := pvar^.info.statistic.parameter;
    
    // Prüfen, ob Logbuch für Parameter ausgewählt wurde
    if tmpParameter AND 2#10 then
    
      // Variablennummer speichern
      udVarNo := pvar^.no;
      
      // In Logbuch eintragen
      bLogValue := true;
      
      //*****************************************************************************
      //** UNTERSCHEIDUNG DER TYPEN                                                **
      //*****************************************************************************
      case pvar^.info.vartype of
        
        // Datum
        //*****************************************************************************
        FDATE:
        
          // Speichern des aktuellen Wertes
          dOldValue := pres^.value;
          
          // Speichern des neuen Wertes
          DATE_to_lasal(p0  := #dNewValue, 
                        p1  := #pres^.datim.fdate);
                        
        // Zeit
        //*****************************************************************************
        FTIME:
        
          // Speichern des aktuellen Wertes
          dOldValue := pres^.value;
          
          // Speichern des neuen Wertes
          TIME_to_lasal(p0  := #dNewValue, 
                        p1  := #pres^.datim.ftime);
        
        // String
        //*****************************************************************************
        FSTRING:
        
          if IsCon_coSystemLogging = TRUE then
            coSystemLogging.LogEventText("EventParamChange::IF_Write(): Änderung von Strings kann noch nicht mitgeloggt werden" );
          end_if;
          
        // der Rest
        //*****************************************************************************
        else
        
          // Speichern des aktuellen Wertes
          if get_dat( p0  := #tmpResult, 
                      x1  := udVarNo) = true then
            dOldValue := tmpResult.value;
          else
            dOldValue := 0;
            if IsCon_coSystemLogging = TRUE then
              coSystemLogging.LogEventText("EventParamChange::IF_Write(): Bestimmen des Wertes vor der Änderung fehlgeschlagen" );
            end_if;
          end_if;

          // Speichern des neuen Wertes
          dNewValue := pres^.value;
          
      end_case;
    
    end_if;
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_InputIsSaved
	VAR_INPUT
		pi 	: ^_INPUT;
		pr 	: ^_RESULT;
	END_VAR

   // Prüfen ob Projekt bereit hochgefahren ist
  if bProjectReady then
    
    // Soll die Wertänderung ins Logbuch geschrieben werden?
    if bLogValue = true then
    
      // Prüfen ob die Variablennummer noch gleich ist
      if pi^.io.variable.info[0].state = VAR_VAL &
         pi^.io.variable.info[0].value = udVarNo$DINT then
      
        // Info an EventJournal weitergeben
        case pi^.io.typ of
        
          // Datum
          //*****************************************************************************
          AS_DATE:
          
            // Auf Änderung prüfen
            if dOldValue <> dNewValue then
              
              // neues Event hinzufügen
              if coEventQueue.AddDateChange(udVarNo   := udVarNo, 
                                            dOldDate  := dOldValue, 
                                            dNewDate  := dNewValue) = false then
                
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("EventParamChange::IF_InputIsSaved(): Event für Änderung eines Datums konnte nicht hinzugefügt werden" );
                end_if;
              end_if;
            
            end_if;


          // Zeit
          //*****************************************************************************
          AS_TIME:
            
            // Auf Änderung prüfen
            if dOldValue <> dNewValue then
            
              // neues Event hinzufügen
              if coEventQueue.AddTimeChange(udVarNo   := udVarNo, 
                                            dOldTime  := dOldValue, 
                                            dNewTime  := dNewValue) = false then
                
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("EventParamChange::IF_InputIsSaved(): Event für Änderung einer Zeit konnte nicht hinzugefügt werden" );
                end_if;
              end_if;
              
            end_if;


          // String
          //*****************************************************************************
          AS_ASCII:
          
          
          // Menü
          //*****************************************************************************
          AS_MENU:
            
            // Auf Änderung prüfen
            if dOldValue <> dNewValue then
            
              // neues Event hinzufügen
              if coEventQueue.AddMenuChange(udVarNo     := udVarNo,
                                            udMenuIndex := pi^.io.info.tbo.no,
                                            dOldValue   := dOldValue, 
                                            dNewValue   := dNewValue) = false then
                
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("EventParamChange::IF_InputIsSaved(): Event für Änderung eines Menü-Eintrages konnte nicht hinzugefügt werden" );
                end_if;
              end_if;

            end_if;


          // der Rest
          //*****************************************************************************
          AS_NUMERIC:
            
            // Auf Änderung prüfen
            if dOldValue <> dNewValue then
            
              // neues Event hinzufügen
              if coEventQueue.AddValueChange( udVarNo   := udVarNo, 
                                              dOldValue := dOldValue, 
                                              dNewValue := dNewValue) = false then
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("EventParamChange::IF_InputIsSaved(): Event für Änderung eines Parameters konnte nicht hinzugefügt werden" );
                end_if;
              end_if;

            end_if;
          
          else
            if IsCon_coSystemLogging = TRUE then
              coSystemLogging.LogEventText("EventParamChange::IF_InputIsSaved(): Event für diese Änderung wird nicht unterstützt" );
            end_if;
        end_case;

      else
        if IsCon_coSystemLogging = TRUE then
          coSystemLogging.LogEventText("EventParamChange::IF_InputIsSaved(): Variablennummer hat sich geändert, zwischenzeitlich hat eine andere Änderung stattgefunden" );
        end_if;
      end_if;
    
    end_if;    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IP4Communication::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	len     : UDINT;
    NewInstUser   : BOOL;
  END_VAR

  NewInstUser := FALSE;  ret_code := READY;

  case pPara^.uiCmd of

    // --------------------------
    // Usercommand to get the IP adress
    CMD_GETIPOVERSTATION:
    
       if (IPAdressValid = 1) then
         len := coSigCLib.StrLen(str:=#pIP_Adress[0]);
         pResult^.uiLng := len$UINT;
         coSigCLib.MemCpy(#pResult^.aData[0], #pIP_Adress[0], len + 1); 
          ret_code := READY;

       elsif (IPAdressValid = -1) then
        ret_code := ERROR;
       else
        ret_code := BUSY;
       end_if;
       
       NewInstUser := TRUE;

  end_case;
  
  // If no user cmd is done, do the base newInst
  if (NewInstUser = FALSE) then
    ret_code := _Global::Server0.NewInst(pPara, pResult);
  end_if;


END_FUNCTION


FUNCTION GLOBAL ProjectGlobal::GetIpAdressOfStation
	VAR_INPUT
		pIpAdress 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: SINT;
	END_VAR
  VAR
    udIPAdress  :UDINT;
    tmpIP_ASCII  : ARRAY[0..16] of _ASCII;
  END_VAR
  
  retcode := 0;
  
  if (ProjectReadyVar = TRUE) then
    udIPAdress := 0;
    
    // get LSE Station
    pComPort := Get_COMPORT(StationNumber$UINT);  
      
    if (pComPort <> NIL) then
      udIPAdress := pComPort^.comdef.ipadress;
    
      // konvertieren der IP in string format
      DToA(p0:=#tmpIP_ASCII[0], x1:=(udIPAdress AND 0xFF)$DINT, x2:=0x800, x3:=sizeof(_ASCII));
      coSigCLib.StrCpy(dst0:=pIpAdress, src0:=#tmpIP_ASCII[0]);
      coSigCLib.StrCat(ps1:=pIpAdress, ps2:=".");
      // zweite stelle der IP adresse konvertieren    
      DToA(p0:=#tmpIP_ASCII[0], x1:=((udIPAdress shr 8) AND 0xFF)$DINT, x2:=0x800, x3:=sizeof(_ASCII));
      coSigCLib.StrCat(ps1:=pIpAdress, ps2:=#tmpIP_ASCII[0]);
      coSigCLib.StrCat(ps1:=pIpAdress, ps2:=".");
      // dritte stelle der IP adresse konvertieren    
      DToA(p0:=#tmpIP_ASCII[0], x1:=((udIPAdress shr 16) AND 0xFF)$DINT, x2:=0x800, x3:=sizeof(_ASCII));
      coSigCLib.StrCat(ps1:=pIpAdress, ps2:=#tmpIP_ASCII[0]);
      coSigCLib.StrCat(ps1:=pIpAdress, ps2:=".");
      // vierte stelle der IP adresse konvertieren    
      DToA(p0:=#tmpIP_ASCII[0], x1:=((udIPAdress shr 24) AND 0xFF)$DINT, x2:=0x800, x3:=sizeof(_ASCII));
      coSigCLib.StrCat(ps1:=pIpAdress, ps2:=#tmpIP_ASCII[0]);
      
      retcode := 1;
    
    else
    // no ip adress set
      retcode := -1;
    end_if;
  end_if;

END_FUNCTION


FUNCTION ProjectGlobal::SwitchOn
	VAR_INPUT
		hdTime 	: HDINT;
		hdDate 	: HDINT;
	END_VAR
  
  if coEventQueue.AddSystemOnOff(dDate := hdDate$DINT, 
                                  dTime := hdTime$DINT,
                                  bSwitchOnOff := true) = false then
    
    if IsCon_coSystemLogging = TRUE then
      coSystemLogging.LogEventText("EventSwitchOnOff::SwitchOn(): Hinzufügen vom Event fehlgeschalgen");
    end_if;
  end_if;

END_FUNCTION


FUNCTION ProjectGlobal::SwitchOff
	VAR_INPUT
		hdTime 	: HDINT;
		hdDate 	: HDINT;
	END_VAR
  
  if coEventQueue.AddSystemOnOff( dDate := hdDate$DINT, 
                                dTime := hdTime$DINT,
                                bSwitchOnOff := false) = false then
    
    if IsCon_coSystemLogging = TRUE then
      coSystemLogging.LogEventText("EventSwitchOnOff::SwitchOff(): Hinzufügen vom Event fehlgeschalgen");
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_WindowRun
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
		event 	: ^_EVENT;
	END_VAR
  
    if (ops.tAbsolute - udTimeStamp) > 5 SECS then
      
      udTimeStamp := ops.tAbsolute;
      // aktuelle Zeit lesen
      SysDate := SysDate.Read();
      SysTime := SysTime.Read();
      
      // aktuelle Zeit speichern
      OffDate.Data.Write(SysDate$DINT);
      OffTime.Data.Write(SysTime$DINT);
      
    end_if;
    

END_FUNCTION
