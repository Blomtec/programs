//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "FolderTransfer"
	Revision           = "1.2"
	GUID               = "{78732D02-A8E3-45BF-A09A-A846B7043E1F}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(510,240)"
	Comment            = "Die Klasse dient dem Austausch von Ordnern&#13;&#10;zwischen zwei CPUs bzw. Terminals.&#13;&#10;&#13;&#10;Kann verwendet werden um einen Ordner von&#13;&#10;einer 2ten CPU zu holen.&#13;&#10;&#13;&#10;Die Klasse alleine ist nicht funktionsfähig. Sie benötigt&#13;&#10;die Klasse FileTransfer um korrekt zu funktionieren.">
	<Channels>
		<Server Name="ClassSvr" GUID="{E98E9072-738A-42C6-B8DA-FA1315554265}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Objekt-Server der Klasse. Hier können die Globalen Methoden aufgerufen&#13;&#10;werden. ( GetFolder , GetStateOfProcess )"/>
		<Server Name="sState" GUID="{D1F36362-C59D-4067-B05F-D595AAC4878D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Status des letzten Kommandos ."/>
		<Server Name="sSubState" GUID="{E7618F42-8108-4596-B5A9-E0E7D5728549}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Genauere Aufschlüsselung des aktuell durchlaufenen Schritts"/>
		<Client Name="cFileSys" Required="false" Internal="false" Comment="Objekt Kanal auf die _FileSys Klasse. Braucht nicht verbunden werden."/>
		<Client Name="cFileTransfer" Required="true" Internal="false" Comment="Verbindung zur FileTransfer Klasse. &#13;&#10;Objekt Kanal : FileTransfer&#13;&#10;&#13;&#10;(über diesen Client werden die einzelnen Files und Ordner von der Gegenstelle&#13;&#10;geholt.)"/>
		<Client Name="cSigCLib" Required="false" Internal="false" Comment="Objekt Kanal auf die SigCLib Klasse. Braucht nicht verbunden werden."/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\FolderTransfer\FolderTransfer.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="hötant"/>
		<Dokumentation Revision="1.2" Date="2015-10-27" Author="hötant" Company="Sigmatek" Description="added Methode GetStateOfProcess , added documentation file"/>
		<Dokumentation Revision="1.1" Date="2015-10-21" Author="hötant" Company="Sigmatek" Description="added error handling and some improvements"/>
		<Dokumentation Revision="1.0" Date="2015-10-15" Author="hötant" Company="Sigmatek" Description="cration of class"/>
	</RevDoku>
</Class>
*)
FolderTransfer : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	sState 	: SvrCh__FT_State_PTofCls_FileTransferHandle;
	sSubState 	: SvrCh__FT_SubState_PTofCls_FileTransferHandle;
  //Clients:
	cFileTransfer 	: CltChCmd_FileTransfer;
	cSigCLib 	: CltChCmd_SigCLib;
	cFileSys 	: CltChCmd__FileSys;
  //Variables:
		SourceDP 	: FileTransferHandle::_FT_String;
		DestDP 	: FileTransferHandle::_FT_String;
		FolderContent 	: FileTransferHandle::_FT_FolderContent;
		WorkIndex 	: UDINT;
		ActEntrie 	: FileTransferHandle::_FT_FolderContentEntrie;
		CreateDirHandle 	: DINT;
		DirString 	: FileTransferHandle::_FT_String;
		ssw 	: FileTransferHandle::_FT_SubState;
  //Functions:
				//! <Function Comment="Nicht für den Benutzer.( Abarbeitung der Kommandos )" Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Wird verwendet, um einen Ordner von der Gegenstelle zu holen. &#13;&#10;Es werden alle Files und Ordner aus dem Source Ordner kopiert. &#13;&#10;( inklusive Unterordner )" Name="GetFolder"/>
	FUNCTION GLOBAL GetFolder
		VAR_INPUT
			pSourceDP 	: ^CHAR;			//! <Variable Comment="Laufwerk und Ordner ( z.B.: &quot;C:\Test\Hallo\&quot; )" Name="GetFolder.pSourceDP"/>
			pDestDP 	: ^CHAR;			//! <Variable Comment="Laufwerk und Ordnername , wohin der Inhalt des Source Ordners&#13;&#10;kopiert werden soll.( z.B.: &quot;E:\Export\&quot; ) &#13;&#10;Der Ordner muss bereits existieren." Name="GetFolder.pDestDP"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 .. Es läuft bereits eine andere Aktion&#13;&#10;1 .. Transfer wurde erfolgreich gestartet.&#13;&#10;-1 .. Einer der übergebenen Pointer ist NULL" Name="GetFolder.retcode"/>
		END_VAR;
	
	FUNCTION SeperatePath_FileName
		VAR_INPUT
			pContent 	: ^CHAR;
			pPath 	: ^CHAR;
			pFileName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION CheckStartOperation
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Wird verwendet, um den Status der letzten Aktion zu überprüfen." Name="GetStateOfProcess"/>
	FUNCTION GLOBAL GetStateOfProcess
		VAR_OUTPUT
			retcode 	: FileTransferHandle::_FT_State;			//! <Variable Comment="FT_NoAction .. aktuelle keine Aktive Aktion&#13;&#10;FT_OperationReady .. Aktion wurde ohne Fehler durchgeführt.&#13;&#10;FT_Error .. Es ist ein Fehler aufgetreten.&#13;&#10;&#13;&#10;Der Server sSubState gibt genauere Auskünfte über Fehler oder&#13;&#10;aktuelle Statusinformationen." Name="GetStateOfProcess.retcode"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd FileTransfer
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB FolderTransfer::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_FOLDERTRANSFER
1$UINT, 2$UINT, (SIZEOF(::FolderTransfer))$UINT, 
3$UINT, 3$UINT, 0$UINT, 
TO_UDINT(1725388019), "FolderTransfer", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::FolderTransfer.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::FolderTransfer.sState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2839362732), "sState", 
(::FolderTransfer.sSubState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3622246169), "sSubState", 
//Clients:
(::FolderTransfer.cFileTransfer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2395918110), "cFileTransfer", TO_UDINT(4196971158), "FileTransfer", 1$UINT, 2$UINT, 
(::FolderTransfer.cSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1539399991), "cSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 14$UINT, 
(::FolderTransfer.cFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(194275965), "cFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
END_FUNCTION


#define USER_CNT_FolderTransfer 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_FolderTransfer] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION FolderTransfer::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_FolderTransfer, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION GLOBAL FolderTransfer::GetFolder
	VAR_INPUT
		pSourceDP 	: ^CHAR;
		pDestDP 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  // Rückgabewert auf Error setzen
  retcode := 0;
  // Status übernehmen
  sState    := cFileTransfer.GetStateOfProcess();
  // Prüfen ob wir starten dürfen.
  if  (sState = FT_NoAction | sState = FT_OperationReady | sState = FT_Error ) & 
      CheckStartOperation() = TRUE then
    retcode := -1;
    // nur bei gültigen Pointern starten
    if (pSourceDP <> NIL) & (pDestDP <> NIL) then
      // Strings kopieren , damit sie im Background zur verfügung stehen.
      cSigCLib.StrCpy(dst0:=#SourceDP[0], src0:=pSourceDP);
      cFileTransfer.FileTransferHandle.PrepairPathAddBS(pPath:=#SourceDP[0]);
      cSigCLib.StrCpy(dst0:=#DestDP[0], src0:=pDestDP);
      cFileTransfer.FileTransferHandle.PrepairPathAddBS(pPath:=#DestDP[0]);
      // Start auslösen im Background
      ssw := FT_SUB_SendRequestFolderContent;
      // Erfolgreich gestartet.
      retcode := 1;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL FolderTransfer::GetStateOfProcess
	VAR_OUTPUT
		retcode 	: FileTransferHandle::_FT_State;
	END_VAR
  
    // aktuellen status zurückgeben.
    retcode := sState;    


END_FUNCTION

FUNCTION VIRTUAL GLOBAL FolderTransfer::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	FunktErg    : dint;                             
    DPSource    : FileTransferHandle::_FT_String;   
    DPDest      : FileTransferHandle::_FT_String;
    tPath       : FileTransferHandle::_FT_String;
    tFileName   : FileTransferHandle::_FT_String;
  END_VAR

  //******************************************************************************************************
  //************************   Abarbeitung des Ablaufs      **********************************************
  //******************************************************************************************************
  case ssw of
  
  //******************************************************************************************************
    FT_sub_NoAction : 
    
  //******************************************************************************************************
    FT_SUB_SendRequestFolderContent: 
      // Operation anstoßen. ( Folder Inhalt von PLC holen )
      if cFileTransfer.FileTransferHandle.GetContentList(pSourceDP:=#SourceDP[0]) = 1 then
        sState    := cFileTransfer.FileTransferHandle.sState;
        sSubState := cFileTransfer.FileTransferHandle.sSubState;
        ssw := FT_SUB_WaitFolderContent;
      else
        // es ist ein Fehler aufgetreten
        sState := FT_Error;
        sSubState := ssw := FT_SUB_Error_OtherProcessRunning;
      end_if;

  //******************************************************************************************************     
    FT_SUB_WaitFolderContent : 
      sState    := cFileTransfer.FileTransferHandle.sState;
      sSubState := cFileTransfer.FileTransferHandle.sSubState;
      // Warten bis Operation fertig ist.
      if cFileTransfer.FileTransferHandle.sState = FT_FolderContextReady then
        ssw := FT_SUB_GetFolderContent;
      // Überprüfen ob ein Fehler auftritt.  
      elsif cFileTransfer.FileTransferHandle.sState = FT_Error then
        // es ist ein Fehler aufgetreten
        sState := FT_Error;
        ssw := sSubState := cFileTransfer.FileTransferHandle.sSubState;
      end_if;
      
 //******************************************************************************************************       
    FT_SUB_GetFolderContent : 
      sState    := cFileTransfer.FileTransferHandle.sState;
      sSubState := cFileTransfer.FileTransferHandle.sSubState;
      // inhalt des Ornders übernehemen.
      if cFileTransfer.FileTransferHandle.GetRecivedContentList(pFolderContent:=#FolderContent) = TRUE then
        ssw := FT_SUB_CreateDir;
      end_if;

//******************************************************************************************************               
    FT_SUB_CreateDir : 
      sState    := FT_WorkOnRequestedFolder;
      sSubState := ssw;
      cSigCLib.StrCpy(dst0:=#DirString[0], src0:=#DestDP[0]);
      cFileTransfer.FileTransferHandle.PrepairPathDelBS(pPath:=#DirString[0]);
      // Root Folder erstellen.
      CreateDirHandle := cFileSys.CreateDirectory_A(Async:=1, dirname:=#DirString[0]); 
      ssw := FT_SUB_WaitCreateDir;

//******************************************************************************************************             
    FT_SUB_WaitCreateDir : 
      sState    := FT_WorkOnRequestedFolder;
      sSubState := ssw;
      // Warten bis Prozess abgeschlossen ist.
      if cFileSys.GetAsyncState(ID:=CreateDirHandle$udint, Erg:=#FunktErg) = 0 then
        // Ergebniss des Prozess auslesen.
        if FunktErg = 0 | FunktErg = -36 then  //-36 RTF_FILE_EXISTS
           // alles OK
           ssw := FT_SUB_CheckForFileOrFolder ;
           WorkIndex :=0;
        else
          // Fehler Create Directory
          sState := FT_Error;
          sSubState := ssw := FT_SUB_Error_CreateDir;
        end_if;
      end_if; 
        
//******************************************************************************************************               
    FT_SUB_CheckForFileOrFolder : 
      sState    := FT_WorkOnRequestedFolder;
      sSubState := ssw;
      // solange Einträge vorhanden sind , diese abarbeiten.
      if WorkIndex < FolderContent.Nr then
        // Aktuellen Eintrag auslesen.
        ActEntrie := FolderContent.Entrie[WorkIndex];
        // Prüfen was gemacht werden soll ( Folder oder File )
        case ActEntrie.Attrib of
          
          FT_Folder :  // Unterverzeichniss erstellen.
                       cSigCLib.StrCpy(dst0:=#DirString[0], src0:=#DestDP[0]);
                       cSigCLib.StrCat(ps1:=#DirString[0], ps2:=#ActEntrie.ContentString[0]);
                       cFileTransfer.FileTransferHandle.PrepairPathDelBS(pPath:=#DirString[0]);
                       CreateDirHandle := cFileSys.CreateDirectory_A(Async:=1, dirname:=#DirString[0]);
                       sSubState := FT_SUB_CreateDir;
                       ssw := FT_SUB_WaitCreateDirFolder;
          
          
          FT_File   :  // File von der PLC holen
                       ssw :=FT_SUB_GetFile;
          
        end_case;
      // Fertig.
      else
        ssw :=FT_SUB_OperationReady;
        sState    := FT_OperationReady;
        sSubState := ssw;
      end_if;
 
 //******************************************************************************************************
    FT_SUB_WaitCreateDirFolder : 
      sState    := FT_WorkOnRequestedFolder;
      sSubState := ssw;
      // Warten bis Prozess abgeschlossen ist.
      if cFileSys.GetAsyncState(ID:=CreateDirHandle$udint, Erg:=#FunktErg) = 0 then
        // Ergebniss des Prozess auslesen.
        if FunktErg = 0 | FunktErg = -36 then  //-36 RTF_FILE_EXISTS
           // alles OK
           ssw := FT_SUB_CheckForFileOrFolder;
           WorkIndex +=1;
        else
          // Fehler Create Directory
          sState := FT_Error;
          sSubState := ssw := FT_SUB_Error_CreateDir;
        end_if;
      end_if;

//******************************************************************************************************
    FT_SUB_GetFile : // File holen
      sState    := FT_WorkOnRequestedFolder;
      sSubState := ssw;
      // Pfad und Filenamen trennen.
      SeperatePath_FileName(pContent:=#ActEntrie.ContentString[0], pPath:=#tPath[0], pFileName:=#tFileName[0]);
      // Source und Destination Folder erstellen.
      cSigCLib.StrCpy(dst0:=#DPSource[0], src0:=#SourceDP[0]);
      cSigCLib.StrCat(ps1:=#DPSource[0], ps2:=#tPath[0] );
      cSigCLib.StrCpy(dst0:=#DPDest[0], src0:=#DestDP[0]);
      cSigCLib.StrCat(ps1:=#DPDest[0], ps2:=#tPath[0] );
      
      // File Transfer anstoßen.
      if cFileTransfer.FileTransferHandle.GetFile(pSourceDP:=#DPSource[0], pSourceNE:=#tFileName[0], pDestinationDP:=#DPDest[0]) = TRUE then
        // erfolgreich gestartet.
        ssw := FT_SUB_WaitGetFile;
      else
        // Fehler aufgetreten.
        sState := FT_Error;
        sSubState := ssw := FT_SUB_Error_GettingFile;
      end_if;

//******************************************************************************************************        
    FT_SUB_WaitGetFile :
      // Warten bis Operation fertig ist.
      if cFileTransfer.FileTransferHandle.sState = FT_OperationReady then
        ssw :=FT_SUB_CheckForFileOrFolder;
        sState    := FT_WorkOnRequestedFolder;
        sSubState := ssw;
        // Auf nächsten Eintrag weiterschalten.
        WorkIndex +=1;
      // Auf Fehler prüfen.
      elsif cFileTransfer.FileTransferHandle.sState = FT_Error then
        // Fehler aufgetreten , stop all.
        sState := FT_Error;
        sSubState := ssw := FT_SUB_Error_GetFileFromContent;
      else 
        // Status des Filetransfers übernehmen.
        sState    := cFileTransfer.FileTransferHandle.sState;
        sSubState := cFileTransfer.FileTransferHandle.sSubState;
      end_if;
        
  end_case;

	state := READY;

END_FUNCTION

FUNCTION FolderTransfer::SeperatePath_FileName
	VAR_INPUT
		pContent 	: ^CHAR;
		pPath 	: ^CHAR;
		pFileName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	ptrToSign : ^char;
    ptrStart  : ^char;
    tContent :  FileTransferHandle::_FT_String;
  END_VAR
  
  // Rückgabewert auf Error setzen
  retcode := FALSE;
  // Auf gültige Pointer prüfen.
  if pContent <> NIL & pPath <> NIL & pFileName <> NIL then
    // auf locale Variable umkopien.
    cSigCLib.StrCpy(dst0:=#tContent[0], src0:=pContent);
    // startPointer setzen ( auf den Anfang )
    ptrToSign := ptrStart := #tContent[0];  
    // solange suchen , bis das zeichen nicht mehr gefunden wird . ( wir suchen die Position des zu letzt gefundenen)
    while (ptrToSign <> NIL) do
      // Nach dem Zeichen suchen
      ptrToSign := cSigCLib.StrChr(ps1:=ptrStart, i:='\');
      // prüfen ob das Zeichen gefunden wurde.
      if ptrToSign <> NIL then
        // Startposition für nächste Suche setzen.
        ptrStart := ptrToSign +1;
      end_if;
    end_while;
    
    // letzte Position prüfen
    if ptrStart <> NIL then
      // Letzte Positon ist der Anfang des Filenamens
      cSigCLib.StrCpy(dst0:=pFileName, src0:=(ptrStart));
      // Filenamen wegschneiden.
      ptrStart^ :=0;
      // Pfad bleibt über und wird zurückgeliefert.
      cSigCLib.StrCpy(dst0:=pPath, src0:=#tContent[0]);
      // Erfolgreich getrennt.
      retcode := TRUE; 
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION FolderTransfer::CheckStartOperation
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
//*******************************************************************************************************
//*********************   je nach Status darf gestartet werden oder nicht *******************************
//*******************************************************************************************************
  case ssw of
  	FT_SUB_NoAction,        
  	FT_SUB_OperationReady,
  	FT_SUB_FindFirstFolder,
  	FT_SUB_Error_CreateDir,
  	FT_SUB_Error_CreateFile,
  	FT_SUB_Error_WriteFile,
  	FT_SUB_Error_CloseFile,
  	FT_SUB_Error_FindFile,
  	FT_SUB_Error_FileOpen,
  	FT_SUB_Error_FileLength,
  	FT_SUB_Error_AllocMemory,
  	FT_SUB_Error_ReadFile,
  	FT_SUB_ErrorJobID,
  	FT_SUB_ErrorCallback,
  	FT_SUB_Error_GettingFile,
  	FT_SUB_Error_OtherProcessRunning,
  	FT_SUB_Error_GetFolderContent,
  	FT_SUB_Error_GetFileFromContent,
  	FT_SUB_Error_GetFolder_EmptyFolder,
    FT_SUB_Error_GetFolder_ToMuchEntries: retcode := TRUE;
  else
    retcode := FALSE;
  end_case;

END_FUNCTION
