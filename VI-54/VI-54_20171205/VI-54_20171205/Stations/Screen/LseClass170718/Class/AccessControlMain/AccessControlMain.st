//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

// Einstellungen der Benutzerdaten
//-----------------------------------------------------------------------------------------
#define   AccessControl_InitDriveLetter               "C:\Users.cfg"                          // Standard Laufwerksbuchstabe, sofern die Benutzerdaten nicht exportiert werden sollen
#define   AccessControl_UserFile                      "Users.cfg"                             // Name der Datei für die Benutzerdaten
#define   AccessControl_DriveLetterLength             _strlen("C:\")                          // Länge des Strings für das aktuelle Laufwerk
#define   AccessControl_MaxUsernameLength             30                                      // Maximale Anzahl der Zeichen im Benutzernamen
#define   AccessControl_MaxPasswordLength             10                                       // Maximale Anzahl der Zeichen im Passwort
#define   AccessControl_MaxUserInfoLength             60                                      // Maximale Anzahl der Zeichen in der Information des Benutzers
#define   AccessControl_MaxUSBSNLength                20                                      // Maximale Anzahl der Zeichen in der USB-Seriennummer
#define   AccessControl_MaxUserFilePathLength         100                                     // Maximale Länge des Pfades der Datei für die Benutzerdaten
#define   AccessControl_NumUserBuffer                 20                                      // Anzahl der Benutzer, welche im Buffer platz haben


// Einstellungen für die Datei der Benutzerverwaltung
//-----------------------------------------------------------------------------------------
#define   AccessControl_Version                       1                                       // Version der Benutzerverwaltung
#define   AccessControl_HeaderLength                  40                                      // Größe des Headers in der Datei mit den Benutzern


// Einstellungen für die Visualisierung
//-----------------------------------------------------------------------------------------
#define   AccessControl_MessageWindowNr               10013                                   // Nummer des Fensters, welches die MSGNr als Text darstellt

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "AccessControlMain"
	Revision           = "2.17"
	GUID               = "{6B241EE9-8750-42E7-81BF-9A727EC68B8A}"
	RealtimeTask       = "false"
	DefRealtime        = "1 ms"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(542,120)"
	Comment            = "Main class for user administration and login">
	<Channels>
		<Server Name="ActLevel" GUID="{C0D98F71-E967-4D92-9668-AB876FF6A96B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="level of active user"/>
		<Server Name="ActUser" GUID="{B99296E3-B1EB-4EC8-A4B9-A31CC0E2BC55}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="name of active user"/>
		<Server Name="CopyUserFile" GUID="{6C9A0803-5BCB-482D-9C7E-84A4D98E7430}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="&gt; 0 ... command export userdata&#13;&#10;&lt; 0 ... command import userdata&#13;&#10;= 0 ... idle"/>
		<Server Name="EInfo" GUID="{2223AEF5-BF74-4CBD-B5FF-5C9C382D40EA}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Edit: user info"/>
		<Server Name="ELevel" GUID="{084F13C3-DF80-4A3D-875B-4D4BB6B3C807}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Edit: userlevel"/>
		<Server Name="EPassword" GUID="{69CBC706-A257-4F7E-9829-7F66DD358684}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Edit: new password"/>
		<Server Name="EPassword2" GUID="{80982B07-59FA-4CCD-949E-EACA52960132}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Edit: new password repeated"/>
		<Server Name="EPasswordOld" GUID="{547F6489-9C9A-40F6-B0DC-F0F77A558F53}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Edit: old password"/>
		<Server Name="ETimeOut" GUID="{7CE15E69-10D2-4D9D-AE87-8C3A0EF30C62}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Edit: Timout for auto logoff"/>
		<Server Name="EUsbSN" GUID="{CC998564-8B86-4397-A8CD-906EAC525E35}" Visualized="false" Initialize="true" WriteProtected="true" Retentive="false" Comment="UsbSerialNumber for management (use StringClass inside)"/>
		<Server Name="EUserName" GUID="{49EFE8EB-7C66-462D-9721-1A001FB3639B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Edit: User name (string class)"/>
		<Server Name="LoggedInWithUsb" GUID="{B40F27A3-15E4-4098-A792-C44F3404FB4D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="1 = user is logged in with USB stick"/>
		<Server Name="LPassword" GUID="{D733D475-2292-42E1-8B06-9337A659FFB5}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Login: password"/>
		<Server Name="LUserName" GUID="{81D81484-CCA8-4893-B2A5-00B3157542F6}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Login: username"/>
		<Server Name="MSGNr" GUID="{3D96A892-6ACA-4C4B-962F-EABFE1DC1C12}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="status of the user management (ENUMs, LSE textlist)"/>
		<Server Name="NextScreen" GUID="{A6E0361B-C02E-4F84-9948-31A9968F3CE0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="SelectFunction" GUID="{F33B61CD-8421-4FDF-AA18-5FADE4137AD0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Server with write-methode witch calls another methodes&#13;&#10;    1:  AddUser()&#13;&#10;    2:  DeleteUser()&#13;&#10;    3:  ModifyUser()&#13;&#10;    4:  Login()&#13;&#10;    5:  Logout()&#13;&#10;    6:  ShowUserData()&#13;&#10;    7:  ChangePassword()&#13;&#10;    8:  AddUsbSN()&#13;&#10;    9:  AddUsbSNbyUser()&#13;&#10;    10: DelUsbSN()&#13;&#10;    11: clearSevers()&#13;&#10;    12: closeScreen()&#13;&#10;"/>
		<Server Name="UserFile" GUID="{51793EDD-914C-4906-A9B1-3D19631C8E1E}" Class="String" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="path and name of file for userdata"/>
		<Server Name="UserIsLoggedIn" GUID="{F13DFF00-C2EA-471F-AFFE-21302A7FD5D5}" Visualized="true" Remotely="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="1 = user is logged in"/>
		<Client Name="AccessConfig" Required="true" Internal="false" Comment="Bit 0: 1 = ignore user-level for screen access"/>
		<Client Name="ActScreenNr" Required="true" Internal="false" Comment="screen-number of the active screen"/>
		<Client Name="coDriveLetter" Required="false" Internal="false" Comment="object channel to DriveLetter object"/>
		<Client Name="coEventQueue" Required="true" Internal="false" Comment="object channel to EventQueue object"/>
		<Client Name="coFileSys" Required="false" Internal="false" Comment="object channel to FileSys (don&apos;t connect!)"/>
		<Client Name="coGlobal" Required="true" Internal="false" Comment="object channel to ProjectGlobal object"/>
		<Client Name="coSystem" Required="false" Internal="false" Comment="object channel to System (don&apos;t connect!)"/>
		<Client Name="coSystemLogging" Required="false" Internal="false" Comment="Object channel to SystemLogging (optional)"/>
		<Client Name="Deactivate" Required="false" Internal="false" Comment="Use for debugging. If 1 the access-contol is not enabled. Everyone can access pages even if a access-level is defined&#13;&#10;"/>
		<Client Name="RefreshList" Required="true" Internal="false" Comment="command &quot;refresh list&quot; - connect to AccessControlList for usermanagement"/>
		<Client Name="StrActUser" Required="true" Internal="true"/>
		<Client Name="StrEditInfo" Required="true" Internal="true"/>
		<Client Name="StrEditPassword" Required="true" Internal="true"/>
		<Client Name="StrEditPassword2" Required="true" Internal="true"/>
		<Client Name="StrEditPasswordOld" Required="true" Internal="true"/>
		<Client Name="StrEditUsbSN" Required="true" Internal="true"/>
		<Client Name="StrEditUserName" Required="true" Internal="true"/>
		<Client Name="StrLoginPassword" Required="true" Internal="true"/>
		<Client Name="StrLoginUserName" Required="true" Internal="true"/>
		<Client Name="StrUserFile" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="2.18" Date="2017-01-31" Author="Marco Blom" Company="Sigmatek" Description="Changed act screen"/>
		<Dokumentation Revision="2.17" Date="2016-07-13" Author="Roskri" Company="Sigmatek" Description="Changed define for message window in lasal screen"/>
		<Dokumentation Revision="2.16" Date="2016-05-19" Author="GreJoh" Company="Sigmatek" Description="Client coSystemLogging must not be connected."/>
		<Dokumentation Revision="2.15" Date="2016-02-04" Author="Roskri" Company="Sigmatek" Description="IF a login-USB was already connected during CPU-start it will now be recognized"/>
		<Dokumentation Revision="2.14" Date="2015-11-12" Author="hötant" Company="Sigmatek" Description="corrected method NewStick ( wrong handling of first user , USB login did not work )"/>
		<Dokumentation Revision="2.13" Date="2015-11-09" Author="hötant" Company="Sigmatek" Description="corrected a fault in method Login , memory allocation is not nessasary"/>
		<Dokumentation Revision="2.12" Date="2015-10-30" Author="BraLis" Company="Sigmatek" Description="-replaced the define &quot;AccessControl_IgnoreScreenAccess&quot; by the client AccessConfig; if set 0, the accesslevel will be checked&#13;&#10;-corrected the methods AddUser, DeleteUser, CreateAdmin, SearchUserbyUsbSN, AddUsbSN and DelUsbSN because of Access Exception"/>
		<Dokumentation Revision="2.11" Date="2015-10-29" Author="BraLis" Company="Sigmatek" Description="corrected the methods SearchUser, DeleteUser, getUserToEdit, Login, AddUser, CreateAdmin and IF_WindowRun because the buffer UsersBuffer was written wrong&#13;&#10;"/>
		<Dokumentation Revision="2.10" Date="2015-10-27" Author="BraLis&#13;&#10;" Company="Sigmatek" Description="-Error in IF_WindowRun: check the file length and set pActUser^.pNext := NIL&#13;&#10;-add method CreateStandardUser() which is called in the Init()&#13;&#10;-add the variable StandardUser which serves as a buffer for the standard users&#13;&#10;-modified SearchUser() that also the buffer StandardUser will be checked"/>
		<Dokumentation Revision="2.9&#13;&#10;&#13;&#10;" Date="2015-10-27" Author="KruAle&#13;&#10;" Company="Sigmatek" Description="new define &quot;AccessControl_IgnoreScreenAccess&quot;. If set, the class does not check after login/logout if the access-level is valid.&#13;&#10;"/>
		<Dokumentation Revision="2.8" Date="2015-09-29" Author="BraLis" Company="Sigmatek" Description="insert the method SystemLogging::LogEventText instead of TRACE-Messages"/>
		<Dokumentation Revision="2.7" Date="2015-09-22" Company="Sigmatek" Description="Creation."/>
	</RevDoku>
	<Network Name="AccessControlMain">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{8005E018-7B4A-4188-9852-0A318F5B3C83}"
				Class      = "_Global"
				Position   = "(458,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrActUser"
				GUID       = "{1B803DCB-2376-45FB-B870-33B2941EB6E4}"
				Class      = "String"
				Position   = "(450,1500)"
				Visualized = "true">
				<Channels>
					<Server Name="Data" Value="&quot;C:\Users.cfg&quot;"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditInfo"
				GUID       = "{7AE4601E-7C0E-4B98-9FAE-154D0AC7622D}"
				Class      = "String"
				Position   = "(450,900)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditPassword"
				GUID       = "{6357ED1B-6D36-45F1-86E4-5BC76B2C562A}"
				Class      = "String"
				Position   = "(450,600)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditPassword2"
				GUID       = "{4AD4D94F-791D-499E-BC7A-D60EBDEE4ABA}"
				Class      = "String"
				Position   = "(450,750)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditPasswordOld"
				GUID       = "{6D0599E8-293F-4EB4-B2D3-4FA402CEFC05}"
				Class      = "String"
				Position   = "(450,450)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditUsbSN"
				GUID       = "{B42CFCF6-D3EB-4ED1-85B9-D31E0A6FF116}"
				Class      = "String"
				Position   = "(450,1050)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditUserName"
				GUID       = "{D89E4404-D5E5-4B0C-98BC-A886F3BF376D}"
				Class      = "String"
				Position   = "(450,300)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrLoginPassword"
				GUID       = "{B4830AE8-893B-488C-A2E6-89F745D42EC1}"
				Class      = "String"
				Position   = "(450,1350)"
				Visualized = "true">
				<Channels>
					<Server Name="Data" Value="0"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrLoginUserName"
				GUID       = "{54806AE7-2519-4475-9F81-BB64E7FBDBD8}"
				Class      = "String"
				Position   = "(450,1200)"
				Visualized = "true">
				<Channels>
					<Server Name="Data" Value="0"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrUserFile"
				GUID       = "{179FDEAC-8007-4279-BC94-5ACC0AF9E553}"
				Class      = "String"
				Position   = "(450,1650)"
				Visualized = "false">
				<Channels>
					<Server Name="Data" Value="&quot;C:\&quot;"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(1178,210),(758,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(458,210),(38,210),"/>
			<Connection Source="this.StrEditUserName" Destination="StrEditUserName.Data"/>
			<Connection Source="this.EUserName" Destination="StrEditUserName.Data" Vertices="(1178,390),(1006,390),"/>
			<Connection Source="this.StrEditPassword" Destination="StrEditPassword.Data"/>
			<Connection Source="this.EPassword" Destination="StrEditPassword.Data" Vertices="(1178,510),(1006,690),"/>
			<Connection Source="this.StrUserFile" Destination="StrUserFile.Data"/>
			<Connection Source="this.EPasswordOld" Destination="StrEditPasswordOld.Data" Vertices="(1178,450),(1006,540),"/>
			<Connection Source="this.StrActUser" Destination="StrActUser.Data"/>
			<Connection Source="this.LPassword" Destination="StrLoginPassword.Data" Vertices="(1178,930),(1006,1440),"/>
			<Connection Source="this.StrLoginUserName" Destination="StrLoginUserName.Data"/>
			<Connection Source="this.StrLoginPassword" Destination="StrLoginPassword.Data"/>
			<Connection Source="this.LUserName" Destination="StrLoginUserName.Data" Vertices="(1178,870),(1006,1290),"/>
			<Connection Source="this.UserFile" Destination="StrUserFile.Data" Vertices="(1178,1170),(1006,1740),"/>
			<Connection Source="this.StrEditUsbSN" Destination="StrEditUsbSN.Data"/>
			<Connection Source="this.EUsbSN" Destination="StrEditUsbSN.Data" Vertices="(1178,810),(1006,1140),"/>
			<Connection Source="this.StrEditPassword2" Destination="StrEditPassword2.Data"/>
			<Connection Source="this.EPassword2" Destination="StrEditPassword2.Data" Vertices="(1178,570),(1006,840),"/>
			<Connection Source="this.StrEditInfo" Destination="StrEditInfo.Data"/>
			<Connection Source="this.EInfo" Destination="StrEditInfo.Data" Vertices="(1178,750),(1006,990),"/>
			<Connection Source="this.ActUser" Destination="StrActUser.Data" Vertices="(1178,990),(1006,1590),"/>
			<Connection Source="this.StrEditPasswordOld" Destination="StrEditPasswordOld.Data"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Global

AccessControlMain : CLASS
: _Global
	TYPE
	  t_a_USB_Serial : ARRAY [0..AccessControl_MaxUSBSNLength] OF CHAR;
	  t_e_MsgNumbers :
	  (
	    MSG_NO_ERR,
	    MSG_LOGIN_OK,
	    MSG_LOGOUT_OK,
	    MSG_ADDUSER_OK,
	    MSG_EDITUSER_OK,
	    MSG_DELUSER_OK,
	    MSG_PWCHANGE_OK,
	    MSG_EXPORT_USERS_OK,
	    MSG_IMPORT_USERS_OK,
	    MSG_USB_SERNUM,
	    ERR_USER_EXISTS,
	    ERR_USER_NOTEXIST,
	    ERR_NO_NAME,
	    ERR_NO_PASS,
	    ERR_WRONG_PASS,
	    ERR_WRONG_PWCHANGE,
	    ERR_USERS_FILE,
	    ERR_ADDUSER:=17,
	    ERR_MEMORY:=18,
	    ERR_EDITUSER,
	    ERR_DELUSER,
	    ERR_NO_DRIVE,
	    ERR_COPYUSERS,
	    ERR_USB_SERNUM,
	    ERR_NO_SCREEN_ACCESS,
	    ERR_WRONG_PWOLD,
	    ERR_DEL_USB_SERNUM,
	    ERR_AUTHORITY_EDITUSER,
	    ERR_AUTHORITY_LEVEL,
	    ERR_EDIT_OWNLEVEL,
	    ERR_AUTHLEVEL_LOW:=30
	  )$UDINT;
	  t_e_RetCheckservers :
	  (
	    NAME_PASS_1,
	    NAME_1,
	    PASS_1,
	    NAME_PASS_ERR,
	    NAME_0,
	    PASS_0
	  )$UDINT;
	  t_e_UserFile :
	  (
	    AccessControl_IDLE,
	    AccessControl_FILEOPEN,
	    AccessControl_WAIT4FILEOPEN,
	    AccessControl_FILELENGTH,
	    AccessControl_WAIT4FILELENGTH,
	    AccessControl_FILETELL,
	    AccessControl_WAIT4FILETELL,
	    AccessControl_READHEADER,
	    AccessControl_WAIT4READHEADER,
	    AccessControl_FILEREAD,
	    AccessControl_WAIT4FILEREAD,
	    AccessControl_FILEREFRESH,
	    AccessControl_WAIT4FILEREFRESH,
	    AccessControl_WRITEHEADER,
	    AccessControl_WAIT4WRITEHEADER,
	    AccessControl_FILLBUFFER,
	    AccessControl_FILEWRITE,
	    AccessControl_WAIT4FILEWRITE,
	    AccessControl_FILECLOSE,
	    AccessControl_WAIT4FILECLOSE
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_User : STRUCT  //! <Type Public="true" Name="t_s_User"/>
	    aUsername : ARRAY [0..AccessControl_MaxUsernameLength] OF CHAR;
	    aUserPassword : ARRAY [0..AccessControl_MaxPasswordLength] OF CHAR;
	    usUserLevel : USINT;
	    udUserTimeout : UDINT;
	    aUserInfo : ARRAY [0..AccessControl_MaxUserInfoLength] OF CHAR;
	    USBSerial : t_a_USB_Serial;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_UserHeader : STRUCT
	    udVersion : UDINT;
	    udUserStructSize : UDINT;
	    udNumUser : UDINT;
	    aNotDefined : ARRAY [0..6] OF DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_VKAccessLists : STRUCT
	    AccessList : ^AccessControlList;
	    pNext : ^t_s_VKAccessLists;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_VKUser : STRUCT
	    User : t_s_User;
	    pNext : ^t_s_VKUser;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	SelectFunction 	: SvrCh_DINT;
	NextScreen 	: SvrCh_DINT;
	EUserName 	: SvrCh_UDINT;
	EPasswordOld 	: SvrCh_UDINT;
	EPassword 	: SvrCh_UDINT;
	EPassword2 	: SvrCh_UDINT;
	ELevel 	: SvrCh_DINT;
	ETimeOut 	: SvrCh_UDINT;
	EInfo 	: SvrCh_UDINT;
	EUsbSN 	: SvrCh_UDINT;
	LUserName 	: SvrCh_UDINT;
	LPassword 	: SvrCh_UDINT;
	ActUser 	: SvrCh_UDINT;
	ActLevel 	: SvrCh_DINT;
	MSGNr 	: SvrCh_DINT;
	UserFile 	: SvrChCmd_UDINT;
	CopyUserFile 	: SvrCh_DINT;
	UserIsLoggedIn 	: SvrCh_DINT;
	LoggedInWithUsb 	: SvrCh_DINT;
  //Clients:
	Deactivate 	: CltCh_DINT;
	coDriveLetter 	: CltChCmd_String;
	coFileSys 	: CltChCmd__FileSys;
	coSystem 	: CltChCmd_System;
	StrActUser 	: CltChCmd_String;
	StrEditUserName 	: CltChCmd_String;
	StrEditPassword 	: CltChCmd_String;
	StrEditPassword2 	: CltChCmd_String;
	StrEditUsbSN 	: CltChCmd_String;
	StrLoginUserName 	: CltChCmd_String;
	StrLoginPassword 	: CltChCmd_String;
	StrEditInfo 	: CltChCmd_String;
	StrUserFile 	: CltChCmd_String;
	coEventQueue 	: CltChCmd_EventQueue;
	ActScreenNr 	: CltCh_UDINT;
	coGlobal 	: CltChCmd_ProjectGlobal;
	RefreshList 	: CltCh_DINT;
	StrEditPasswordOld 	: CltChCmd_String;
	coSystemLogging 	: CltChCmd_SystemLogging;
	AccessConfig 	: CltCh_BDINT;
  //Variables:
		ActUserBuffer 	: t_s_User;
		aUserFilePath : ARRAY [0..AccessControl_MaxUserFilePathLength] OF CHAR;

		dAsyncID 	: DINT;
		dAsyncState 	: DINT;
		dErrorCode 	: DINT;
		dFileHandle 	: DINT;
		dFileLength 	: DINT;
		dFileRead 	: DINT;
		dFileTell 	: DINT;
		dFileWrite 	: DINT;
		eUserFileState 	: t_e_UserFile;
		pAccessListsBuffer 	: ^t_s_VKAccessLists;
		pActUser 	: ^t_s_VKUser;
		pBefore 	: ^t_s_VKUser;
		udNumberOfUsers 	: UDINT;
		udTimeout 	: UDINT;			//! <Variable Comment="Zeit des Logins des aktuellen Benutzers.&#13;&#10;" Name="udTimeout"/>
		UsersBuffer 	: ^t_s_VKUser;
		bCloseScreen 	: BOOL;			//! <Variable Comment="Diese Variable gibt an, ob der Benutzer nach einem Logout noch die nötige Zugriffsberechtigung auf diesen Screen hat.&#13;&#10;False .. Zugriff erlaubt&#13;&#10;True  .. Screen wird gewechselt" Name="bCloseScreen"/>
		bLogoutOldUser 	: BOOL;			//! <Variable Comment="False .. default&#13;&#10;True  .. Aktuell eingeloggter Benutzer wird ausgeloggt, da sich ein neuer per USB-Stick anmeldet." Name="bLogoutOldUser"/>
		udAddedUserDataSize 	: UDINT;			//! <Variable Comment="Aktuelle Größe der zu schreibenden Benutzerdaten im Puffer." Name="udAddedUserDataSize"/>
		pUserBuffer 	: ^t_s_User;			//! <Variable Comment="Puffer zum Schreiben der Benutzerdaten." Name="pUserBuffer"/>
		udUserBufferSize 	: UDINT;			//! <Variable Comment="Größe des Puffers zum Schreiben der Benutzerdaten." Name="udUserBufferSize"/>
		pWriteUserBuffer 	: ^t_s_User;			//! <Variable Comment="Schreibe-Zeiger auf den Puffer zum Schreiben der Benutzerdaten." Name="pWriteUserBuffer"/>
		Header 	: t_s_UserHeader;
		StandardUser 	: ^t_s_VKUser;
		bdAccessConfig : BDINT
		[
		  1 IgnoreScreenAccess,
		];

		bNewStickAtStart 	: BOOL;			//! <Variable Comment="TRUE if a USB-stick was already&#13;&#10;inserted at CPU-start but Memory for&#13;&#10;UsersBuffer was not yet allocated.&#13;&#10;After allocation it will be false." Name="bNewStickAtStart"/>
		bUsersBufferAllocated 	: DINT;			//! <Variable Comment="TRUE when memory for USersBuffer&#13;&#10;have been allocated otherwise FALSE" Name="bUsersBufferAllocated"/>
		aPerSerNum 	: t_a_USB_Serial;			//! <Variable Comment="Array to save the USB-serial number&#13;&#10;for a USB that was connected to CPU&#13;&#10;during CPU-Start" Name="aPerSerNum"/>
		IsCon_coSystemLogging 	: BOOL;
		Reload 	: DINT;
		aTmpUsername : ARRAY [0..255] OF CHAR;

		aTmpPassword : ARRAY [0..255] OF CHAR;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Constructor of the class, is used for initialisation of variables and server." Name="AccessControlMain"/>
	FUNCTION AccessControlMain
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="In dieser Methode wird das Datei-Handling verwaltet." Name="IF_WindowRun"/>
	FUNCTION VIRTUAL GLOBAL IF_WindowRun
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowEnd
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_ChkEnable
		VAR_INPUT
			key 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Add a new user." Name="AddUser"/>
	FUNCTION GLOBAL AddUser;
				//! <Function Comment="Edit the selected user." Name="EditUser"/>
	FUNCTION GLOBAL EditUser;
				//! <Function Comment="Delete the selected user." Name="DeleteUser"/>
	FUNCTION GLOBAL DeleteUser;
				//! <Function Comment="Searches a user with the username." Name="SearchUser"/>
	FUNCTION SearchUser
		VAR_INPUT
			pBuffer 	: ^t_s_VKUser;			//! <Variable Comment="Pointer to the buffer in which the user should be searched." Name="SearchUser.pBuffer"/>
			pUserName 	: ^USINT;			//! <Variable Comment="Pointer to the username which should be searched." Name="SearchUser.pUserName"/>
			pUser 	: ^t_s_User;			//! <Variable Comment="Pointer to the user data, in case that he was found." Name="SearchUser.pUser"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="-1..Error&#13;&#10;&gt;=0..Ok" Name="SearchUser.retcode"/>
		END_VAR;
				//! <Function Comment="Login of a user." Name="Login"/>
	FUNCTION GLOBAL Login;
				//! <Function Comment="Triggers the actualization of the userfile." Name="refreshUserFile"/>
	FUNCTION refreshUserFile;
				//! <Function Comment="Logout of the user which is actual logged in." Name="Logout"/>
	FUNCTION GLOBAL Logout;
				//! <Function Comment="Reset the server values." Name="clearServers"/>
	FUNCTION clearServers;
				//! <Function Comment="Provide the user data (for example: to edit a user in the visu)&#13;&#10;&#13;&#10;Benutzerdaten bereitstellen.&#13;&#10;(zB. zum Benutzer Bearbeiten in Visu)" Name="ShowUserData"/>
	FUNCTION GLOBAL ShowUserData;
				//! <Function Comment="Is used to change the password of a user." Name="ChangePassword"/>
	FUNCTION GLOBAL ChangePassword
		VAR_INPUT
			bAdmin 	: BOOL;			//! <Variable Comment="Shows if this method was called from a logged in user or from the user managment (Admin).&#13;&#10;&#13;&#10;Gibt an, ob diese Methode von einem eingeloggten Benutzer, oder von der Benutzerverwaltung (Administrator) aus aufgerufen wurde." Name="ChangePassword.bAdmin"/>
		END_VAR
		VAR_OUTPUT
			bRet 	: BOOL;			//! <Variable Comment="FALSE..Password is not changed&#13;&#10;TRUE..Password changed" Name="ChangePassword.bRet"/>
		END_VAR;
				//! <Function Comment="Links the serial number of a plugged USB-stick with the selected user." Name="AddUsbSN"/>
	FUNCTION GLOBAL AddUsbSN;
				//! <Function Comment="Links the serial number of a plugged USB-stick with the actual logged in user." Name="AddUsbSNbyUser"/>
	FUNCTION GLOBAL AddUsbSNbyUser;
				//! <Function Comment="Deletes the USB-link of the selected user." Name="DelUsbSN"/>
	FUNCTION GLOBAL DelUsbSN;
				//! <Function Comment="Writes a value on the server MSGNr depending on a ENUM. This value will be evaluated in the Visu, depending on a text list.&#13;&#10;&#13;&#10;Schreibt anhand eines ENUMs einen Wert auf den Server MSGNr, welcher in der Visu anhand einer Textliste ausgewertet wird." Name="MESSAGE"/>
	FUNCTION VIRTUAL GLOBAL MESSAGE
		VAR_INPUT
			dMSGNumber 	: DINT;
		END_VAR;
				//! <Function Comment="Searches a user depending on the number and sets the input parameter pUser to the data of the found user." Name="getUserDataByNr"/>
	FUNCTION GLOBAL getUserDataByNr
		VAR_INPUT
			udUserNr 	: UDINT;			//! <Variable Comment="Number of the user which should be searched." Name="getUserDataByNr.udUserNr"/>
			pUser 	: ^t_s_User;			//! <Variable Comment="Pointer to the data of a found user." Name="getUserDataByNr.pUser"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0..Ok&#13;&#10;-1..Error" Name="getUserDataByNr.retcode"/>
		END_VAR;
				//! <Function Comment="Delivers the number of users." Name="getNumberOfUsers"/>
	FUNCTION GLOBAL getNumberOfUsers
		VAR_OUTPUT
			udUsers 	: UDINT;			//! <Variable Comment="Number of users." Name="getNumberOfUsers.udUsers"/>
		END_VAR;
				//! <Function Comment="Method to register access lists." Name="RegisterAccessList"/>
	FUNCTION GLOBAL RegisterAccessList
		VAR_INPUT
			pNewAccessList 	: ^AccessControlList;			//! <Variable Comment="Thispointer of the access list." Name="RegisterAccessList.pNewAccessList"/>
		END_VAR;
				//! <Function Comment="Is called when a USB-stick is plugged in. If there is a link of the serial number and a user, the user will be logged in automatically." Name="NewStick"/>
	FUNCTION GLOBAL NewStick
		VAR_INPUT
			pSerNum 	: ^void;			//! <Variable Comment="Serial number of the USB-stick." Name="NewStick.pSerNum"/>
		END_VAR;
				//! <Function Comment="Is called when a plugged in USB-stick is going to unplug. Was a user logged in with this USB-stick, then he will be logged out." Name="StickRemoved"/>
	FUNCTION GLOBAL StickRemoved
		VAR_INPUT
			pSerNum 	: ^void;			//! <Variable Comment="Serial number of the USB-stick." Name="StickRemoved.pSerNum"/>
		END_VAR;
				//! <Function Comment="Looks if a user is linked with the serial number of a plugged in USB-stick." Name="SearchUserbyUsbSN"/>
	FUNCTION SearchUserbyUsbSN
		VAR_INPUT
			pUser 	: ^t_s_User;			//! <Variable Comment="In case that a user was found, this pointer points to the user data." Name="SearchUserbyUsbSN.pUser"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="-1..Error&#13;&#10;&gt;=0..Ok" Name="SearchUserbyUsbSN.retcode"/>
		END_VAR;
				//! <Function Comment="Searches a user depending on the position in the list and returns a pointer to the userdata." Name="getUserToEdit"/>
	FUNCTION getUserToEdit
		VAR_INPUT
			udPos 	: UDINT;			//! <Variable Comment="Position of the user in the list." Name="getUserToEdit.udPos"/>
		END_VAR
		VAR_OUTPUT
			pUser 	: ^t_s_User;			//! <Variable Comment="Pointer to the user data, in case that a user was found." Name="getUserToEdit.pUser"/>
		END_VAR;
				//! <Function Comment="Switch to the main screen." Name="closeScreen"/>
	FUNCTION closeScreen;
				//! <Function Comment="Creates a admin with the passed data." Name="CreateAdmin"/>
	FUNCTION GLOBAL CreateAdmin
		VAR_INPUT
			pUsername 	: ^CHAR;			//! <Variable Comment="Name of the admin." Name="CreateAdmin.pUsername"/>
			pPassword 	: ^CHAR;			//! <Variable Comment="Password of the admin." Name="CreateAdmin.pPassword"/>
			usLevel 	: USINT;			//! <Variable Comment="User level of the admin." Name="CreateAdmin.usLevel"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Admin not created.&#13;&#10;TRUE..Admin created." Name="CreateAdmin.bSuccessful"/>
		END_VAR;
	
	FUNCTION GLOBAL ReloadRecipe
		VAR_INPUT
			ReadValue 	: DINT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SelectFunction::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CopyUserFile::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _FileSys
#pragma usingLtd EventQueue
#pragma usingLtd ProjectGlobal
#pragma usingLtd System
#pragma usingLtd SystemLogging


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AccessControlMain::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_ACCESSCONTROLMAIN
2$UINT, 17$UINT, (SIZEOF(::AccessControlMain))$UINT, 
19$UINT, 20$UINT, 0$UINT, 
TO_UDINT(1830373904), "AccessControlMain", //Class
TO_UDINT(3788417926), "_Global", 0$UINT, 14$UINT, //Baseclass
//Servers:
(::AccessControlMain.SelectFunction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2341012260), "SelectFunction", 
(::AccessControlMain.NextScreen.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(953367535), "NextScreen", 
(::AccessControlMain.EUserName.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(692262836), "EUserName", 
(::AccessControlMain.EPasswordOld.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(1388793247), "EPasswordOld", 
(::AccessControlMain.EPassword.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3839842070), "EPassword", 
(::AccessControlMain.EPassword2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(4008039435), "EPassword2", 
(::AccessControlMain.ELevel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1170981826), "ELevel", 
(::AccessControlMain.ETimeOut.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(657934102), "ETimeOut", 
(::AccessControlMain.EInfo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(2322146267), "EInfo", 
(::AccessControlMain.EUsbSN.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3035685157), "EUsbSN", 
(::AccessControlMain.LUserName.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(2246091247), "LUserName", 
(::AccessControlMain.LPassword.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(1216143693), "LPassword", 
(::AccessControlMain.ActUser.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(2702005403), "ActUser", 
(::AccessControlMain.ActLevel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3379937697), "ActLevel", 
(::AccessControlMain.MSGNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(565379775), "MSGNr", 
(::AccessControlMain.UserFile.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(3973173805), "UserFile", 
(::AccessControlMain.CopyUserFile.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2542678631), "CopyUserFile", 
(::AccessControlMain.UserIsLoggedIn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(944245539), "UserIsLoggedIn", 
(::AccessControlMain.LoggedInWithUsb.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2344123189), "LoggedInWithUsb", 
//Clients:
(::AccessControlMain.Deactivate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4121546348), "Deactivate", 
(::AccessControlMain.coDriveLetter.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2932290194), "coDriveLetter", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.coFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(940542775), "coFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
(::AccessControlMain.coSystem.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4161038425), "coSystem", TO_UDINT(968218125), "System", 0$UINT, 1$UINT, 
(::AccessControlMain.StrActUser.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3044358681), "StrActUser", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.StrEditUserName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3343489247), "StrEditUserName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.StrEditPassword.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(181786749), "StrEditPassword", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.StrEditPassword2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(879453780), "StrEditPassword2", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.StrEditUsbSN.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1615830285), "StrEditUsbSN", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.StrLoginUserName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2057897138), "StrLoginUserName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.StrLoginPassword.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3073721360), "StrLoginPassword", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.StrEditInfo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2384849336), "StrEditInfo", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.StrUserFile.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4017309775), "StrUserFile", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.coEventQueue.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2896066780), "coEventQueue", TO_UDINT(915169004), "EventQueue", 1$UINT, 3$UINT, 
(::AccessControlMain.ActScreenNr.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1681679496), "ActScreenNr", 
(::AccessControlMain.coGlobal.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3645698641), "coGlobal", TO_UDINT(1462004836), "ProjectGlobal", 1$UINT, 9$UINT, 
(::AccessControlMain.RefreshList.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(788426340), "RefreshList", 
(::AccessControlMain.StrEditPasswordOld.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1250624554), "StrEditPasswordOld", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlMain.coSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(292037947), "coSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 4$UINT, 
(::AccessControlMain.AccessConfig.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(571864739), "AccessConfig", 
END_FUNCTION


#define USER_CNT_AccessControlMain 45

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AccessControlMain] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AccessControlMain::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Global::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Global::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Global::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AccessControlMain;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IF_WindowRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #IF_WindowEnd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #IF_ChkEnable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[44]		:= #MESSAGE();

#pragma warning (default : 74)
	_Global::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Global::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SelectFunction.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SelectFunction::Write() );
	IF SelectFunction.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	NextScreen.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF NextScreen.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	EPasswordOld.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF EPasswordOld.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ELevel.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ELevel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ETimeOut.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ETimeOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LUserName.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF LUserName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LPassword.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF LPassword.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActUser.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ActUser.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, UserFile.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #UserFile::M_WR_DIRECT();
	UserFile.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF UserFile.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CopyUserFile.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CopyUserFile::Write() );
	IF CopyUserFile.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AccessControlMain();

END_FUNCTION

#pragma usingLtd AccessControlList

//{{LSL_IMPLEMENTATION

#pragma UsingLtd AccessControlList


FUNCTION VIRTUAL GLOBAL AccessControlMain::Init

  if _Firstscan then
    
    // Methode der Basis-Klasse
    _Global::Init();

    //-----------------------------------------------------------------------------------------
    //  check client-connnections and set flags                   GreJoh
    //-----------------------------------------------------------------------------------------    
    if IsClientConnected(#coSystemLogging) then
      IsCon_coSystemLogging := TRUE;
    else 
      IsCon_coSystemLogging := FALSE;
    end_if;

    
    // Speicher für Benutzer-Puffer
    //-----------------------------------------------------------------------------------------
    pUserBuffer$^void := coSystem.Malloc(size0 := sizeof(t_s_User) * AccessControl_NumUserBuffer);
    if (pUserBuffer = NIL) then
      if IsCon_coSystemLogging = TRUE then
        coSystemLogging.LogEventText("AccessControlMain::Init(): Speicher allokieren für den Puffer zum Dateischreiben fehlgeschlagen" );
      end_if;
      return;
    else
      // Schreibezeiger und Länge des Puffers setzen
      pWriteUserBuffer  := pUserBuffer;
      udUserBufferSize  := sizeof(t_s_User) * AccessControl_NumUserBuffer;
    end_if;
    
    // Zeiger auf Benutzer-Puffer setzen
    pActUser := UsersBuffer;
        
    // Init fertig durchlaufen, mit Dateihandling beginnen
    eUserFileState := AccessControl_FILEOPEN;
    
    bdAccessConfig := AccessConfig.Read();
  
    // Make standard a user
    StrCpy(p0:= #aTmpUsername, x1:= sizeof(_ASCII), p2:= cConfigName, x3:= sizeof(_ASCII));
    DToA(p0:= #aTmpPassword[0], x1:= cConfigCode, x2:= 16#800, x3:= 1);
    CreateAdmin(pUsername:= #aTmpUsername[0], pPassword:= #aTmpPassword[0], usLevel:= 255);
  end_if;
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AccessControlMain::IF_WindowRun
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
		event 	: ^_EVENT;
	END_VAR
  VAR
    pHelp          : ^t_s_VKAccessLists;
    tmpUserTimeout : UDINT;
    tmpUser        : t_s_User;
    tmpUserName    : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpCount       : UDINT;
  END_VAR
  
  //****************************************************************************
  //****************************************************************************
  //****      Schrittschaltwerk für das Verwalten der Benutzerdaten         ****
  //****************************************************************************
  //****************************************************************************
  case eUserFileState of
    
    //****************************************************************************
    AccessControl_IDLE:
            // Benutzerdaten erfolgreich gelesen
            
      //if a USB-stick was connected during start
      if bNewStickAtStart & bUsersBufferAllocated then
        NewStick(#aPerSerNum);
        bNewStickAtStart := false;
      end_if;

            
            
    //****************************************************************************        
    AccessControl_FILEOPEN:
            // Pfad der Datei zum Speichern der Benutzer holen
            //-----------------------------------------------------------------------------------------
            StrNCpy(p0 := #aUserFilePath[0], 
                    x1 := sizeof(aUserFilePath[0]), 
                    p2 := AccessControl_InitDriveLetter, 
                    x3 := sizeof(_ASCII), 
                    ml := AccessControl_MaxUserFilePathLength);
            StrUserFile.WriteDataOff(udLen:=_strlen(#aUserFilePath[0]), udOff:=0, pData:=#aUserFilePath[0]);
                        
            // Datei öffnen/erstellen, wenn vorhanden diese nicht überschreiben
            dAsyncID := coFileSys.FileOpen_A(Async := 1, FileName := #aUserFilePath[0], attributes := ATT_CREATE);
            eUserFileState := AccessControl_WAIT4FILEOPEN;
            
            
    //****************************************************************************
    AccessControl_WAIT4FILEOPEN:
            // Datei schon fertig geöffnet?
            dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);
            
            case dAsyncState of
              0:
                // Fertig und geöffnet
                if dFileHandle >= 0 then
                  eUserFileState := AccessControl_FILELENGTH;              
                else
                  if IsCon_coSystemLogging = TRUE then
                    coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Öffnen der Datei" );
                  end_if;
                  eUserFileState := AccessControl_IDLE;                
                end_if;  
              
              RT_INVALID_ID,
              RT_ERG_DELETED:
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Öffnen der Datei" );
                end_if;
                eUserFileState := AccessControl_IDLE;                  
                
              RT_NOT_STARTED,
              RT_IN_PROGRESS:
              
            else
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Öffnen der Datei" );
              end_if;
              eUserFileState := AccessControl_IDLE;                                
            end_case;
               
               
    //****************************************************************************
    AccessControl_FILELENGTH:
            // Länge der Datei lesen
            dAsyncID := coFileSys.FileLength_A(Async := 1, handle := dFileHandle);
            eUserFileState := AccessControl_WAIT4FILELENGTH;
            
            
    //****************************************************************************
    AccessControl_WAIT4FILELENGTH:
            // Länge der Datei schon fertig gelesen?
            dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileLength);
            
            case dAsyncState of
              0:
                // Fertig und geöffnet
                if dFileLength >= 0 then
                  eUserFileState := AccessControl_FILETELL;  
                else
                  if IsCon_coSystemLogging = TRUE then
                    coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen der Dateilänge" );
                  end_if;
                  eUserFileState := AccessControl_FILECLOSE;                
                end_if;  
              
              RT_INVALID_ID,
              RT_ERG_DELETED:
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen der Dateilänge" );
                end_if;
                eUserFileState := AccessControl_FILECLOSE;                  
                
              RT_NOT_STARTED,
              RT_IN_PROGRESS:
              
            else
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen der Dateilänge" );
              end_if;
              eUserFileState := AccessControl_FILECLOSE;                                
            end_case;
  
            
    //****************************************************************************
    AccessControl_FILETELL:
            // Position des Dateizeigers lesen
            dAsyncID := coFileSys.FileTell_A(Async := 1, handle := dFileHandle);
            eUserFileState := AccessControl_WAIT4FILETELL;
            
            
    //****************************************************************************
    AccessControl_WAIT4FILETELL:
            // Position des Dateizeigers schon gelesen?
            dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileTell);
            
             case dAsyncState of
              0:
                // Fertig und geöffnet
                if dFileTell = 0 then
                  eUserFileState := AccessControl_READHEADER; 
                elsif dFileTell >= 0 then
                  eUserFileState := AccessControl_FILEREAD;  
                else
                  if IsCon_coSystemLogging = TRUE then
                    coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Holen der Position des Dateizeigers" );
                  end_if;
                  eUserFileState := AccessControl_FILECLOSE;                
                end_if;  
              
              RT_INVALID_ID,
              RT_ERG_DELETED:
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Holen der Position des Dateizeigers" );
                end_if;
                eUserFileState := AccessControl_FILECLOSE;                  
                
              RT_NOT_STARTED,
              RT_IN_PROGRESS:
              
            else
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Holen der Position des Dateizeigers" );
              end_if;
              eUserFileState := AccessControl_FILECLOSE;                                
            end_case;
    
    
    //****************************************************************************
    AccessControl_READHEADER:
            // Wenn Daten vorhanden sind und der Dateizeiger gültig ist
            //-----------------------------------------------------------------------------------------
            if (dFileLength > 0) & (dFileTell >= 0)  then
              
              // Dateizeiger gültig
              if (dFileTell < dFileLength) then
                                                
                // Header lesen
                dAsyncID := to_dint(coFileSys.FileRead_A(Async:=1, handle:=dFileHandle, buffer:=#Header, length:=AccessControl_HeaderLength));
                eUserFileState := AccessControl_WAIT4READHEADER;
              
              else
                eUserFileState := AccessControl_FILECLOSE;
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen des Headers" );            
                end_if;
              end_if;
              
            else
              eUserFileState := AccessControl_FILECLOSE;
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen des Headers" );            
              end_if;
            end_if;
            
            
    //****************************************************************************
    AccessControl_WAIT4READHEADER:
            // Daten schon fertig gelesen?
            dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileRead);
            
            
            case dAsyncState of
              0:
              // Fertig und gelesen
              //-----------------------------------------------------------------------------------------
              if dFileRead = AccessControl_HeaderLength then
              
                // Header entschlüsseln und speichern
                DeEncode(#Header, sizeof(t_s_UserHeader), false);
                
                // Gleicher Versionsstand?
                if (Header.udVersion = AccessControl_Version) & (Header.udUserStructSize = sizeof(t_s_User)) &
                   (((Header.udNumUser * Header.udUserStructSize) + sizeof(t_s_UserHeader)) =  TO_UDINT(dFileLength)) then
                                  
                  // Speicher für alle Benutzer reservieren
                  tmpCount := 0;
                  while (tmpCount < Header.udNumUser) do
                    
                    // Speicher für einen weiteren Benutzer reservieren
                    //-----------------------------------------------------------------------------------------
                    if UsersBuffer = NIL then
        
                      UsersBuffer$^void := coSystem.Malloc(sizeof(t_s_VKUser));
                      UsersBuffer^.pNext := NIL;
                      pActUser := UsersBuffer;
                      tmpCount += 1;
                      bUsersBufferAllocated := TRUE;
                    else
                    
                      pActUser^.pNext$^void := coSystem.Malloc(size0:=sizeof(t_s_VKUser)); 
                      if (pActUser^.pNext = NIL) then
                        MESSAGE(dMSGNumber:=ERR_MEMORY);
                        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
                        if IsCon_coSystemLogging = TRUE then
                          coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim allokieren des Speichers" );
                        end_if;
                        return;
                      else
                        tmpCount += 1;
                        pActUser := pActUser^.pNext;
                        pActUser^.pNext := NIL;
                      end_if;
                      
                    end_if;
                  
                  end_while;
                  
                  // Zeiger wieder auf den reservierten Speicherplatz für den Ersten Benutzer setzen
                  pActUser       := UsersBuffer;
                  eUserFileState := AccessControl_FILETELL;
                
                else
                  // Noch Kompatibel machen für andere Versionen!!!
                  //  -> bei zu kleiner Struktur defaultwerte definieren, bei zu großer den Rest einfach nicht übernehmen!
                  if IsCon_coSystemLogging = TRUE then
                    coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Falscher Versionsstand!" );
                  end_if;
                  eUserFileState := AccessControl_FILECLOSE;
                end_if;
                
              else
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen des Headers" );
                end_if;
                eUserFileState := AccessControl_FILECLOSE;
              end_if;  
              
              RT_INVALID_ID,
              RT_ERG_DELETED:
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen des Headers" );
                end_if;
                eUserFileState := AccessControl_FILECLOSE;                  
                
              RT_NOT_STARTED,
              RT_IN_PROGRESS:
              
            else
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen des Headers" );
              end_if;
              eUserFileState := AccessControl_FILECLOSE;                                
            end_case;
            
            
    //****************************************************************************
    AccessControl_FILEREAD:
            // Wenn Daten vorhanden sind und der Dateizeiger gültig ist
            //-----------------------------------------------------------------------------------------
            if (dFileLength > 0) & (dFileTell >= 0)  then
              
              // Dateiende erreicht
              if (dFileTell >= dFileLength) then
                
                // Letzten Datensatz kennzeichnen
                eUserFileState  := AccessControl_FILECLOSE;
              
              // Weiteren Benutzer lesen
              else
                  // Benutzerdaten des aktuellen Benutzers lesen
                dAsyncID := to_dint(coFileSys.FileRead_A(Async:=1, handle:=dFileHandle, buffer:=#pActUser^.User, length:=sizeof(t_s_User)));
                eUserFileState := AccessControl_WAIT4FILEREAD;
                
              end_if;
              
            else
              eUserFileState := AccessControl_FILECLOSE;
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen der Benutzerdaten" );            
              end_if;
            end_if;
            
            
    //****************************************************************************
    AccessControl_WAIT4FILEREAD:
            // Daten schon fertig gelesen?
            dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileRead);
            
            case dAsyncState of
              0:
                // Fertig und gelesen
                //-----------------------------------------------------------------------------------------
                if (dFileRead >= 0) & (pActUser <> NIL) then
                
                  // Benutzerdaten entschlüsseln
                  DeEncode(#pActUser^.User, sizeof(t_s_User), false);
                  pActUser := pActUser^.pNext;
                  
                  // Keine oder falsche Benutzerdaten gelesen
                  //-----------------------------------------------------------------------------------------
                  if (dFileRead <> sizeof(t_s_User)) then 
                    
                    MESSAGE(dMSGNumber := ERR_USERS_FILE);
                    InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
                    if IsCon_coSystemLogging = TRUE then
                      coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Keine bzw. falsche Benutzerdaten gelesen" );
                    end_if;
                    pActUser := UsersBuffer^.pNext;
                    
                    // Reservierten Speicher freigeben
                    while (pActUser <> NIL) do
                    
                      pBefore         := pActUser;
                      pActUser        := pActUser^.pNext;
                      udNumberOfUsers := 0;
                      coSystem.Free(ptr0:=pBefore);
                    
                    end_while;
                    
                    eUserFileState := AccessControl_FILECLOSE;
                  
                  // Richtigen Datensatz gelesen
                  //-----------------------------------------------------------------------------------------
                  else
                  
                    udNumberOfUsers += 1;                
                    eUserFileState  := AccessControl_FILETELL;
                  
                  end_if;
                    
                  else
                    if IsCon_coSystemLogging = TRUE then
                      coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen der Benutzerdaten" );
                    end_if;
                    eUserFileState := AccessControl_FILECLOSE;
                  end_if;  
              
              RT_INVALID_ID,
              RT_ERG_DELETED:
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen der Benutzerdaten" );
                end_if;
                eUserFileState := AccessControl_FILECLOSE;                  
                
              RT_NOT_STARTED,
              RT_IN_PROGRESS:
              
            else
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Lesen der Benutzerdaten" );
              end_if;
              eUserFileState := AccessControl_FILECLOSE;                                
            end_case;
            
    
    
    //****************************************************************************
    AccessControl_FILEREFRESH:
            // Datei aktualisieren/ersetzen
            dAsyncID := coFileSys.FileOpen_A(Async := 1, FileName := #aUserFilePath[0], attributes := ATT_CREATE_ALWAYS);
            eUserFileState := AccessControl_WAIT4FILEREFRESH;
            
            
    //****************************************************************************
    AccessControl_WAIT4FILEREFRESH:
            // Datei schon fertig geöffnet?
            dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);
            
            case dAsyncState of
              0:
                // Fertig und wieder geöffnet
                  if dFileHandle >= 0 then
                  
                    pActUser            := UsersBuffer;
                    pWriteUserBuffer    := pUserBuffer;
                    udAddedUserDataSize := 0;
                    eUserFileState := AccessControl_WRITEHEADER;
                          
                  else
                    if IsCon_coSystemLogging = TRUE then
                      coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Datei für die Benutzerdaten konnte nicht erstellt werden" );
                    end_if;
                    eUserFileState := AccessControl_FILECLOSE;
                  end_if;  
              
              RT_INVALID_ID,
              RT_ERG_DELETED:
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Datei für die Benutzerdaten konnte nicht erstellt werden" );
                end_if;
                eUserFileState := AccessControl_FILECLOSE;                  
                
              RT_NOT_STARTED,
              RT_IN_PROGRESS:
              
            else
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Datei für die Benutzerdaten konnte nicht erstellt werden" );
              end_if;
              eUserFileState := AccessControl_FILECLOSE;                                
            end_case;
            
        
    //****************************************************************************
    AccessControl_WRITEHEADER:
            // Header setzen und verschlüsseln
            Header.udVersion        := AccessControl_Version;
            Header.udUserStructSize := sizeof(t_s_User);
            Header.udNumUser        := udNumberOfUsers;
            DeEncode(#Header, sizeof(t_s_UserHeader), true);
            
            dAsyncID := coFileSys.FileWrite_A(Async:=1, handle:=dFileHandle, buffer:=#Header, length:=AccessControl_HeaderLength);
            eUserFileState := AccessControl_WAIT4WRITEHEADER;    
    
    
    //****************************************************************************
    AccessControl_WAIT4WRITEHEADER:
            // Daten schon fertig geschrieben?
            dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileWrite);
            
            case dAsyncState of
              0:
                // Header erfolgreich geschrieben
                  if dFileWrite = AccessControl_HeaderLength then
                    if udNumberOfUsers > 0 then
                      eUserFileState := AccessControl_FILLBUFFER;
                    else
                      eUserFileState := AccessControl_FILECLOSE;
                    end_if;
                          
                  else
                    if IsCon_coSystemLogging = TRUE then
                      coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
                    end_if;
                    eUserFileState := AccessControl_FILECLOSE;
                  end_if;  
              
              RT_INVALID_ID,
              RT_ERG_DELETED:
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
                end_if;
                eUserFileState := AccessControl_FILECLOSE;                  
                
              RT_NOT_STARTED,
              RT_IN_PROGRESS:
              
            else
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
              end_if;
              eUserFileState := AccessControl_FILECLOSE;                                
            end_case;
            
            
    //****************************************************************************
    AccessControl_FILLBUFFER:
            // Alle Zeilen geschrieben, Buffer voll oder Zeit abgelaufen
            //-----------------------------------------------------------------------------------------
            while (udAddedUserDataSize < udUserBufferSize) do
              
              // erster User wurde nicht in das File eingetragen, da pNext NIL ist!!
              // Abfrage gilt nur, wenn erster User eingetragen wird
              if udAddedUserDataSize = 0 then
                if (pActUser <> NIL) & (pWriteUserBuffer <> NIL) then
                  ActUserBuffer     := pActUser^.User;
                  DeEncode(#ActUserBuffer, sizeof(t_s_User), true);
                  pWriteUserBuffer^ := ActUserBuffer;
                  pWriteUserBuffer  += sizeof(t_s_User);
                end_if;
              else
                // Zeiger auf Benutzer gültig?
                if (pActUser^.pNext <> NIL) & (pWriteUserBuffer <> NIL) then
                  
                  // Änderungen des Buffers in die Datei schreiben
                  ActUserBuffer     := pActUser^.pNext^.User;
                  DeEncode(#ActUserBuffer, sizeof(t_s_User), true);
                  pWriteUserBuffer^ := ActUserBuffer;
                  pWriteUserBuffer  += sizeof(t_s_User);
                  pActUser          := pActUser^.pNext;
                  
                else
                  // Alle Benutzer in den Puffer geladen
                  exit;
                end_if;
              end_if;

              // Größe der aktuellen Daten im Buffer erhöhen
              udAddedUserDataSize := pWriteUserBuffer$udint - pUserBuffer$udint;
              
            end_while;
            
            eUserFileState := AccessControl_FILEWRITE;
            
    
    //****************************************************************************
    AccessControl_FILEWRITE:
            // Zeiger auf Benutzer gültig?
            if (pUserBuffer <> NIL) & (udAddedUserDataSize > 0) then
              dAsyncID := coFileSys.FileWrite_A(Async:=1, handle:=dFileHandle, buffer:=pUserBuffer, length:=udAddedUserDataSize);
              eUserFileState := AccessControl_WAIT4FILEWRITE;
            else
              eUserFileState := AccessControl_FILECLOSE;
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Zeiger auf Benutzerdaten ungültig" );
              end_if;
            end_if;
                
    
    //****************************************************************************
    AccessControl_WAIT4FILEWRITE:
            // Daten schon fertig geschrieben?
            dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileWrite);
            
            case dAsyncState of
              0:
                // alle Benutzerdaten geschrieben
                  if (pActUser^.pNext = NIL) & (dFileWrite >= 0) then
                    
                    // Aktualisiere registrierte Zugriffslisten
                    pHelp := pAccessListsBuffer;              
                    while (pHelp <> NIL) do
                      pHelp^.AccessList^.UpdateList.Write(1);
                      pHelp := pHelp^.pNext;
                    end_while;
                    
                    eUserFileState := AccessControl_FILECLOSE;
                    
                  elsif dFileWrite >= 0 then
                  
                    // Buffer für neue Daten leeren und Schreibezeiger auf Anfang setzen
                    pWriteUserBuffer    := pUserBuffer;
                    udAddedUserDataSize := 0;
                    
                    eUserFileState := AccessControl_FILLBUFFER;
                  else
                  
                    if IsCon_coSystemLogging = TRUE then
                      coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
                    end_if;
                    eUserFileState := AccessControl_FILECLOSE;
                    
                  end_if;  
              
              RT_INVALID_ID,
              RT_ERG_DELETED:
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
                end_if;
                eUserFileState := AccessControl_FILECLOSE;                  
                
              RT_NOT_STARTED,
              RT_IN_PROGRESS:
              
            else
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
              end_if;
              eUserFileState := AccessControl_FILECLOSE;                                
            end_case;
            
            
    //****************************************************************************
    AccessControl_FILECLOSE:            
            dAsyncID := coFileSys.FileClose_A(Async := 1, handle := dFileHandle);
            eUserFileState := AccessControl_WAIT4FILECLOSE;
            
            
    //****************************************************************************
    AccessControl_WAIT4FILECLOSE:
            // Datei schon geschlossen?
            dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);
            
            case dAsyncState of
              0:
                // Fertig und geschlossen
                  if dFileHandle >= 0 then
                  
                    eUserFileState := AccessControl_IDLE;
                    
                  else
                    
                    if IsCon_coSystemLogging = TRUE then
                      coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Schließen der Datei" );
                    end_if;
                    eUserFileState := AccessControl_IDLE;
                    
                  end_if;  
              
              RT_INVALID_ID,
              RT_ERG_DELETED:
                if IsCon_coSystemLogging = TRUE then
                  coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Schließen der Datei" );
                end_if;
                eUserFileState := AccessControl_IDLE;                  
                
              RT_NOT_STARTED,
              RT_IN_PROGRESS:
              
            else
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::IF_WindowRun(): Fehler beim Schließen der Datei" );
              end_if;
              eUserFileState := AccessControl_IDLE;                                
            end_case;
    
  end_case;
  
  
  
  // Abmeldezeit des eingeloggten Benutzers kontrollieren
  //-----------------------------------------------------------------------------------------
  if UserIsLoggedIn & (LoggedInWithUsb = 0) then
    
    tmpUserName[0] := 0;
    StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    if (SearchUser(pBuffer := UsersBuffer, pUserName:=#tmpUserName[0], pUser:=#tmpUser) <> -1) then
      
      // Abmeldezeit eingegeben?
      tmpUserTimeout := (tmpUser.udUserTimeout min);
      if (tmpUserTimeout <> 0) then
        
        // Abmeldezeit bei einem Event zurücksetzen
        //-----------------------------------------------------------------------------------------
        if (event^.ftype = _EVENT_HIDPRESS) | (event^.ftype = _EVENT_KEYPRESS) then
          udTimeout := ops.tAbsolute;
        end_if;
        
        // Zeit abgelaufen?
        //-----------------------------------------------------------------------------------------
        if ((ops.tAbsolute - udTimeout) > tmpUserTimeout) then
          Logout();
          udTimeout      := 0;
          tmpUserName[0] := 0;
        end_if;
      end_if;
    end_if;
  end_if;
  

END_FUNCTION


FUNCTION AccessControlMain::refreshUserFile
  
  // Datei mit den Benutzerdaten aktualisieren (Schrittschaltwerk neu anstoßen)
  eUserFileState := AccessControl_FILEREFRESH;
  
END_FUNCTION


FUNCTION GLOBAL AccessControlMain::AddUser
  VAR
    pActualVKUser : ^t_s_VKUser;
    tmpUserName   : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpPassword   : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpPWControl  : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpUserInfo   : ARRAY[0..AccessControl_MaxUserInfoLength] of CHAR;
  END_VAR
  
  tmpUserName[0]  := 0;
  tmpPassword[0]  := 0;
  tmpPWControl[0] := 0;
  tmpUserInfo[0]  := 0;
   
  StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
  StrEditPassword.GetDataAt(pData:=#tmpPassword[0], udSize:=StrEditPassword.GetLength()+1, udAt:=0);
  StrEditPassword2.GetDataAt(pData:=#tmpPWControl[0], udSize:=StrEditPassword2.GetLength()+1, udAt:=0);
  StrEditInfo.GetDataAt(pData:=#tmpUserInfo[0], udSize:=StrEditInfo.GetLength()+1, udAt:=0);
  
  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if StrEditUserName.GetLength() then
    
    // Benutzer existiert noch nicht
    //-----------------------------------------------------------------------------------------
    if (SearchUser(pBuffer := UsersBuffer, pUserName := #tmpUserName[0], pUser := NIL) = -1) then
      
      // Berechtigt um diese Zugriffsberechtigung zu vergeben
      if (ELevel < ActLevel) then
      
        if UsersBuffer = NIL then
        
          if (StrCmp(p0:=#tmpPassword[0], x1:=sizeof(tmpPassword[0]), p2:=#tmpPWControl[0], x3:=sizeof(tmpPWControl[0])) = 0) then
            
            UsersBuffer$^void := coSystem.Malloc(sizeof(t_s_VKUser));
            UsersBuffer^.pNext := NIL;
            pActualVKUser := UsersBuffer;
            
            // Benutzerdaten in die Struktur speichern
            //-----------------------------------------------------------------------------------------
            StrNCpy(p0 := #pActualVKUser^.User.aUsername[0], 
                      x1 := sizeof(pActualVKUser^.User.aUsername[0]), 
                      p2 := #tmpUserName[0], 
                      x3 := sizeof(tmpUserName[0]), 
                      ml := AccessControl_MaxUsernameLength);
              StrNCpy(p0 := #pActualVKUser^.User.aUserPassword[0], 
                      x1 := sizeof(pActualVKUser^.User.aUserPassword[0]), 
                      p2 := #tmpPassword[0], 
                      x3 := sizeof(tmpPassword[0]), 
                      ml := AccessControl_MaxPasswordLength);
              StrNCpy(p0 := #pActualVKUser^.User.aUserInfo[0], 
                      x1 := sizeof(pActualVKUser^.User.aUserInfo[0]), 
                      p2 := #tmpUserInfo[0], 
                      x3 := sizeof(tmpUserInfo[0]), 
                      ml := AccessControl_MaxUserInfoLength);
              pActualVKUser^.User.usUserLevel   := TO_USINT(ELevel);
              pActualVKUser^.User.udUserTimeout := ETimeOut;
              pActualVKUser^.User.USBSerial[0]  := 0;
              pActualVKUser^.pNext := NIL;
              
              udNumberOfUsers += 1;
              refreshUserFile();
            
            else
              MESSAGE(dMSGNumber:=ERR_ADDUSER);
              InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
            end_if;
          
        else
        
          pActualVKUser := UsersBuffer;
        
          // Letzten Benutzer holen
          while (pActualVKUser^.pNext <> NIL)  do
            pActualVKUser := pActualVKUser^.pNext;
          end_while;
          
          // Passwörter auf Gleichheit überprüfen
          //-----------------------------------------------------------------------------------------
          if (pActualVKUser <> NIL) & (StrCmp(p0:=#tmpPassword[0], x1:=sizeof(tmpPassword[0]), p2:=#tmpPWControl[0], x3:=sizeof(tmpPWControl[0])) = 0) then     
         
            // Speicher für den neuen Benutzer allokieren
            pActualVKUser^.pNext$^void := coSystem.Malloc(sizeof(t_s_VKUser));
            if pActualVKUser^.pNext = NIL then
              MESSAGE(dMSGNumber:=ERR_MEMORY);
              InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
              if IsCon_coSystemLogging = TRUE then
                coSystemLogging.LogEventText("AccessControlMain::AddUser(): Fehler beim allokieren des Speichers" );
              end_if;
              return;
            end_if;
          
            pActualVKUser := pActualVKUser^.pNext;
            
            // Benutzerdaten in die Struktur speichern
            //-----------------------------------------------------------------------------------------
            StrNCpy(p0 := #pActualVKUser^.User.aUsername[0], 
                    x1 := sizeof(pActualVKUser^.User.aUsername[0]), 
                    p2 := #tmpUserName[0], 
                    x3 := sizeof(tmpUserName[0]), 
                    ml := AccessControl_MaxUsernameLength);
            StrNCpy(p0 := #pActualVKUser^.User.aUserPassword[0], 
                    x1 := sizeof(pActualVKUser^.User.aUserPassword[0]), 
                    p2 := #tmpPassword[0], 
                    x3 := sizeof(tmpPassword[0]), 
                    ml := AccessControl_MaxPasswordLength);
            StrNCpy(p0 := #pActualVKUser^.User.aUserInfo[0], 
                    x1 := sizeof(pActualVKUser^.User.aUserInfo[0]), 
                    p2 := #tmpUserInfo[0], 
                    x3 := sizeof(tmpUserInfo[0]), 
                    ml := AccessControl_MaxUserInfoLength);
            pActualVKUser^.User.usUserLevel   := TO_USINT(ELevel);
            pActualVKUser^.User.udUserTimeout := ETimeOut;
            pActualVKUser^.User.USBSerial[0]  := 0;
            pActualVKUser^.pNext := NIL;
            
            udNumberOfUsers += 1;
            refreshUserFile();
          
          else
            MESSAGE(dMSGNumber:=ERR_ADDUSER);
            InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
          end_if;
        
      end_if;

      else
        MESSAGE(dMSGNumber:=ERR_AUTHORITY_LEVEL);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      end_if;
      
    else
      MESSAGE(dMSGNumber:=ERR_USER_EXISTS);
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    end_if;
    
  else
    MESSAGE(dMSGNumber:=ERR_NO_NAME); 
    InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::EditUser
  VAR
    tmpPos         : DINT;
    pActUser       : ^t_s_User;
    tmpUserName    : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpActUserName : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpUserInfo    : ARRAY[0..AccessControl_MaxUserInfoLength] of CHAR;
    tmpPWold       : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpOwnUser     : UINT;
  END_VAR
  
  tmpPos         := 0;
  tmpUserName[0] := 0;
  tmpUserInfo[0] := 0;
  tmpPWold[0]    := 0;
  
  // Benutzername und Passwort holen
  StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
  StrEditInfo.GetDataAt(pData:=#tmpUserInfo[0], udSize:=StrEditInfo.GetLength()+1, udAt:=0);
  StrEditPasswordOld.GetDataAt(pData:=#tmpPWold[0], udSize:=StrEditPasswordOld.GetLength()+1, udAt:=0);
  if UserIsLoggedIn then
    StrActUser.GetDataAt(pData:=#tmpActUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
  end_if;
  tmpOwnUser := (StrCmp(p0:=#tmpUserName[0], x1:=sizeof(tmpUserName[0]), p2:=#tmpActUserName[0], x3:=sizeof(tmpActUserName[0])));
  
  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if StrEditUserName.GetLength() then
  
    tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:= #tmpUserName[0], pUser:=NIL);
    // Benutzer existiert
    if (tmpPos >= 0) then
    
      // Benutzer nur zum Bearbeiten holen
      //-----------------------------------------------------------------------------------------
      pActUser := getUserToEdit(udPos:=to_udint(tmpPos));
      // Berechtigt um diesen Benutzer zu bearbeiten bzw. den eigenen Benutzer bearbeiten
      if (pActUser <> NIL) & ((pActUser^.usUserLevel < ActLevel) | (tmpOwnUser = 0)) then
        
        // Berechtigt um diese Zugriffsberechtigung zu vergeben
        if ((ELevel < ActLevel) | (tmpOwnUser = 0)) then
          
          // Passwort überprüfen
          if (StrCmp(p0:=#tmpPWold[0], x1:=sizeof(tmpPWold[0]), p2:=#pActUser^.aUserPassword[0], x3:=sizeof(pActUser^.aUserPassword[0])) = 0) then
            
            // Neue Benutzerdaten übernehmen
            if (ChangePassword(bAdmin:=true) = true) then
              
              MESSAGE(dMSGNumber:=MSG_EDITUSER_OK);
              
              StrNCpy(p0 := #pActUser^.aUsername[0], 
                      x1 := sizeof(pActUser^.aUsername[0]), 
                      p2 := #tmpUserName[0], 
                      x3 := sizeof(tmpUserName[0]), 
                      ml := AccessControl_MaxUsernameLength);
              StrNCpy(p0 := #pActUser^.aUserInfo[0], 
                      x1 := sizeof(pActUser^.aUserInfo[0]), 
                      p2 := #tmpUserInfo[0], 
                      x3 := sizeof(tmpUserInfo[0]), 
                      ml := AccessControl_MaxUserInfoLength);
              pActUser^.udUserTimeout := ETimeOut;
                
              // Der Benutzer darf sein eigenes Level nicht bearbeiten
              if (tmpOwnUser = 0) & (pActUser^.usUserLevel <> TO_USINT(ELevel)) then
                MESSAGE(dMSGNumber:=ERR_EDIT_OWNLEVEL);
              else
                pActUser^.usUserLevel := TO_USINT(ELevel);
              end_if;
                
              refreshUserFile();
              InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
            
            end_if;
            
          else
            MESSAGE(dMSGNumber:=ERR_WRONG_PWOLD);
            InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
          end_if;
        
        else
          MESSAGE(dMSGNumber:=ERR_AUTHORITY_LEVEL);
          InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        end_if;
        
      else
        MESSAGE(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      end_if;
      
    else
      MESSAGE(dMSGNumber:=ERR_USER_NOTEXIST);
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    end_if;
    
  else
      MESSAGE(dMSGNumber:=ERR_NO_NAME);
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::DeleteUser
  VAR
    tmpPos          : DINT;
    tmpCount        : DINT;
    pBefore         : ^t_s_VKUser;
    pActualVKUser   : ^t_s_VKUser;
    pActUser        : ^t_s_User;
    tmpActUserName  : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpDelUserName  : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
  END_VAR
  
  tmpPos   := 0;
  tmpCount := 0;
  
  // Aktuellen und zu löschenden Benutzernamen holen
  StrActUser.GetDataAt(pData:=#tmpActUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
  StrEditUserName.GetDataAt(pData:=#tmpDelUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
    
  // Kontrollieren, damit der aktuell angemeldete Benutzer nicht gelöscht wird
  //-----------------------------------------------------------------------------------------
  if StrCmp(p0:=#tmpActUserName[0], x1:=sizeof(tmpActUserName[0]), p2:=#tmpDelUserName[0], x3:=sizeof(tmpDelUserName[0])) then

    // Benutzername angegeben
    if StrEditUserName.GetLength() then
      
      // Position des Benutzers holen
      //-----------------------------------------------------------------------------------------
      tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:=StrEditUserName.DataBuffer.GetDataPtr(), pUser:=NIL);
      if (tmpPos >= 0) then
        
        pActUser := getUserToEdit(udPos:=to_udint(tmpPos));
        // Berechtigt um diesen Benutzer zu löschen?
        if (pActUser <> NIL) & (pActUser^.usUserLevel < ActLevel) then

          pActualVKUser := UsersBuffer;
          
          if tmpPos = 0 then
            // Letzten Benutzer speichern
            pBefore       := pActualVKUser;
          else
            while (tmpCount <> tmpPos) do
              tmpCount += 1;
              // Letzten Benutzer speichern
              pBefore       := pActualVKUser;
              // nächsten Benutzer holen
              pActualVKUser := pActualVKUser^.pNext;
            end_while;
          end_if;

          // Letztes Element
          if (pActualVKUser^.pNext = NIL) then
          
            // Speicher freigeben
            coSystem.Free(ptr0:=pActualVKUser);
            pBefore^.pNext := NIL;
            RefreshList.Write(input:=1);
            
          else
            
            // Speicher freigeben
            coSystem.Free(ptr0:=pActualVKUser);
            
            if tmpPos = 0 then
              pBefore := pActualVKUser^.pNext; 
              UsersBuffer := pBefore;
            else
              pBefore^.pNext := pActualVKUser^.pNext; 
            end_if;

          end_if;;
        
          udNumberOfUsers -= 1;
          pActualVKUser   := NIL;
          if udNumberOfUsers = 0 then
            UsersBuffer := NIL;
          end_if;
          refreshUserFile();
        
        else
          MESSAGE(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
          InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        end_if;
        
      else
        MESSAGE(dMSGNumber:=ERR_USER_NOTEXIST);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      end_if;
      
    else
      MESSAGE(dMSGNumber:=ERR_NO_NAME);
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    end_if;
    
  else
    MESSAGE(dMSGNumber:=ERR_DELUSER);
    InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
  end_if;
  
END_FUNCTION
  

FUNCTION GLOBAL AccessControlMain::ShowUserData
  VAR
    tmpPos    : DINT;
    tmpUser   : t_s_User;
  END_VAR
  
  tmpPos := -1;

  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if StrEditUserName.GetLength() then
  
      // Position des Benutzers holen
      //-----------------------------------------------------------------------------------------
      tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:=StrEditUserName.DataBuffer.GetDataPtr(), pUser:=#tmpUser);
      if tmpPos >= 0 then
      
        // Benutzerdaten kopieren
        StrEditUserName.WriteDataOff(udLen:=_strlen(#tmpUser.aUsername[0]), udOff:=0, pData:=#tmpUser.aUsername[0]);
        StrEditPasswordOld.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPassword.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPassword2.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditInfo.WriteDataOff(udLen:=_strlen(#tmpUser.aUserInfo[0]), udOff:=0, pData:=#tmpUser.aUserInfo[0]);
        ELevel   := tmpUser.usUserLevel;
        ETimeOut := tmpUser.udUserTimeout;
        
      else
        
        // Leere Daten kopieren
        StrEditUserName.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPasswordOld.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPassword.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPassword2.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditInfo.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        ELevel   := 0;
        ETimeOut := 0;
        
        MESSAGE(dMSGNumber:=ERR_USER_NOTEXIST);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        
      end_if;
    
  else
  
    MESSAGE(dMSGNumber:=ERR_NO_NAME);
    InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::ChangePassword
	VAR_INPUT
		bAdmin 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bRet 	: BOOL;
	END_VAR
  VAR
  	tmpUserName   : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpPassword   : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpPWControl  : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpUser       : t_s_User;
    pActUser      : ^t_s_User;
    tmpPos        : DINT;
    tmpPW1Length  : UDINT;
    tmpPW2Length  : UDINT;
  END_VAR
  
  bRet            := false;
  tmpUserName[0]  := 0;
  tmpPassword[0]  := 0;
  tmpPWControl[0] := 0;
  pActUser        := NIL;
  tmpPos          := 0;
  
  // Benutzer eingeloggt oder Benutzerverwaltung
  //-----------------------------------------------------------------------------------------
  if (UserIsLoggedIn = true) | (bAdmin = true) then
    
    // Benutzername und Passwörter holen
    if (bAdmin = true) then
      StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
    else
      StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    end_if;
    tmpPW1Length := StrEditPassword.GetLength()+1;
    tmpPW2Length := StrEditPassword2.GetLength()+1;
    StrEditPassword.GetDataAt(pData:=#tmpPassword[0], udSize:=tmpPW1Length, udAt:=0);
    StrEditPassword2.GetDataAt(pData:=#tmpPWControl[0], udSize:=tmpPW2Length, udAt:=0);
    
    // Soll das PW geändert werden?
    //-----------------------------------------------------------------------------------------
    if (tmpPW1Length > 1) & (tmpPW2Length > 1) then
    
      // Geändertes Passwort richtig eingegeben?
      //-----------------------------------------------------------------------------------------
      if (StrCmp(p0:=#tmpPassword[0], x1:=sizeof(tmpPassword[0]), p2:=#tmpPWControl[0], x3:=sizeof(tmpPWControl[0])) = 0) then
        
        // Position des Benutzers holen
        tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:= #tmpUserName[0], pUser:=#tmpUser);
        if (tmpPos >= 0) then
                  
          // Benutzerdaten anhand der Position holen und neues Passwort setzen
          //-----------------------------------------------------------------------------------------
          pActUser := getUserToEdit(udPos:=to_udint(tmpPos));
          if (pActUser <> NIL) then
          
            StrNCpy(p0 := #pActUser^.aUserPassword[0], 
                    x1 := sizeof(pActUser^.aUserPassword[0]), 
                    p2 := #tmpPassword[0], 
                    x3 := sizeof(tmpPassword[0]), 
                    ml := AccessControl_MaxPasswordLength);
            if (bAdmin = false) then
              refreshUserFile();
            end_if;
            MESSAGE(dMSGNumber:=MSG_PWCHANGE_OK);
            InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
            bRet := true;
            
          end_if;
          
        else
        
          MESSAGE(dMSGNumber:=ERR_USER_NOTEXIST);
          InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        
        end_if;
        
      else
      
        MESSAGE(dMSGNumber:=ERR_WRONG_PWCHANGE);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      
      end_if;
    
    else
      
      // Passwort nicht geändert
      bRet := FALSE;
      
    end_if;
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AccessControlMain::SelectFunction::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
 
	SelectFunction := input;

  //*****************************************************************************
  //** Jeweilige Funktion ausgewählt                                           **
  //*****************************************************************************
  case SelectFunction of
    
    // Legt einen neuen Benutzer an
    1:  AddUser();
        clearServers();
    
    // Löscht den ausgewählten Benutzer
    2:  DeleteUser();
        clearServers();
    
    // Bearbeitet den ausgewählten Benutzer
    3:  EditUser();
        clearServers();
    
    // Login
    4:  Login();
        clearServers();
    
    // Logout
    5:  Logout();
        clearServers();
    
    // Schreibt die Benutzerdaten des ausgewählten Benutzers auf die Server zum Bearbeiten
    6:  ShowUserData();
    
    // Ändert das Passwort des ausgewählten Benutzers
    7:  ChangePassword(bAdmin:=false);
        clearServers();
    
    // Verknüpft die Seriennummer des aktuellen Speichermediums mit dem eingeloggten Benutzer
    8:  AddUsbSN();
        clearServers();
    
    // Verknüpft die Seriennummer des aktuellen Speichermediums mit dem eingeloggten Benutzer
    9:  AddUsbSNbyUser();
        clearServers();
    
    // Löscht die Verknüpfung der Seriennummer mit dem aktuellen Speichermedium
    10: DelUsbSN();
        clearServers();
       
    // Löscht alle Benutzerdaten auf den Servern
    11: clearServers();
        
    
    // Springt auf den vorherigen Bildschirm
    12: closeScreen();
    
    
  end_case;

 	result := SelectFunction;
  SelectFunction := 0;

END_FUNCTION


FUNCTION AccessControlMain::SearchUser
	VAR_INPUT
		pBuffer 	: ^t_s_VKUser;
		pUserName 	: ^USINT;
		pUser 	: ^t_s_User;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpPos        : DINT;
    pActualVKUser : ^t_s_VKUser;
  END_VAR
  
  retcode := -1;
  
  if pBuffer = NIL then
    return;
  end_if;;  
  
  tmpPos  := 0;
  
  pActualVKUser := pBuffer; 
  
  // Benutzer anhand des Benutzernamens suchen
  //-----------------------------------------------------------------------------------------
  while (pActualVKUser <> NIL) do
  
    tmpPos += 1;
    if StrCmp(p0:=#pActualVKUser^.User.aUsername[0], x1:=sizeof(pActualVKUser^.User.aUsername[0]), p2:=pUserName, x3:=sizeof(_ASCII)) = 0 then
      
      // Benutzerdaten zurückgeben
      if pUser <> NIL then
        pUser^ := pActualVKUser^.User;
      end_if;

      retcode := tmpPos-1;
      exit;
      
    else
    
      pActualVKUser := pActualVKUser^.pNext;
      retcode       := -1;
    
    end_if;
    
  end_while;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::Login
  VAR
    tmpUser      : t_s_User;
    tmpUserName  : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpPassword  : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpScreenInfo : ^_PRJ_ENTRY;    
  END_VAR
  
  tmpUserName[0] := 0;
  tmpPassword[0] := 0;

  // Benutzername und Passwort holen
  StrLoginUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrLoginUserName.GetLength()+1, udAt:=0);
  StrLoginPassword.GetDataAt(pData:=#tmpPassword[0], udSize:=StrLoginPassword.GetLength()+1, udAt:=0);
  
  // Benutzername angegeben?
  //-----------------------------------------------------------------------------------------
  if StrLoginUserName.GetLength() then
  (*
    // Administrator holen
    if UsersBuffer = NIL then
        
      //UsersBuffer$^void := coSystem.Malloc(sizeof(t_s_VKUser));
      //UsersBuffer^.pNext := NIL;
      //tmpUser := UsersBuffer^.User;
      
    else
    
      tmpUser := UsersBuffer^.User;
    
    end_if;
    *)
    
    _memset(dest:=#tmpUser, usByte:=0, cntr:=sizeof(t_s_User));
    
    // Wenn der Benutzer existiert oder sich der Administrator einloggt
    //-----------------------------------------------------------------------------------------
    if (SearchUser(pBuffer := UsersBuffer, pUserName:=#tmpUserName[0], pUser:=#tmpUser) >= 0) | 
       (SearchUser(pBuffer := StandardUser, pUserName:=#tmpUserName[0], pUser:=#tmpUser) >= 0) then
     
      // Passwort überprüfen
      if StrCmp(p0:=#tmpUser.aUserPassword[0], x1:=sizeof(tmpUser.aUserPassword[0]), p2:=#tmpPassword[0], x3:=sizeof(tmpPassword[0])) = 0 then
        
        // Wenn ein anderer Benutzer eingeloggt ist, diesen ausloggen
        if (UserIsLoggedIn = true) then
          bLogoutOldUser := true;
          Logout();
          bLogoutOldUser := false;
        end_if;
        Reload := 1;
       
        // Neuen Benutzer einloggen
        StrActUser.WriteDataOff(udLen:=_strlen(#tmpUser.aUsername[0]), udOff:=0, pData:=#tmpUser.aUsername[0]);
        ActLevel       := tmpUser.usUserLevel;
        UserIsLoggedIn := true;
        
        // Login als Event speichern
        coEventQueue.AddUserLoginLogout(pUserName:=#tmpUser.aUsername[0], dActLevel:=ActLevel, bIsLogin := TRUE);
        
        // Zeit beim Login speichern (für Abmeldezeit)
        udTimeout := ops.tAbsolute;
        
        // Soll Benutzer-Level überprüft werden?
        if (bdAccessConfig.IgnoreScreenAccess = 0) then
          
          // Neuer Benutzer berechtigt auf diesem Screen zu sein?
          tmpScreenInfo := Prj_GetEntryByNo(x0:=to_uint(ActScreenNr.Read()), x1:=_PE_PICTURE);
          if (tmpScreenInfo <> NIL) & (tmpScreenInfo^.access > ActLevel) then
            bCloseScreen := true;
            closeScreen();
            MESSAGE(dMSGNumber:=ERR_NO_SCREEN_ACCESS);
            InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
            return;
          end_if;
          
        end_if;
    
        // Seite refreshen
        if ActScreenNr.Read() <> 0 then
          InsertCmd(x0:=CMD_NEWPICTURE, x1:=to_dint(ActScreenNr.Read()), x2:=0);
        else
          InsertCmd(x0:=CMD_NEWPICTURE, x1:= NextScreen, x2:=0); // Go always to first screen
        end_if;
      else
      
        MESSAGE(dMSGNumber:=ERR_WRONG_PASS);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        
      end_if;
    
    else
    
      MESSAGE(dMSGNumber:=ERR_USER_NOTEXIST);
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    
    end_if;
    
  else
    
    MESSAGE(dMSGNumber:=ERR_NO_NAME);
    InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::Logout
  VAR
    tmpUserName  : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpScreenInfo : ^_PRJ_ENTRY;
  END_VAR
  
  // Logout als Event speichern
  //-----------------------------------------------------------------------------------------
  tmpUserName[0] := 0;  
  StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
  coEventQueue.AddUserLoginLogout(pUserName:=#tmpUserName[0], dActLevel:=ActLevel, bIsLogin := FALSE);
  
  // Aktuelle Benutzerdaten zurücksetzen
  //-----------------------------------------------------------------------------------------
  StrActUser.WriteDataOff(udLen:=1, udOff:=0, pData:="");
  ActLevel        := 0;
  UserIsLoggedIn  := false;
  LoggedInWithUsb := false;
  
  // Soll Benutzer-Level überprüft werden?
  if bdAccessConfig.IgnoreScreenAccess = 0 then
    
    // Benutzer berechtigt auf diesem Bildschirm zu sein?
    tmpScreenInfo := Prj_GetEntryByNo(x0:=to_uint(ActScreenNr.Read()), x1:=_PE_PICTURE);
    if (bLogoutOldUser = false) & (tmpScreenInfo <> NIL) & (tmpScreenInfo^.access > ActLevel) then
      bCloseScreen := true;
      closeScreen();
      MESSAGE(dMSGNumber:=ERR_NO_SCREEN_ACCESS);
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION AccessControlMain::clearServers

  // Alle Server zurücksetzen/löschen
  //-----------------------------------------------------------------------------------------
  StrEditPasswordOld.Clear();
  StrEditPassword.Clear();
  StrEditPassword2.Clear();
  StrEditUserName.Clear();
  StrEditInfo.Clear();
  StrLoginPassword.Clear();
  StrLoginUserName.Clear();
  ELevel   := 0;
  ETimeOut := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AccessControlMain::MESSAGE
	VAR_INPUT
		dMSGNumber 	: DINT;
	END_VAR
  
  // Info für Pop-Up Fenster in der Visualisierung 
  MSGNr := dMSGNumber;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::getUserDataByNr
	VAR_INPUT
		udUserNr 	: UDINT;
		pUser 	: ^t_s_User;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpPos        : UDINT;
    pActualVKUser : ^t_s_VKUser;
  END_VAR
  
  tmpPos  := 0;
  pActualVKUser := UsersBuffer; 
  
  // Übergabeparameter ok?
  //-----------------------------------------------------------------------------------------
  if (pUser <> NIL) & (udUserNr >= 0) then
  
    // Benutzer anhand der Nummer suchen
    //-----------------------------------------------------------------------------------------
    while (tmpPos <> udUserNr) & (pActualVKUser <> NIL) & (pActualVKUser^.pNext <> NIL) do

      tmpPos        += 1;
      pActualVKUser := pActualVKUser^.pNext;
      
    end_while;
    
    // Gefundene Benutzerdaten gültig?
    //-----------------------------------------------------------------------------------------
    if (pActualVKUser <> NIL) then
      pUser^  := pActualVKUser^.User;
      retcode := 0;
    else
      retcode := -1;
    end_if;
    
  else
  
    retcode := -1;
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::getNumberOfUsers
	VAR_OUTPUT
		udUsers 	: UDINT;
	END_VAR
  
  udUsers := udNumberOfUsers;

END_FUNCTION


FUNCTION AccessControlMain::getUserToEdit
	VAR_INPUT
		udPos 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pUser 	: ^t_s_User;
	END_VAR
  VAR
  	pActualVKUser : ^t_s_VKUser;
    tmpCount      : UDINT;
  END_VAR
  
  pActualVKUser := UsersBuffer;
  tmpCount := 0;
  pUser    := NIL;
  
  // Suche Benutzer anhand der Position
  //-----------------------------------------------------------------------------------------
  while (pActualVKUser <> NIL) & (tmpCount <> udPos) do
    tmpCount += 1;
    pActualVKUser := pActualVKUser^.pNext;
  end_while;
  
  // Benutzerdaten zurückgeben (nicht den Administrator -> pos = 0) 
  //-----------------------------------------------------------------------------------------
  if tmpCount >= 0 then
    pUser := #pActualVKUser^.User;
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::RegisterAccessList
	VAR_INPUT
		pNewAccessList 	: ^AccessControlList;
	END_VAR
  VAR
  	pHelp  : ^t_s_VKAccessLists;
  END_VAR
  
  // Registrierte Zugriffsliste für Aktualisierung
  //-----------------------------------------------------------------------------------------
  if pNewAccessList <> NIL then
    
    // Speicher leer
    if pAccessListsBuffer = NIL then
    
      pAccessListsBuffer$^void := coSystem.Malloc(size0:=sizeof(t_s_VKAccessLists));
      if pAccessListsBuffer = NIL then
        MESSAGE(dMSGNumber:=ERR_MEMORY);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        if IsCon_coSystemLogging = TRUE then
          coSystemLogging.LogEventText("AccessControlMain::RegisterAccessList(): Fehler beim allokieren des Speichers" );
        end_if;
        return;
      end_if;
      pAccessListsBuffer^.AccessList := pNewAccessList;
      pAccessListsBuffer^.pNext      := NIL;
    
    else
      
      // Das Ende der Liste finden
      pHelp := pAccessListsBuffer;
      while (pHelp^.pNext <> NIL) do
        pHelp := pHelp^.pNext;
      end_while;
      
      // Speicher für die Zugriffsliste allokieren
      pHelp^.pNext$^void := coSystem.Malloc(size0:=sizeof(t_s_VKAccessLists));
      if pHelp^.pNext = NIL then
        MESSAGE(dMSGNumber:=ERR_MEMORY);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        if IsCon_coSystemLogging = TRUE then
          coSystemLogging.LogEventText("AccessControlMain::RegisterAccessList(): Fehler beim allokieren des Speichers" );
        end_if;
        return;
      end_if;
      pHelp^.pNext^.AccessList := pNewAccessList;
      pHelp^.pNext^.pNext      := NIL;
      
    end_if;
  end_if;

END_FUNCTION


FUNCTION AccessControlMain::AccessControlMain
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
  // Server
  LoggedInWithUsb     := false;
  UserIsLoggedIn      := false;
  ELevel              := 0;
  ETimeOut            := 0;
  // Variablen
  pAccessListsBuffer  := NIL;
  UsersBuffer  := NIL;
  StandardUser := NIL;
  udNumberOfUsers     := 0;
  dErrorCode          := MSG_NO_ERR;
  
	ret_code            := C_OK;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::NewStick
	VAR_INPUT
		pSerNum 	: ^void;
	END_VAR
  VAR
  	User : t_s_User;
  END_VAR

  StrEditUsbSN.WriteDataOff(udLen:=_strlen(pSerNum$^CHAR), udOff:=0, pData:=pSerNum$^CHAR);
  
  // Seriennummer des USB-Sticks mit vorhandenen Benutzerdaten vergleichen
  //-----------------------------------------------------------------------------------------
  if SearchUserbyUsbSN(#User) >= 0 then
  
    StrLoginUserName.WriteDataOff(udLen:=_strlen(#User.aUsername[0]), udOff:=0, pData:=#User.aUsername[0]);
    StrLoginPassword.WriteDataOff(udLen:=_strlen(#User.aUserPassword[0]), udOff:=0, pData:=#User.aUserPassword[0]);
    Login();
    clearServers();
    LoggedInWithUsb := true;
  
  elsif !!bUsersBufferAllocated then
    bNewStickAtStart := TRUE;
    aPerSerNum := pSerNum$^t_a_USB_SERIAL^;
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::StickRemoved
	VAR_INPUT
		pSerNum 	: ^void;
	END_VAR
  VAR
  	tmpUser     : t_s_User;
    tmpUserName : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
  END_VAR
  
  tmpUserName[0] := 0;  
  
  // Nur wenn ein Benutzer mit dem USB-Stick eingeloggt ist
  //-----------------------------------------------------------------------------------------
  if (LoggedInWithUsb = true) then
  
    StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    
    // Benutzerdaten holen
    if (SearchUser(pBuffer := UsersBuffer, pUserName:=#tmpUserName[0], pUser:=#tmpUser) >= 0) then
      
      // Wenn die Seriennummer identisch ist
      if (StrCmp(p0:=#tmpUser.USBSerial[0], x1:=sizeof(tmpUser.USBSerial[0]), p2:=pSerNum$^CHAR, x3:=sizeof(_ASCII)) = 0) then
      
        Logout();
        clearServers();
        LoggedInWithUsb := false;

      end_if;
  
    end_if;
  
  end_if;
  
  StrEditUsbSN.Clear(); 

END_FUNCTION


FUNCTION AccessControlMain::SearchUserbyUsbSN
	VAR_INPUT
		pUser 	: ^t_s_User;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpPos        : DINT;
    pActualVKUser : ^t_s_VKUser;
    tmpEditUsbSN  : Array[0..AccessControl_MaxUSBSNLength] of CHAR;
  END_VAR
  
  retcode         := -1;
  tmpPos          := 0;
  tmpEditUsbSN[0] := 0;
  pActualVKUser   := UsersBuffer;
  
  if pActualVKUser = NIL then
    return;
  end_if; 
  
  StrEditUsbSN.GetDataAt(pData:=#tmpEditUsbSN[0], udSize:=StrEditUsbSN.GetLength()+1, udAt:=0); 
  
  // Nach der Seriennummer suchen
  //-----------------------------------------------------------------------------------------
  while pActualVKUser <> NIL do
    
    tmpPos += 1;
    // Gleiche Seriennummer gefunden
    if StrCmp(p0:=#pActualVKUser^.User.USBSerial[0], x1:=sizeof(pActualVKUser^.User.USBSerial[0]), p2:=#tmpEditUsbSN[0], x3:=sizeof(tmpEditUsbSN[0])) = 0 then
      
      // Benutzerdaten holen
      if (pUser <> NIL) then
        pUser^ := pActualVKUser^.User;
      end_if;
      
      retcode := tmpPos-1;
      exit;
      
    else
    
      pActualVKUser := pActualVKUser^.pNext;
      retcode := -1;
    
    end_if;
    
  end_while;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::AddUsbSNbyUser
  VAR
    tmpUserName : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
  END_VAR
  
  tmpUserName[0] := 0;
  
  // Eingeloggten Benutzer mit der Seriennummer des USB-Sticks verknüpfen
  //-----------------------------------------------------------------------------------------
  if (UserIsLoggedIn = true) then
  
    StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    StrEditUserName.WriteDataOff(udLen:=_strlen(#tmpUserName[0]), udOff:=0, pData:=#tmpUserName[0]);
    AddUsbSN();
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::AddUsbSN
  VAR
    tmpPos      : DINT;
    pActUser    : ^t_s_User;
    pOldUserSN      : ^t_s_User; 
    tmpUserName     : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpActUserName  : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpNewPos       : DINT;
    tmpOwnUser      : UINT;
  END_VAR
  
  if UserIsLoggedIn then
    StrActUser.GetDataAt(pData:=#tmpActUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
  end_if;
  
  tmpPos          := 0;
  pActUser        := NIL;
  tmpUserName[0]  := 0;
  tmpNewPos       := 0;
  
  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if StrEditUserName.GetLength() then
  
    // Benutzername und dessen Position holen
    StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
    tmpNewPos := SearchUser(pBuffer := UsersBuffer, pUserName:= #tmpUserName[0], pUser:=NIL);
    
    // Benutzer gefunden
    //-----------------------------------------------------------------------------------------
    if (tmpNewPos >= 0) then
    
      // Wenn ein USB-Stick mit einem Benutzer verknüpft werden soll, muss der Benutzer manuell eingeloggt sein
      if (LoggedInWithUsb = false) & (StrEditUsbSN.GetLength() > 0) then
        
        //Benutzerdaten anhand der Position holen
        pActUser := getUserToEdit(udPos:=to_udint(tmpNewPos));
        tmpOwnUser := (StrCmp(p0:=#pActUser^.aUsername[0], x1:=sizeof(pActUser^.aUsername[0]), p2:=#tmpActUserName[0], x3:=sizeof(tmpActUserName[0])));
        if (pActUser <> NIL) & ((pActUser^.usUserLevel < ActLevel) | (tmpOwnUser = 0)) then
        
          // Wenn dieser USB-Stick schon mit einem anderen Benutzer verknüpft ist, lösche diese Verbindung
          tmpPos := SearchUserbyUsbSN(pUser:=NIL);
          if (tmpPos >= 0) then
            // Benutzerdaten anhand der Position holen
            pOldUserSN := getUserToEdit(udPos:=to_udint(tmpPos));
            if (StrCmp(p0:=#pActUser^.USBSerial[0], x1:=sizeof(pActUser^.USBSerial[0]), p2:=#pOldUserSN^.USBSerial[0], x3:=sizeof(pOldUserSN^.USBSerial[0])) <> 0) then
             
              if (pOldUserSN <> NIL) & ((pOldUserSN^.usUserLevel < ActLevel) | (StrCmp(p0:=#pOldUserSN^.aUsername[0], x1:=sizeof(pOldUserSN^.aUsername[0]), p2:=#tmpActUserName[0], x3:=sizeof(tmpActUserName[0])) = 0)) then
                pOldUserSN^.USBSerial[0] := 0;
              else
                MESSAGE(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
                InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
                return;
              end_if;
             
            else
              MESSAGE(dMSGNumber:=ERR_USB_SERNUM);
              InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
            end_if;
           
          end_if;
          
          // Seriennummer des USB-Sticks speichern
          StrEditUsbSN.GetDataAt(pData:=#pActUser^.USBSerial[0], udSize:=StrEditUsbSN.GetLength()+1, udAt:=0);
          refreshUserFile();
        
        else
        
          MESSAGE(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
          InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      
        end_if;
      else
        
        MESSAGE(dMSGNumber:=ERR_USB_SERNUM);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      
      end_if;
      
    else
    
      MESSAGE(dMSGNumber:=ERR_USER_NOTEXIST);
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    
    end_if;
    
  else
      
    MESSAGE(dMSGNumber:=ERR_NO_NAME);
    InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    
  end_if;
      
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AccessControlMain::IF_WindowEnd
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
	END_VAR
  
  // Alle Server beim Schließen eines Fensters zurücksetzen
  //-----------------------------------------------------------------------------------------
  if (whoami^.ima <> IMA_TOUCHEDITOR) then
  
    clearServers();
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlMain::DelUsbSN
  VAR
    tmpPos         : DINT;
    tmpOwnUser     : UINT;
    pActUser       : ^t_s_User;
    tmpUserName    : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpActUserName : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
  END_VAR
  
  tmpPos            := 0;
  pActUser          := NIL;
  tmpUserName[0]    := 0;
  tmpActUserName[0] := 0;
  
  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if StrEditUserName.GetLength() then
  
    StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
    StrActUser.GetDataAt(pData:=#tmpActUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    
    // Position des Benutzers holen
    tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:=#tmpUserName[0], pUser:=NIL);
    if (tmpPos >= 0) then
      
      // Benutzerdaten anhand der Position holen
      pActUser := getUserToEdit(to_udint(tmpPos));
      tmpOwnUser := (StrCmp(p0:=#tmpUserName[0], x1:=sizeof(tmpUserName[0]), p2:=#tmpActUserName[0], x3:=sizeof(tmpActUserName[0])));
      if (pActUser <> NIL) & ((tmpOwnUser) | ((tmpOwnUser = 0) & (LoggedInWithUsb = 0))) &
         (StrLen(txt:=#pActUser^.USBSerial[0], size:=sizeof(pActUser^.USBSerial[0])) <> 0) then
        
        // Berechtigt um diesen Benutzer zu bearbeiten bzw. den eigenen Benutzer bearbeiten 
        if ((pActUser^.usUserLevel < ActLevel) | (tmpOwnUser = 0)) then
          pActUser^.USBSerial[0] := 0;
          refreshUserFile();     
        else
          MESSAGE(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
          InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        end_if;     

      else
        
        MESSAGE(dMSGNumber:=ERR_DEL_USB_SERNUM);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      
      end_if;
      
    else
      
      MESSAGE(dMSGNumber:=ERR_USER_NOTEXIST);
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        
    end_if;
    
  else
      
    MESSAGE(dMSGNumber:=ERR_NO_NAME);
    InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AccessControlMain::CopyUserFile::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
    tmpExtDriveLetter : ARRAY[0..AccessControl_MaxUserFilePathLength] of CHAR;
    tmpFileCpy        : DINT;
  END_VAR

	CopyUserFile := input;
	result := CopyUserFile;
  
  
  // Exportieren/Importieren der Benutzerdatei auf einen USB-Speicher 
  //-----------------------------------------------------------------------------------------
  if (CopyUserFile <> 0) then
    
    // USB-Speichermedium auch angeschlossen?
    //-----------------------------------------------------------------------------------------
    if coDriveLetter.GetLength() then
      
      tmpExtDriveLetter[0] := 0;
      coDriveLetter.GetDataAt(pData:=#tmpExtDriveLetter[0], udSize:=coDriveLetter.GetLength()+1, udAt:=0);
      StrNCpy(p0:=#tmpExtDriveLetter[AccessControl_DriveLetterLength], 
              x1:=sizeof(tmpExtDriveLetter[0]), 
              p2:=AccessControl_UserFile, 
              x3:=sizeof(_ASCII), 
              ml:=AccessControl_MaxUserFilePathLength);
      
      // Bestehende Datei der Benutzerdaten auf entsprechendes Laufwerk kopieren
      //-----------------------------------------------------------------------------------------
      if (CopyUserFile > 0) then
        // Exportieren der Benutzerdatei auf einen USB-Speicher 
        tmpFileCpy := coFileSys.FileCopy(pSource:=AccessControl_InitDriveLetter, pDest:=#tmpExtDriveLetter[0], udOption:=0);
      elsif (CopyUserFile < 0) then
        // Importieren der Benutzerdatei von einem USB-Speicher 
        tmpFileCpy := coFileSys.FileCopy(pSource:=#tmpExtDriveLetter[0], pDest:=AccessControl_InitDriveLetter, udOption:=0);
      end_if;
      
      // Kopieren der Benutzerdaten erfolgreich?
      if (tmpFileCpy <> 0) then
        MESSAGE(dMSGNumber:=ERR_COPYUSERS);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
        if IsCon_coSystemLogging = TRUE then
          coSystemLogging.LogEventText("AccessControlMain::CopyUserFile::Write(): Kopieren der Benutzerdaten fehlgeschlagen" );
        end_if;
      elsif (CopyUserFile > 0) & (tmpFileCpy = 0) then
        MESSAGE(dMSGNumber:=MSG_EXPORT_USERS_OK);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      elsif (CopyUserFile < 0) & (tmpFileCpy = 0) then
        MESSAGE(dMSGNumber:=MSG_IMPORT_USERS_OK);
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      end_if;
      
    else
    
      MESSAGE(dMSGNumber:=ERR_NO_DRIVE);
      InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      
    end_if;
    
    // Server zurücksetzen
    CopyUserFile := 0;
    
  end_if;


END_FUNCTION


FUNCTION AccessControlMain::closeScreen
    
  // Benutzer befindet sich auf einem Screen, ohne korrekte Zugangsberechtigung
  if (bCloseScreen = true & (bdAccessConfig.IgnoreScreenAccess = 0)) then  
    
    // Kehre zum Start-Bildschirm zurück
    InsertCmd(x0:=CMD_NEWPICTURE, x1:=coGlobal.GetStartPicture(), x2:=0);
    bCloseScreen := false;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL AccessControlMain::CreateAdmin
	VAR_INPUT
		pUsername 	: ^CHAR;
		pPassword 	: ^CHAR;
		usLevel 	: USINT;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  
  //Rückgabewert initialisieren
  bSuccessful := FALSE;
  
  if StandardUser = NIL then
        
    StandardUser$^void := coSystem.Malloc(sizeof(t_s_VKUser));
    StandardUser^.pNext := NIL;
    
  end_if;  
  
  //Benutzerdaten gültig?
  if (pUsername <> NIL) & (pPassword <> NIL) & (usLevel <> NIL) then
  
    StrNCpy(p0 := #StandardUser^.User.aUsername[0], 
            x1 := sizeof(StandardUser^.User.aUsername[0]), 
            p2 := pUsername,                          
            x3 := sizeof(_ASCII),
            ml := AccessControl_MaxUsernameLength);
    StrNCpy(p0 := #StandardUser^.User.aUserPassword[0], 
            x1 := sizeof(StandardUser^.User.aUserPassword[0]), 
            p2 := pPassword,                                  
            x3 := sizeof(_ASCII), 
            ml := AccessControl_MaxPasswordLength);
    StandardUser^.User.usUserLevel   := usLevel;       
    StandardUser^.User.udUserTimeout := 0;
      
     bSuccessful := true;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AccessControlMain::IF_ChkEnable
	VAR_INPUT
		key 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := false;
  
  // Zugangsebenen deaktiviert (frei zugänglich)
  //-----------------------------------------------------------------------------------------
  if (Deactivate = true) then
  
    retcode := true;
  
  // Zugangscode prüfen
  //-----------------------------------------------------------------------------------------
  elsif (ActLevel >= key) then
  
    retcode := true;
 
  end_if;

END_FUNCTION

FUNCTION GLOBAL AccessControlMain::ReloadRecipe
	VAR_INPUT
		ReadValue 	: DINT;
	END_VAR
	VAR_OUTPUT
		State 	: DINT;
	END_VAR
  
  if ReadValue = 1 then
    Reload := 0;
  end_if;
  
  State := Reload; 

END_FUNCTION
