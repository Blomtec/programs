//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "DiagnosticWork_PLC"
	Revision           = "1.0"
	GUID               = "{66A0F0CE-472D-47A6-B3D4-4018EACC720D}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(478,120)"
	Comment            = "This class starts and controls the work. It starts the user function when the command is received or it sends commands to another station to start the work.">
	<Channels>
		<Server Name="sStatus" GUID="{B9DFA269-150E-4313-A5A4-482708132731}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual status."/>
		<Client Name="cToCom" Required="true" Internal="false" Comment="Object channel to SendDataCMD_PLC."/>
		<Client Name="cUserFunction" Required="true" Internal="false" Comment="Connect this client to the user function."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.0" Date="2016-06-02" Author="HötAnt" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
</Class>
*)
DiagnosticWork_PLC : CLASS
	TYPE
#pragma pack(push, 1)
	  _JobState : STRUCT
	    JobID : DINT;
	    State : BOOL;
	  END_STRUCT;
#pragma pack(pop)
	  _SSW_DWPLC :
	  (
	    DWPLC_WaitForTrigger,
	    DWPLC_CallStartWork,
	    DWPLC_CallWorkMethode,
	    DWPLC_SendAnswerSuccess,
	    DWPLC_CheckSendingSuccess,
	    DWPLC_SendAnswerError,
	    DWPLC_CheckSendingError
	  )$UDINT;
	END_TYPE
  //Servers:
	sStatus 	: SvrChCmd_iprStates;
  //Clients:
	cUserFunction 	: CltChCmd_DiagnosticUserFunction_PLC;
	cToCom 	: CltChCmd_SendDataCMD_PLC;
  //Variables:
		ssw_Collector 	: _SSW_DWPLC;
		SendDataPtr 	: ^void;			//! <Variable Comment="Pointer to the data which will be send." Name="SendDataPtr"/>
		JobState 	: _JobState;
		SendDataSize 	: UDINT;
		TempJobID 	: DINT;
		TempFault 	: _DiagErrorCode;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Receive data." Name="ReceivedData"/>
	FUNCTION VIRTUAL GLOBAL ReceivedData
		VAR_INPUT
			size 	: UDINT;			//! <Variable Comment="Size of the received data." Name="ReceivedData.size"/>
			pdata 	: ^USINT;			//! <Variable Comment="Pointer to the received data." Name="ReceivedData.pdata"/>
			OptCMD 	: USINT;			//! <Variable Comment="Optional command." Name="ReceivedData.OptCMD"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="FALSE..Error&#13;&#10;TRUE..Data received" Name="ReceivedData.retcode"/>
		END_VAR;
				//! <Function Comment="Save Job ID and JobState in a membervariable." Name="ResponseJobState"/>
	FUNCTION GLOBAL ResponseJobState
		VAR_INPUT
			JobID 	: DINT;			//! <Variable Comment="Job ID." Name="ResponseJobState.JobID"/>
			SendOK 	: BOOL;			//! <Variable Comment="State of the job." Name="ResponseJobState.SendOK"/>
		END_VAR;
				//! <Function Comment="Get the actual state of the job." Name="GetJobState"/>
	FUNCTION GLOBAL GetJobState
		VAR_INPUT
			JobID 	: DINT;			//! <Variable Comment="ID of the job from which you want to get the state." Name="GetJobState.JobID"/>
		END_VAR
		VAR_OUTPUT
			SendOK 	: DINT;			//! <Variable Comment="-1..Error while sending&#13;&#10; 0..Wait for JobID&#13;&#10; 1..Sended&#13;&#10;" Name="GetJobState.SendOK"/>
		END_VAR;
				//! <Function Comment="Set the errorcode. This errorcode will be sent to the remote station if an error occurs." Name="SetError"/>
	FUNCTION SetError
		VAR_INPUT
			ErrorNr 	: DINT;			//! <Variable Comment="Error number." Name="SetError.ErrorNr"/>
			ErrorCode 	: DINT;			//! <Variable Comment="Error code." Name="SetError.ErrorCode"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd DiagnosticUserFunction_PLC
#pragma usingLtd SendDataCMD_PLC


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DiagnosticWork_PLC::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_DIAGNOSTICWORK_PLC
1$UINT, 0$UINT, (SIZEOF(::DiagnosticWork_PLC))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3804321695), "DiagnosticWork_PLC", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DiagnosticWork_PLC.sStatus.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3043700589), "sStatus", 
//Clients:
(::DiagnosticWork_PLC.cUserFunction.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(121626066), "cUserFunction", TO_UDINT(4200646535), "DiagnosticUserFunction_PLC", 1$UINT, 0$UINT, 
(::DiagnosticWork_PLC.cToCom.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1002087807), "cToCom", TO_UDINT(64911590), "SendDataCMD_PLC", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_DiagnosticWork_PLC 2

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DiagnosticWork_PLC] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DiagnosticWork_PLC::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DiagnosticWork_PLC, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #ReceivedData();

#pragma warning (default : 74)
	sStatus.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF sStatus.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL DiagnosticWork_PLC::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  
  case ssw_Collector of
    DWPLC_WaitForTrigger : // Wait for Trigger from HMI
    
    DWPLC_CallStartWork : // User Funktion aufrufen , das jetzt gestartet werden kann.
      sStatus := BUSY;
      case cUserFunction.StartWork() of
         Ready : // Aktion konnte gestartet werden , weiter mit Zyklischer Methode
                ssw_Collector :=DWPLC_CallWorkMethode;
      else
        // Error Code auslesen und raufschicken. !!!!
        TempFault := cUserFunction.GetErrorCode();
        cUserFunction.EndWork();
        ssw_Collector := DWPLC_SendAnswerError;
        sStatus := ERROR;
      end_case;
        
        
    DWPLC_CallWorkMethode : // USer Funktion Zyklisch aufrufen , bis bei GetWorkState Ready oder Error zurück kommt.
      
      cUserFunction.WorkMethode();
      // Prüfen ob Funktion fertig ist.
      case cUserFunction.GetWorkState() of
        
        Ready : // Daten vom User Abholen
                SendDataSize := cUserFunction.GetDataSize();
                SendDataPtr  := cUserFunction.GetDataPtr();
                if SendDataSize <> 0 then
                  if SendDataPtr <> NIL then
                    ssw_Collector := DWPLC_SendAnswerSuccess;
                  else
                    // Error Code raufschicken. !!!!
                    SetError(ErrorNr:=DENR_PLC_DataIncorrect, ErrorCode:=DECD_DataPointer);
                    cUserFunction.EndWork();
                    ssw_Collector := DWPLC_SendAnswerError;
                    sStatus := ERROR;
                  end_if;
                else
                  // Error Code raufschicken. !!!!
                  SetError(ErrorNr:=DENR_PLC_DataIncorrect, ErrorCode:=DECD_DataSize);
                  cUserFunction.EndWork();
                  ssw_Collector := DWPLC_SendAnswerError;
                  sStatus := ERROR;
                end_if;
                
        BUSY  : // warten bis Abarbeiung fertig ist.
            
        ERROR : // Error Code raufschicken. !!!!
                TempFault := cUserFunction.GetErrorCode();
                cUserFunction.EndWork();
                ssw_Collector := DWPLC_SendAnswerError;
                sStatus := ERROR;
                
      
      end_case;


    DWPLC_SendAnswerSuccess : // Send Response ( wennn alles gut gegangen ist )
      
      TempJobID := cToCom.SendData(pData:=SendDataPtr, length:=SendDataSize, timeout:=0, OptCMD:=Diagnostic_OptCMD_ResponseSuccesData);
      if TempJobID >=0 then
        ssw_Collector := DWPLC_CheckSendingSuccess;
      else
        // Error Code raufschicken. !!!!
        SetError(ErrorNr:=DENR_PLC_SendError, ErrorCode:=DECD_JobID);
        cUserFunction.EndWork();
        ssw_Collector := DWPLC_SendAnswerError;
        sStatus := ERROR;
      end_if;
        
   
    DWPLC_CheckSendingSuccess : // Wait for Callback of JobState ( wurd erfolgreich gesendet ) ResponseJobState 
      
      case GetJobState(JobID:= TempJobID ) of
        -1 :// Konnte nicht gesendet werden
            // Error Code raufschicken. !!!!
            SetError(ErrorNr:=DENR_PLC_SendError, ErrorCode:=JobState.State);
            cUserFunction.EndWork();
            ssw_Collector := DWPLC_SendAnswerError;
            sStatus := ERROR;
            
         0 :// noch keinen Callback bekommen.
         
         1 :// erfolgreich gesendet.
            cUserFunction.EndWork();
            ssw_Collector := DWPLC_WaitForTrigger;
            sStatus := READY;
      end_case;
      
    DWPLC_SendAnswerError : // Send Response ( wennn Fehler aufgetreten ist. )
      
      TempJobID := cToCom.SendData(pData:=#TempFault, length:=sizeof(TempFault), timeout:=0, OptCMD:=Diagnostic_OptCMD_ResponseError);
      if TempJobID >=0 then
        ssw_Collector := DWPLC_CheckSendingSuccess;
      else
        // Felermeldung noch ausgeben.
        sStatus := ERROR;
        ssw_Collector := DWPLC_WaitForTrigger;
      end_if;
        
   
    DWPLC_CheckSendingError : // Wait for Callback of JobState ( wurd erfolgreich gesendet ) ResponseJobState 
      
      case GetJobState(JobID:= TempJobID ) of
        -1 :// Konnte nicht gesendet werden
            sStatus := ERROR;
            ssw_Collector := DWPLC_WaitForTrigger;
            
         0 :// noch keinen Callback bekommen.
         1 :// erfolgreich gesendet.
            ssw_Collector := DWPLC_WaitForTrigger;
            sStatus := READY;
      end_case;
    
  end_case;


	state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiagnosticWork_PLC::ReceivedData
	VAR_INPUT
		size 	: UDINT;
		pdata 	: ^USINT;
		OptCMD 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := FALSE;
  
  if pdata <> NIL & size <> 0 then
    case OptCMD of
      Diagnostic_OptCMD_StartWorkOnPLC : // Start collecting Data
        ssw_Collector :=DWPLC_CallStartWork;
        retcode := TRUE;
    end_case;

  end_if;


END_FUNCTION

FUNCTION GLOBAL DiagnosticWork_PLC::ResponseJobState
	VAR_INPUT
		JobID 	: DINT;
		SendOK 	: BOOL;
	END_VAR
  
  // Statusmeldung für Background merken.
  JobState.JobID := JobID;
  JobState.State := SendOK;
  
END_FUNCTION

FUNCTION GLOBAL DiagnosticWork_PLC::GetJobState
	VAR_INPUT
		JobID 	: DINT;
	END_VAR
	VAR_OUTPUT
		SendOK 	: DINT;
	END_VAR
  
  // prüfen ob unser Job gemeint ist.
  if JobID = JobState.JobID then
    if JobState.State =FALSE then
      // Job konnte nicht gesendet werden.
      SendOK := -1;
    else
      // Job wurde korrekt gesendet.
      SendOK := 1;
    end_if;
  else
    // noch keine Antwort für unseren Job.
    SendOK := 0;
  end_if;
  

END_FUNCTION


FUNCTION DiagnosticWork_PLC::SetError
	VAR_INPUT
		ErrorNr 	: DINT;
		ErrorCode 	: DINT;
	END_VAR
  
  TempFault.ErrorNr := ErrorNr;
  TempFault.ErrorCode := ErrorCode;
  
END_FUNCTION
