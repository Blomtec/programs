//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "TCPComReceiveData"
	Revision           = "1.4"
	GUID               = "{D8F365DB-B165-47DD-BC88-7A9CD9B9E747}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	DefBackground      = "100 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(484,120)"
	Comment            = "this class is used for receiving data from a connected station">
	<Channels>
		<Server Name="Timeout" GUID="{5622CA77-BD29-4C93-8FDF-BB3F9F8990EB}" Visualized="false" Initialize="true" WriteProtected="true" Retentive="false" Comment="Timeout for the receiving process"/>
		<Client Name="coStdLib" Required="false" Internal="false" Comment="object channel to StdLib (don&apos;t connect!)"/>
		<Client Name="coSystemLogging" Required="false" Internal="false" Comment="object channel to SystemLogging (optional)"/>
		<Client Name="CriticalSection" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\TCPComReceiveData\SynchRdWr.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.4" Date="2016-05-19" Author="GreJoh" Company="Sigmatek" Description="Client coSystemLogging must not be connected."/>
		<Dokumentation Revision="1.3" Date="2015-09-29" Author="BraLis" Company="Sigmatek" Description="insert the method SystemLogging::LogEventText instead of TRACE-Messages"/>
		<Dokumentation Revision="1.2" Date="2015-04-16" Company="Sigmatek"/>
	</RevDoku>
	<Network Name="TCPComReceiveData">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{DF2B0B67-0B40-4564-80D6-3FECE38E629E}"
				Class      = "TCPComReceive"
				Position   = "(256,120)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="ID_Source"/>
					<Server Name="sRecvCnt"/>
					<Client Name="toDataManager"/>
				</Channels>
			</Object>
			<Object
				Name       = "CriticalSection"
				GUID       = "{7E759A79-3A43-45E8-A7D4-5EA0C980A804}"
				Class      = "CriticalSection"
				Position   = "(210,540)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.CriticalSection" Destination="CriticalSection.ClassSvr"/>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1044,210),(872,210),"/>
			<Connection Source="this.ID_Source" Destination="_base.ID_Source" Vertices="(1044,270),(872,270),"/>
			<Connection Source="this.sRecvCnt" Destination="_base.sRecvCnt" Vertices="(1044,330),(872,330),"/>
			<Connection Source="_base.toDataManager" Destination="this.toDataManager" Vertices="(256,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using TCPComReceive

TCPComReceiveData : CLASS
: TCPComReceive
	TYPE
	  t_e_SendSteps :
	  (
	    TCPComSend_Idle,
	    TCPComSend_SendData,
	    TCPComSend_WaitAck
	  )$UDINT;
	  t_e_Startup :
	  (
	    Startup_WaitOnline,
	    Startup_GetData,
	    Startup_Send
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_CBCount : STRUCT
	    udSending : DINT;
	    udSended : DINT;
	    udReceived : DINT;
	    udNoReceiverConnected : DINT;
	    udJobDeleted : DINT;
	    udTimeout : DINT;
	    udGlobalReceiveError : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Data : STRUCT
	    udID : UDINT;
	    pValue : ^void;
	    udLength : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SendData : STRUCT
	    bActive : BOOL;
	    udElements : UDINT;
	    aData : ARRAY [0..SynchRdWr_MaxObjects-1] OF t_s_Data;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Timeout 	: SvrCh_UDINT;
  //Clients:
	coStdLib 	: CltChCmd__StdLib;
	CriticalSection 	: CltChCmd_CriticalSection;
	coSystemLogging 	: CltChCmd_SystemLogging;
  //Variables:
		aObjects : ARRAY [0..SynchRdWr_MaxObjects-1] OF ^ReadValue;

		udNumberObjects 	: UDINT;
		udRxCounter 	: UDINT;
		IsCon_coSystemLogging 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CallBackReceiver
		VAR_INPUT
			DestinationID 	: DINT;
			SourceID 	: DINT;
			size 	: UDINT;
			pdata 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="TRUE .. erfolgreich Empfangen .._MNG_Recived &#13;&#10;FALSE.. Fehler beim Empfangen .._MNG_GlobalReciveError" Name="CallBackReceiver.retcode"/>
		END_VAR;
				//! <Function Comment="Is used to register a receive object." Name="LoginObject"/>
	FUNCTION GLOBAL LoginObject
		VAR_INPUT
			udID 	: UDINT;			//! <Variable Comment="Unique ID number" Name="LoginObject.udID"/>
			pThis 	: ^ReadValue;			//! <Variable Comment="Thispointer" Name="LoginObject.pThis"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE.. Method was successful&#13;&#10;FALSE.. Error" Name="LoginObject.bSuccessful"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using CriticalSection
#pragma usingLtd _StdLib
#pragma usingLtd SystemLogging


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB TCPComReceiveData::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_TCPCOMRECEIVEDATA
1$UINT, 4$UINT, (SIZEOF(::TCPComReceiveData))$UINT, 
1$UINT, 3$UINT, 0$UINT, 
TO_UDINT(2405448339), "TCPComReceiveData", //Class
TO_UDINT(4066382941), "TCPComReceive", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::TCPComReceiveData.Timeout.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3187968904), "Timeout", 
//Clients:
(::TCPComReceiveData.coStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3815072667), "coStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::TCPComReceiveData.CriticalSection.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(794617671), "CriticalSection", TO_UDINT(794617671), "CriticalSection", 0$UINT, 4$UINT, 
(::TCPComReceiveData.coSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(292037947), "coSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_TCPComReceiveData 2

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_TCPComReceiveData] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION TCPComReceiveData::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= TCPComReceive::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= TCPComReceive::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, TCPComReceive::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_TCPComReceiveData;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #CallBackReceiver();

#pragma warning (default : 74)
	TCPComReceive::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF TCPComReceive::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd ReadValue

//{{LSL_IMPLEMENTATION


FUNCTION GLOBAL TCPComReceiveData::LoginObject
	VAR_INPUT
		udID 	: UDINT;
		pThis 	: ^ReadValue;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
    
  // Übergabeparameter auf Grenzen prüfen
  if udID >= sizeof(aObjects) / sizeof(aObjects[0]) then
    if IsCon_coSystemLogging = TRUE then
      coSystemLogging.LogEventText("TCPComReceiveData::LoginObject(): Übergabeparameter usID verletzt die Grenzen");
    end_if;
    bSuccessful := false;
    return;
  end_if;
  
  // Prüfen ob die ID bereits belegt ist
  if aObjects[udID] <> NIL then
    if IsCon_coSystemLogging = TRUE then
      coSystemLogging.LogEventText("TCPComReceiveData::LoginObject(): Index für Profilpunkt bereits belegt");
    end_if;
    bSuccessful := false;
    return;
  end_if;

  // This-Pointer von RdWr-Object speichern,
  // somit ist dieser Index belegt
  aObjects[udID] := pThis;
  
  // angemeldete Punkte zählen
  udNumberObjects += 1;

  // Methode war erfolgreich
  bSuccessful := true;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL TCPComReceiveData::CallBackReceiver
	VAR_INPUT
		DestinationID 	: DINT;
		SourceID 	: DINT;
		size 	: UDINT;
		pdata 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    tmpIndex  : UDINT;
    pObject   : ^ReadValue;
  END_VAR

  // Rückgabewert initialisieren
  Retcode := false;
  
  // Übergabeparameter prüfen
  if pData = NIL then
    if IsCon_coSystemLogging = TRUE then
      coSystemLogging.LogEventText("TCPComReceiveData::ReceiveData(): Pointer auf Daten ungültig");
    end_if;
    return;
  end_if;
  
  tmpIndex := pdata^;
  
  // Index prüfen
  if tmpIndex < sizeof(aObjects) / sizeof(aObjects[0]) then
    //Pointer auf ID holen
    pObject := aObjects[tmpIndex];
    
    // Prüfen ob Objekt verfügbar
    if pObject <> NIL then
    
      // Daten weiterleiten
      if pObject^.SetData(pdata, size) = false then
        if IsCon_coSystemLogging = TRUE then
          coSystemLogging.LogEventText("TCPComReceiveData::ReceiveData(): Empfangen der Daten in Indexobjekt fehlgeschlagen");
        end_if;
      end_if;
      
    else
      if IsCon_coSystemLogging = TRUE then
        coSystemLogging.LogEventText("TCPComReceiveData::ReceiveData(): Index zum Empfangen nicht belegt");
      end_if;
    end_if;
  
  else
    if IsCon_coSystemLogging = TRUE then
      coSystemLogging.LogEventText("TCPComReceiveData::ReceiveData(): Indexüberlauf eim Empfangen");
    end_if;
  end_if;

  // Empfangene Packete zählen
  udRxCounter += 1;
  
  // alles korrekt empfangen
  Retcode := true;
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL TCPComReceiveData::Init

  TCPComReceive::Init();
  
  if _FirstScan then
    
    //-----------------------------------------------------------------------------------------
    //  check client-connnections and set flags                                          
    //-----------------------------------------------------------------------------------------
    if (IsClientConnected(#coSystemLogging)) then
      IsCon_coSystemLogging := TRUE;
    else
      IsCon_coSystemLogging := FALSE;
    end_if;
    
    
  end_if;


END_FUNCTION
