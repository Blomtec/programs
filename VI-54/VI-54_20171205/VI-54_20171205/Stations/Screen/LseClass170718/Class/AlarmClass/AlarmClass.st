//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "AlarmClass"
	Revision           = "0.0"
	GUID               = "{485BE057-7D23-4D3F-B304-3755B5B5FD52}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(1140,240)">
	<Channels>
		<Server Name="AlarmNr" GUID="{D9693082-DD0B-414B-BF15-84D62F37C5C5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="LongText" GUID="{2647D504-E7CE-462C-91EA-F41721EF5694}" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="ShortText" GUID="{B499BEBB-25FD-4D6E-9306-F4BFA06357D9}" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Client Name="AlarmTxtLong" Required="true" Internal="true"/>
		<Client Name="AlarmTxtShort" Required="true" Internal="true"/>
	</Channels>
	<Network Name="AlarmClass">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{39D39A3D-23CB-4E5D-B892-FDC8B942A126}"
				Class      = "_HotAlarm"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
			<Object
				Name       = "AlarmTxtLong"
				GUID       = "{5EB31482-0F18-4D18-B001-8216CBF0FC98}"
				Class      = "String"
				Position   = "(210,480)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "AlarmTxtShort"
				GUID       = "{0C162F6D-32B0-4CA0-A391-7CCBC1DD1379}"
				Class      = "String"
				Position   = "(210,330)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(938,210),(518,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="this.AlarmTxtShort" Destination="AlarmTxtShort.Data"/>
			<Connection Source="this.AlarmTxtLong" Destination="AlarmTxtLong.Data"/>
			<Connection Source="this.ShortText" Destination="AlarmTxtShort.Data" Vertices="(938,330),(766,420),"/>
			<Connection Source="this.LongText" Destination="AlarmTxtLong.Data" Vertices="(938,390),(766,570),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _HotAlarm

AlarmClass : CLASS
: _HotAlarm
  //Servers:
	AlarmNr 	: SvrCh_DINT;
	ShortText 	: SvrCh_UDINT;
	LongText 	: SvrCh_UDINT;
  //Clients:
	AlarmTxtShort 	: CltChCmd_String;
	AlarmTxtLong 	: CltChCmd_String;
  //Variables:
		txtShort : ARRAY [0..599] OF CHAR;

		txtLong : ARRAY [0..599] OF CHAR;

		psa 	: ^_SINGLEALARM;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to redraw the io&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;pr ........ pointer to result information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... _TRUE it&apos;s an input / _FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to get data for defined io.&#13;&#10;&#13;&#10;pr ........ pointer to result information&#13;&#10;pio ....... pointer to io information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... _TRUE it&apos;s an input / _FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to do it let&apos;s return _IDIDIT and initialize the  structure _RESULT&#13;&#10;" Name="GetData"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetData
		VAR_INPUT
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="GetData.pr"/>
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="GetData.pio"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to _VARIABLE information given by LSE" Name="GetData.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="GetData.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)" Name="GetData.retcode"/>
		END_VAR;
	
	FUNCTION GLOBAL CreateAlarmTxt
		VAR_INPUT
			inpPsa 	: ^_SINGLEALARM;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ShortText::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ShortText::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LongText::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LongText::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AlarmClass::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_ALARMCLASS
0$UINT, 0$UINT, (SIZEOF(::AlarmClass))$UINT, 
3$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2496854934), "AlarmClass", //Class
TO_UDINT(3509550928), "_HotAlarm", 0$UINT, 1$UINT, //Baseclass
//Servers:
(::AlarmClass.AlarmNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2428539316), "AlarmNr", 
(::AlarmClass.ShortText.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(1164107853), "ShortText", 
(::AlarmClass.LongText.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(1518892913), "LongText", 
//Clients:
(::AlarmClass.AlarmTxtShort.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(938161621), "AlarmTxtShort", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AlarmClass.AlarmTxtLong.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1167577471), "AlarmTxtLong", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_AlarmClass 17

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AlarmClass] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AlarmClass::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _HotAlarm::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AlarmClass;
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetData();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ShortText.pMeth			:= StoreMethod( #ShortText::Read(), #ShortText::Write() );
	IF ShortText.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LongText.pMeth			:= StoreMethod( #LongText::Read(), #LongText::Write() );
	IF LongText.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmClass::Draw
	VAR_INPUT
		pio 	: ^_IO;
		pr 	: ^_RESULT;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  VAR
  pms   : ^_MEM_SINGLEALARM;
	// psa   : ^_SINGLEALARM; 
	txt   : ^_CHAR;  
	st    : BOOL; 
	no    : UDINT; 
  END_VAR

  st  := FALSE; 
  pms := get_MEM_SINGLEALARM(FALSE); 
  no  := no_RINGBUFFER(#pms^.ringbuffer); 
  while(no > 0) do
    no -= 1; 
    psa := pms^.ptr + rpos_RINGBUFFER(#pms^.ringbuffer, no) * sizeof(_SINGLEALARM); 
    CreateAlarmTxt(inpPsa:= psa);
    AlarmNr := psa^.no;
	  if(psa^.state <> 0) then
      txt := create_alarmtext(psa, FALSE, NIL);
	    if(txt <> NIL) then
	    no := 0; 
	    st := TRUE; 
      end_if; 
    end_if; 
  end_while; 

  Graphic.Putimage(#pio^.image, DEFKOORD, DEFKOORD);   
  if(st = _FALSE) then // Set text to ' '
    AlarmNr := -1;
    AlarmTxtShort.Clear();
    AlarmTxtLong.Clear();
  else
    OutMultiTextAlign(txt, pio^.fillchr, #pio^.space, pio^.font, pio^.attrib, pio^.frametype, pio^.coltxt, pio^.colback, pio^.colframe, sizeof(_CHAR));
  end_if; 

  retcode := _IDIDIT;   

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL AlarmClass::GetData
	VAR_INPUT
		pr 	: ^_RESULT;
		pio 	: ^_IO;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  VAR
    pms : ^_MEM_SINGLEALARM; 
  END_VAR

  pms := get_MEM_SINGLEALARM(FALSE);
  pr^.ftype := RES_NUMERIC;
  pr^.rmin  := pms^.xchange;
  pr^.rmax  := pms^.xchange;
  pr^.value := pms^.xchange;
  pr^.ptr   := #pr^.value$void;

  retcode := _IDIDIT;

END_FUNCTION

FUNCTION GLOBAL AlarmClass::CreateAlarmTxt
	VAR_INPUT
		inpPsa 	: ^_SINGLEALARM;
	END_VAR
  VAR
  	pTxtShort : ^_char;
    pTxtLong  : ^_char;
    tmpColor  : _COLOR;
    tmplength : udint;
  END_VAR
  
  if inpPsa = NIL then
    StrCpy(p0:=#txtShort[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));  
    StrCpy(p0:=#txtLong[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));
  else
  
    // Alarmtext short bestimmen
    pTxtShort := create_alarmtext(p0  := inpPsa, 
                                  x1  := FALSE, 
                                  p2  := #tmpColor);                          
    if pTxtShort <> NIL then
      StrNCpy(p0:=#txtShort[0], x1:=sizeof(_char), p2:=pTxtShort, x3:=sizeof(_char), ml := sizeof(txtShort)/sizeof(_CHAR));
    else
      StrCpy(p0:=#txtShort[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));
    end_if;

    // Alarmtext long bestimmen
    pTxtLong := create_alarmtext (p0  := inpPsa, 
                                  x1  := TRUE, 
                                  p2  := #tmpColor);
    if pTxtLong <> NIL then                              
      StrNCpy(p0:=#txtLong[0], x1:=sizeof(_char), p2:=pTxtLong, x3:=sizeof(_char), ml := sizeof(txtLong)/sizeof(_CHAR));
    else
      StrCpy(p0:=#txtLong[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));
    end_if;
  end_if;
  
  tmplength := StrLen(txt:=#txtShort[0], size:=sizeof(_CHAR));
  AlarmTxtShort.WriteDataOffUni(udlen:=(tmplength+1)*2, udOff:=0, pData:=(#txtShort[0])$^_UNI, usSize:=sizeof(_CHAR)); // V.1.1: cast to ^_UNI
  
  tmplength := StrLen(txt:=#txtLong[0], size:=sizeof(_CHAR));
  AlarmTxtLong.WriteDataOffUni(udlen:=(tmplength+1)*2, udOff:=0, pData:=(#txtLong[0])$^_UNI, usSize:=sizeof(_CHAR));  // V.1.1: cast to ^_UNI



END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmClass::ShortText::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	ShortText := AlarmTxtShort.Data.Read();
	output := ShortText;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmClass::ShortText::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	ShortText := input;
	result := (AlarmTxtShort.Data.Write(ShortText))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmClass::LongText::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	LongText := AlarmTxtLong.Data.Read();
	output := LongText;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmClass::LongText::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	LongText := input;
	result := (AlarmTxtLong.Data.Write(LongText))$UDINT;

END_FUNCTION
