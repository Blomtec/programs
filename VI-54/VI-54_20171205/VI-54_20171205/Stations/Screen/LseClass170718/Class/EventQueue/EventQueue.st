//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define     EventQueue_MaxEntries     50
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "EventQueue"
	Revision           = "1.3"
	GUID               = "{35AE70EB-29E3-4C3E-BA94-39518E42FB2A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,480)"
	Comment            = "class for converting row events and buffering for the EventJournal ">
	<Channels>
		<Server Name="ActEntries" GUID="{1C36ECE3-561E-4423-A18A-544D317AC859}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual number of entries in buffer to be readed/handled"/>
		<Server Name="ClassSvr" GUID="{2800330E-7874-49CE-B0C9-48BB9D8223DC}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="class server"/>
		<Server Name="MaxEntries" GUID="{C6390820-BD98-4697-9B31-F711E2C86FB4}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="max. number of entries in buffer to be readed/handled"/>
		<Client Name="coEventJournal" Required="true" Internal="false" Comment="object channel to EventJournal"/>
		<Client Name="coStdLib" Required="false" Internal="false" Comment="object channel to SdtLib (don&apos;t connect!)"/>
		<Client Name="coSystemLogging" Required="false" Internal="false" Comment="object channel to SystemLogging (optional)"/>
		<Client Name="Param1" Required="true" Internal="false" Comment="Parameter 1 for event entry"/>
		<Client Name="Param2" Required="true" Internal="false" Comment="Parameter 2 for event entry"/>
		<Client Name="SysDate" Required="true" Internal="false" Comment="object channel to SysDate"/>
		<Client Name="SysTime" Required="true" Internal="false" Comment="object channel to SysTime"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\EventJournal\Event.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="ObeChr"/>
		<Dokumentation Revision="1.3" Date="2016-08-22" Author="Roskri" Company="Sigmatek" Description="Clients SysDate and SysTime changed to HDINT"/>
		<Dokumentation Revision="1.2" Date="2016-05-18" Author="KaiAnd" Company="Sigmatek" Description="object channel to SystemLogging is optional now"/>
		<Dokumentation Revision="1.1" Date="2015-05-22" Author="BraLis" Company="Sigmatek" Description="insert the method SystemLogging::LogEventText instead of TRACE-Messages"/>
		<Dokumentation Revision="1.0" Date="2015-03-31" Company="Sigmatek" Description="Creation&#13;&#10;"/>
	</RevDoku>
</Class>
*)
EventQueue : CLASS
	TYPE
#pragma pack(push, 1)
	  t_s_EventBuffer : STRUCT
	    pStart : ^_SINGLEALARM;
	    pEnd : ^_SINGLEALARM;
	    pWrite : ^_SINGLEALARM;
	    pRead : ^_SINGLEALARM;
	    udSize : UDINT;
	    udElements : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	ActEntries 	: SvrCh_UDINT;
	MaxEntries 	: SvrCh_UDINT;
  //Clients:
	coEventJournal 	: CltChCmd_EventJournal;
	Param1 	: CltCh_DINT;
	Param2 	: CltCh_DINT;
	SysDate 	: CltCh_HDINT;
	SysTime 	: CltCh_HDINT;
	coStdLib 	: CltChCmd__StdLib;
	coSystemLogging 	: CltChCmd_SystemLogging;
  //Variables:
		sEventBuffer 	: t_s_EventBuffer;
		IsCon_coSystemLogging 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Method to insert an event for a date change into the buffer." Name="AddDateChange"/>
	FUNCTION GLOBAL AddDateChange
		VAR_INPUT
			udVarNo 	: UDINT;			//! <Variable Comment="Variable number" Name="AddDateChange.udVarNo"/>
			dOldDate 	: DINT;			//! <Variable Comment="Old date" Name="AddDateChange.dOldDate"/>
			dNewDate 	: DINT;			//! <Variable Comment="New date" Name="AddDateChange.dNewDate"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..event could not be inserted into the buffer&#13;&#10;TRUE..event inserted successfully" Name="AddDateChange.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Method to insert an event for a menu change into the buffer." Name="AddMenuChange"/>
	FUNCTION GLOBAL AddMenuChange
		VAR_INPUT
			udVarNo 	: UDINT;			//! <Variable Comment="Variable number" Name="AddMenuChange.udVarNo"/>
			udMenuIndex 	: UDINT;
			dOldValue 	: DINT;			//! <Variable Comment="Old value" Name="AddMenuChange.dOldValue"/>
			dNewValue 	: DINT;			//! <Variable Comment="New value" Name="AddMenuChange.dNewValue"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Event could not be inserted into the buffer&#13;&#10;TRUE..Event inserted successfully" Name="AddMenuChange.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Method to insert an event for the change of the operation mode into the buffer." Name="AddOPChange"/>
	FUNCTION GLOBAL AddOPChange
		VAR_INPUT
			eOPMode 	: t_e_OPMode;			//! <Variable Comment="New operation mode" Name="AddOPChange.eOPMode"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Event could not be insert into the buffer&#13;&#10;TRUE..Event inserted successfully" Name="AddOPChange.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Method to insert an event for turning on or off the system." Name="AddSystemOnOff"/>
	FUNCTION VIRTUAL GLOBAL AddSystemOnOff
		VAR_INPUT
			dDate 	: DINT;			//! <Variable Comment="Actual date" Name="AddSystemOnOff.dDate"/>
			dTime 	: DINT;			//! <Variable Comment="Actual time" Name="AddSystemOnOff.dTime"/>
			bSwitchOnOff 	: BOOL;			//! <Variable Comment="FALSE..Event for turning off the system&#13;&#10;TRUE..Event for turning on the system" Name="AddSystemOnOff.bSwitchOnOff"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Event could not be inserted to the buffer&#13;&#10;TRUE..Event inserted succesfully" Name="AddSystemOnOff.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Method to insert an event for a time change into the buffer" Name="AddTimeChange"/>
	FUNCTION GLOBAL AddTimeChange
		VAR_INPUT
			udVarNo 	: UDINT;			//! <Variable Comment="Variable number" Name="AddTimeChange.udVarNo"/>
			dOldTime 	: DINT;			//! <Variable Comment="Old time" Name="AddTimeChange.dOldTime"/>
			dNewTime 	: DINT;			//! <Variable Comment="New time" Name="AddTimeChange.dNewTime"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Event could not be inserted to the buffer&#13;&#10;TRUE..Event inserted successfully" Name="AddTimeChange.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Method to insert an user event (text) into the buffer" Name="AddUserEvent"/>
	FUNCTION GLOBAL AddUserEvent
		VAR_INPUT
			pEventString 	: ^_CHAR;			//! <Variable Comment="Pointer to the text which should be added (Unicode)" Name="AddUserEvent.pEventString"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Event could not be inserted into the buffer&#13;&#10;TRUE..Event inserted successfully" Name="AddUserEvent.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Method to insert an event for user login/logout into the buffer." Name="AddUserLoginLogout"/>
	FUNCTION GLOBAL AddUserLoginLogout
		VAR_INPUT
			pUserName 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the user, which was logged in or logged out" Name="AddUserLoginLogout.pUserName"/>
			dActLevel 	: DINT;			//! <Variable Comment="User level" Name="AddUserLoginLogout.dActLevel"/>
			bIsLogin 	: BOOL;			//! <Variable Comment="FALSE..User logged out&#13;&#10;TRUE..User logged in" Name="AddUserLoginLogout.bIsLogin"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Event could not be inserted to the buffer&#13;&#10;TRUE..Event inserted successfully" Name="AddUserLoginLogout.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Method to insert an event for a value change into the buffer." Name="AddValueChange"/>
	FUNCTION GLOBAL AddValueChange
		VAR_INPUT
			udVarNo 	: UDINT;			//! <Variable Comment="Variable number" Name="AddValueChange.udVarNo"/>
			dOldValue 	: DINT;			//! <Variable Comment="Old value" Name="AddValueChange.dOldValue"/>
			dNewValue 	: DINT;			//! <Variable Comment="New value" Name="AddValueChange.dNewValue"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Event could not be inserted into the buffer&#13;&#10;TRUE..Event inserted successfully" Name="AddValueChange.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Copy data into the write buffer and set the write pointer so that the entry in the buffer will be added to the event journal in the next background run." Name="AddEntry"/>
	FUNCTION AddEntry
		VAR_INPUT
			pEntry 	: ^_SINGLEALARM;			//! <Variable Comment="Pointer to the data of the entry" Name="AddEntry.pEntry"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..pEntry was NIL&#13;&#10;TRUE..Ok" Name="AddEntry.bSuccessful"/>
		END_VAR;
				//! <Function Comment="This Method is used to register an event into the logbook." Name="AddEventEntry"/>
	FUNCTION GLOBAL AddEventEntry
		VAR_INPUT
			uiCategory 	: UINT;			//! <Variable Comment="Category for the event:&#13;&#10;0 .. System category 1&#13;&#10;1 .. System category 2&#13;&#10;2 .. System category 3&#13;&#10;3 .. System category 4&#13;&#10;4 .. Change of the OP mode&#13;&#10;else .. System category 1" Name="AddEventEntry.uiCategory"/>
			uiIndex 	: UINT;			//! <Variable Comment="Index in the textscheme (if used).&#13;&#10;Note: If event is for example a menue-change -&gt; menue-index." Name="AddEventEntry.uiIndex"/>
			pText 	: ^void;			//! <Variable Comment="Individual text" Name="AddEventEntry.pText"/>
			bUnicode 	: BOOL;			//! <Variable Comment="Character size of the string:&#13;&#10;FALSE .. ASCII&#13;&#10;TRUE .. UNI-Code" Name="AddEventEntry.bUnicode"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Event could not be inserted into the buffer&#13;&#10;TRUE..Event inserted successfullly" Name="AddEventEntry.bSuccessful"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib
#pragma usingLtd EventJournal
#pragma usingLtd SystemLogging


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB EventQueue::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EVENTQUEUE
1$UINT, 3$UINT, (SIZEOF(::EventQueue))$UINT, 
3$UINT, 7$UINT, 0$UINT, 
TO_UDINT(915169004), "EventQueue", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::EventQueue.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::EventQueue.ActEntries.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(726684855), "ActEntries", 
(::EventQueue.MaxEntries.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1211468272), "MaxEntries", 
//Clients:
(::EventQueue.coEventJournal.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2457081744), "coEventJournal", TO_UDINT(2671722124), "EventJournal", 1$UINT, 2$UINT, 
(::EventQueue.Param1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3700082945), "Param1", 
(::EventQueue.Param2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1166252219), "Param2", 
(::EventQueue.SysDate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1714210210), "SysDate", 
(::EventQueue.SysTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2737203869), "SysTime", 
(::EventQueue.coStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3815072667), "coStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::EventQueue.coSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(292037947), "coSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_EventQueue 2

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_EventQueue] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION EventQueue::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_EventQueue, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #AddSystemOnOff();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL EventQueue::Init
VAR
	tmpMemory : ^_SINGLEALARM;
END_VAR

  // letzter Init-Durchlauf
  if (_FirstScan) then
    
    //-------------------------------------------------------------------------
    //  check client-connnections and set flags		KaiAnd
    //-------------------------------------------------------------------------
    if (IsClientConnected(#coSystemLogging)) then
      IsCon_coSystemLogging := TRUE;
    else
      IsCon_coSystemLogging := FALSE;
    end_if;



    // Speicher für Eventbuffer allokieren
    tmpMemory$^void := coStdLib.Malloc(size := EventQueue_MaxEntries * sizeof(sEventBuffer.pStart^));
    
    // Prüfen ob Speicher verfügbar
    if tmpMemory <> NIL then
    
      // Größe vom Buffer speichern
      sEventBuffer.udElements := EventQueue_MaxEntries;
      sEventBuffer.udSize     := EventQueue_MaxEntries * sizeof(sEventBuffer.pStart^);
      
      // Pointer für Buffer speichern
      sEventBuffer.pStart := tmpMemory;
      sEventBuffer.pEnd   := tmpMemory + sEventBuffer.udSize;
      sEventBuffer.pRead  := tmpMemory;
      sEventBuffer.pWrite := tmpMemory;
      
    else
      if (IsCon_coSystemLogging = True) then    // KaiAnd
        coSystemLogging.LogEventText("EventQueue::Init(): allokieren des Eventspeichers fehlgeschlagen");
      end_if;
    end_if;

  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL EventQueue::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  // aktuelle Anzahl der Elemente im Buffer darstellen
  if sEventBuffer.pWrite >= sEventBuffer.pRead then
    ActEntries := (sEventBuffer.pWrite$UDINT - sEventBuffer.pRead$UDINT) / sizeof(sEventBuffer.pWrite^);
  else
    ActEntries := ((sEventBuffer.pEnd$UDINT - sEventBuffer.pRead$UDINT) + (sEventBuffer.pWrite$UDINT - sEventBuffer.pStart$UDINT)) / sizeof(sEventBuffer.pWrite^);
  end_if;

  // maximale Anzahl der Einträge darstellen
  if ActEntries > MaxEntries then
    MaxEntries := ActEntries;
    
    if MaxEntries >= sEventBuffer.udElements - 1 then
      if (IsCon_coSystemLogging = True) then    // KaiAnd
        coSystemLogging.LogEventText("EventQueue::Background(): Bufferüberlauf");
      end_if;
    end_if;

  end_if;

  
  //*****************************************************************************
  //** SCHLEIFE ZUM LEEREN VOM BUFFER                                          **
  //*****************************************************************************
  while sEventBuffer.pRead <> sEventBuffer.pWrite do
    
    // Event an EventJournal weiterleiten
    if coEventJournal.AddEntry(ptr := sEventBuffer.pRead) = false then
      if (IsCon_coSystemLogging = True) then    // KaiAnd
        coSystemLogging.LogEventText("EventQueue::Background(): Eintragen des Events in EventJournal fehlgeschlagen");
      end_if;
    end_if;
    
    // Auf nächsten Eintrag wechseln
    sEventBuffer.pRead += sizeof(sEventBuffer.pRead^);
    
    // Ende vom Buffer überwachen
    if sEventBuffer.pRead >= sEventBuffer.pEnd then
      sEventBuffer.pRead := sEventBuffer.pStart;
    end_if;
    
  end_while;


	state := READY;

END_FUNCTION


FUNCTION EventQueue::AddEntry
	VAR_INPUT
		pEntry 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR

  // Übergabeparameter prüfen
  if pEntry = NIL then
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventQueue::AddEntry(): Übergabeparameter pEntry = NIL");
    end_if;
    bSuccessful := false;
    return;
  end_if;
  
  // Element in Buffer speichern
  _memcpy(ptr1  := sEventBuffer.pWrite, 
          ptr2  := pEntry, 
          cntr  := sizeof(sEventBuffer.pWrite^));

  // Schreibpointer weiterschalten
  sEventBuffer.pWrite += sizeof(sEventBuffer.pWrite^);
  
  // Ende vom Buffer überwachen
  if sEventBuffer.pWrite >= sEventBuffer.pEnd then
    sEventBuffer.pWrite := sEventBuffer.pStart;
  end_if;

  // alles erfolgreich
  bSuccessful := true;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL EventQueue::AddSystemOnOff
	VAR_INPUT
		dDate 	: DINT;
		dTime 	: DINT;
		bSwitchOnOff 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpEvent : _SINGLEALARM;
  END_VAR

  // Event initialisieren
  init_SINGLEALARM(#tmpEvent);
  
  if bSwitchOnOff = false then
    // Event für das Ausschalten der Steuerung
    tmpEvent.entrytype := EVENT_SWITCHOFF;
  else
    //Event für das Einschalten der Steuerung
    tmpEvent.entrytype := EVENT_SWITCHON;
  end_if;

  // Zyklusnummer lesen
  Param1 := Param1.Read();
  
  // Informationen speichern
  tmpEvent.no_para := 1;
  tmpEvent.para[0] := Param1;
  
  // Datum + Zeit speichern
  tmpEvent.date_on := dDate;
  tmpEvent.time_on := dTime;

  // Event zum Buffer hinzufügen
  if AddEntry(pEntry := #tmpEvent) = true then
    bSuccessful := true;
  else
    bSuccessful := false;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL EventQueue::AddDateChange
	VAR_INPUT
		udVarNo 	: UDINT;
		dOldDate 	: DINT;
		dNewDate 	: DINT;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpEvent : _SINGLEALARM;
  END_VAR

  // Event initialisieren
  init_SINGLEALARM(#tmpEvent);

  // Event für die Änderung eines Datums
  tmpEvent.entrytype := EVENT_DATECHANGE;

  // Zyklusnummer + Datum und Zeit + Zugangslevel lesen
  Param1  := Param1.Read();
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();
  Param2  := Param2.Read();
  
  // Informationen speichern
  tmpEvent.no_para := 5;
  tmpEvent.para[0] := Param1;
  tmpEvent.para[1] := Param2;
  tmpEvent.para[2] := udVarNo$DINT;
  tmpEvent.para[3] := dOldDate;
  tmpEvent.para[4] := dNewDate;
    
  // Datum + Zeit speichern
  tmpEvent.date_on := to_dint(SysDate);
  tmpEvent.time_on := to_dint(SysTime);

  
  // Event zum Buffer hinzufügen
  if AddEntry(pEntry := #tmpEvent) = true then
    bSuccessful := true;
  else
    bSuccessful := false;
  end_if;

END_FUNCTION


FUNCTION GLOBAL EventQueue::AddTimeChange
	VAR_INPUT
		udVarNo 	: UDINT;
		dOldTime 	: DINT;
		dNewTime 	: DINT;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpEvent : _SINGLEALARM;
  END_VAR

  // Event initialisieren
  init_SINGLEALARM(#tmpEvent);

  // Event für die Änderung einer Zeit
  tmpEvent.entrytype := EVENT_TIMECHANGE;
  
  // Zyklusnummer + Datum und Zeit + Zugangslevel lesen
  Param1  := Param1.Read();
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();
  Param2  := Param2.Read();

  // Informationen speichern
  tmpEvent.no_para := 5;
  tmpEvent.para[0] := Param1;
  tmpEvent.para[1] := Param2;
  tmpEvent.para[2] := udVarNo$DINT;
  tmpEvent.para[3] := dOldTime;
  tmpEvent.para[4] := dNewTime;
  
  // Datum + Zeit speichern
  tmpEvent.date_on := to_dint(SysDate);
  tmpEvent.time_on := to_dint(SysTime);
  
  // Event zum Buffer hinzufügen
  if AddEntry(pEntry := #tmpEvent) = true then
    bSuccessful := true;
  else
    bSuccessful := false;
  end_if;

END_FUNCTION


FUNCTION GLOBAL EventQueue::AddValueChange
	VAR_INPUT
		udVarNo 	: UDINT;
		dOldValue 	: DINT;
		dNewValue 	: DINT;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpEvent : _SINGLEALARM;
  END_VAR

  // Event initialisieren
  init_SINGLEALARM(#tmpEvent);

  // Event für die Änderung eines Wertes
  tmpEvent.entrytype := EVENT_VALUECHANGE;

  // Zyklusnummer + Datum und Zeit + Zugangslevel lesen
  Param1   := Param1.Read();
  SysDate  := SysDate.Read();
  SysTime  := SysTime.Read();
  Param2   := Param2.Read();

  // Informationen speichern
  tmpEvent.no_para := 5;
  tmpEvent.para[0] := Param1;
  tmpEvent.para[1] := Param2;
  tmpEvent.para[2] := udVarNo$DINT;
  tmpEvent.para[3] := dOldValue;
  tmpEvent.para[4] := dNewValue;

  // Datum + Zeit speichern
  tmpEvent.date_on := SysDate$DINT;
  tmpEvent.time_on := SysTime$DINT;
  
  // Event zum Buffer hinzufügen
  if AddEntry(pEntry := #tmpEvent) = true then
    bSuccessful := true;
  else
    bSuccessful := false;
  end_if;

END_FUNCTION


FUNCTION GLOBAL EventQueue::AddMenuChange
	VAR_INPUT
		udVarNo 	: UDINT;
		udMenuIndex 	: UDINT;
		dOldValue 	: DINT;
		dNewValue 	: DINT;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpEvent : _SINGLEALARM;
  END_VAR

  // Event initialisieren
  init_SINGLEALARM(#tmpEvent);

  // Event für die Änderung eines Wertes
  tmpEvent.entrytype := EVENT_MENUCHANGE;

  // Zyklusnummer + Datum und Zeit + Zugangslevel lesen
  Param1  := Param1.Read();
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();
  Param2  := Param2.Read();

  // Informationen speichern
  tmpEvent.no_para := 6;
  tmpEvent.para[0] := Param1;
  tmpEvent.para[1] := Param2;
  tmpEvent.para[2] := udVarNo$DINT;
  tmpEvent.para[3] := dOldValue;
  tmpEvent.para[4] := dNewValue;
  tmpEvent.para[5] := udMenuIndex$DINT;

  // Datum + Zeit speichern
  tmpEvent.date_on := SysDate$DINT;
  tmpEvent.time_on := SysTime$DINT;
  
  // Event zum Buffer hinzufügen
  if AddEntry(pEntry := #tmpEvent) = true then
    bSuccessful := true;
  else
    bSuccessful := false;
  end_if;

END_FUNCTION


FUNCTION GLOBAL EventQueue::AddOPChange
	VAR_INPUT
		eOPMode 	: t_e_OPMode;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpEvent : _SINGLEALARM;
  END_VAR

  // Event initialisieren
  init_SINGLEALARM(#tmpEvent);

  // Event für die Änderung eines Wertes
  tmpEvent.entrytype := EVENT_OPCHANGE;

  // Zyklusnummer + Datum und Zeit + Zugangslevel lesen
  Param1  := Param1.Read();
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();
  Param2  := Param2.Read();

  // Informationen speichern
  tmpEvent.no_para := 3;
  tmpEvent.para[0] := Param1;
  tmpEvent.para[1] := Param2;
  tmpEvent.para[2] := eOPMode$DINT;

  // Datum + Zeit speichern
  tmpEvent.date_on := SysDate$DINT;
  tmpEvent.time_on := SysTime$DINT;
  
  // Event zum Buffer hinzufügen
  if AddEntry(pEntry := #tmpEvent) = true then
    bSuccessful := true;
  else
    bSuccessful := false;
  end_if;

END_FUNCTION


FUNCTION GLOBAL EventQueue::AddUserLoginLogout
	VAR_INPUT
		pUserName 	: ^CHAR;
		dActLevel 	: DINT;
		bIsLogin 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpEvent : _SINGLEALARM;
  END_VAR

  // Event initialisieren
  init_SINGLEALARM(#tmpEvent);

  if bIsLogin = false then
    tmpEvent.entrytype := Event_UserLogout;
  else
    tmpEvent.entrytype := Event_UserLogin;
  end_if;

  //Datum und Zeit lesen
  Param1  := Param1.Read();
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();

  // Informationen speichern
  tmpEvent.no_para := 2;
  tmpEvent.para[0] := Param1;
  tmpEvent.para[1] := dActLevel;
  tmpEvent.ptrsize := (StrLen(txt:=pUserName, size:=sizeof(char)) + 1) * sizeof(_CHAR); // wegen Unicode
  tmpEvent.ptr     := coStdLib.Malloc(size:=tmpEvent.ptrsize);
  if tmpEvent.ptr = NIL then
    tmpEvent.ptrsize := 0;
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText(pChar:="EventQueue::AddUserLoginLogout(): Speicher für Benutzername konnte nicht reserviert werden");
    end_if;
  else
    StrCpy(p0:= tmpEvent.ptr, x1:= sizeof(_CHAR), p2:=pUserName, x3:=sizeof(CHAR));
  end_if;

  // Datum + Zeit speichern
  tmpEvent.date_on := SysDate$DINT;
  tmpEvent.time_on := SysTime$DINT;
  
  // Event zum Buffer hinzufügen
  if AddEntry(pEntry := #tmpEvent) = true then
    bSuccessful := true;
  else
    bSuccessful := false;
  end_if;

END_FUNCTION


FUNCTION GLOBAL EventQueue::AddUserEvent
	VAR_INPUT
		pEventString 	: ^_CHAR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpEvent : _SINGLEALARM;
  END_VAR

  // Event initialisieren
  init_SINGLEALARM(#tmpEvent);

  // Event für die Änderung eines Wertes
  tmpEvent.entrytype := Event_UserEvent;

  // Zyklusnummer + Datum und Zeit + Zugangslevel lesen
  Param1  := Param1.Read();
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();
  Param2  := Param2.Read();
  
  // Informationen speichern
  tmpEvent.no_para := 2;
  tmpEvent.para[0] := Param1;
  tmpEvent.para[1] := Param2;
  tmpEvent.ptrsize := sizeof(pEventString^) * (StrLen(txt:=pEventString, size:=sizeof(pEventString^)) + 1);
  tmpEvent.ptr     := coStdLib.Malloc(size:=tmpEvent.ptrsize);
  if tmpEvent.ptr = NIL then
    tmpEvent.ptrsize := 0;
    if (IsCon_coSystemLogging = True) then    // KaiAnd
      coSystemLogging.LogEventText("EventQueue::AddUserEvent(): Speicher für Benutzer-Event konnte nicht reserviert werden");
    end_if;
  else
    _memcpy(ptr1:=tmpEvent.ptr, ptr2:=pEventString, cntr:=tmpEvent.ptrsize);
  end_if;

  // Datum + Zeit speichern
  tmpEvent.date_on := SysDate$DINT;
  tmpEvent.time_on := SysTime$DINT;
  
  // Event zum Buffer hinzufügen
  if AddEntry(pEntry := #tmpEvent) = true then
    bSuccessful := true;
  else
    bSuccessful := false;
  end_if;

END_FUNCTION


FUNCTION GLOBAL EventQueue::AddEventEntry
	VAR_INPUT
		uiCategory 	: UINT;
		uiIndex 	: UINT;
		pText 	: ^void;
		bUnicode 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpEvent : _SINGLEALARM;
  END_VAR
  
  // Event initialisieren
  init_SINGLEALARM(#tmpEvent);

  // Kategorie des Events definieren
  case uiCategory of
  0 :
    tmpEvent.entrytype := Event_SystemCat1;
  1 :
    tmpEvent.entrytype := Event_SystemCat2;  
  2 :
    tmpEvent.entrytype := Event_SystemCat3;
  3 :
    tmpEvent.entrytype := Event_SystemCat4;  
  4 :
    tmpEvent.entrytype := Event_OPChange;
  else
    tmpEvent.entrytype := Event_SystemCat1;
  end_case;
  
  // Zyklusnummer + Datum und Zeit + Zugangslevel lesen
  Param1  := Param1.Read();
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();
  Param2  := Param2.Read();

  // Informationen speichern
  tmpEvent.no_para := 3;
  tmpEvent.para[0] := Param1;
  tmpEvent.para[1] := Param2;
  tmpEvent.para[2] := uiIndex;
  
  // Speicher für den Text reservieren
  if (pText <> NIL) then
    
    if (bUnicode = true) then
      tmpEvent.ptrsize := (StrLen(txt:=pText, size:=sizeof(UINT)) + 1) * sizeof(UINT);
    else
      tmpEvent.ptrsize := (StrLen(txt:=pText, size:=sizeof(CHAR)) + 1) * sizeof(_CHAR);
    end_if;
    
    tmpEvent.ptr := coStdLib.Malloc(size:=tmpEvent.ptrsize);
    if (tmpEvent.ptr = NIL) then
      tmpEvent.ptrsize := 0;
      if (IsCon_coSystemLogging = True) then    // KaiAnd
        coSystemLogging.LogEventText("EventQueue::AddEventEntry(): Speicher Eventtext konnte nicht reserviert werden");
      end_if;
    else
    
      if bUnicode = true then
        StrCpy(p0 := tmpEvent.ptr, x1 := sizeof(_CHAR), p2 := pText, x3 := sizeof(_CHAR));
      else
        StrCpy(p0 := tmpEvent.ptr, x1 := sizeof(_CHAR), p2 := pText, x3 := sizeof(CHAR));
      end_if;

    end_if;
  end_if;

  // Datum + Zeit speichern
  tmpEvent.date_on := SysDate$DINT;
  tmpEvent.time_on := SysTime$DINT;
  
  // Event zum Buffer hinzufügen
  if AddEntry(pEntry := #tmpEvent) = true then
    bSuccessful := true;
  else
    bSuccessful := false;
  end_if;

END_FUNCTION
