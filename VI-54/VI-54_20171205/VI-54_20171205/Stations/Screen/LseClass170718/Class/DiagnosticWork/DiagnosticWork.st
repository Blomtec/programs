//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "DiagnosticWork"
	Revision           = "1.0"
	GUID               = "{B33CBDC4-C91B-48AB-AE20-5C21386B9418}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(434,120)"
	Comment            = "This class starts and controls the work. It starts the user function when the command is received or it sends commands to another station to start the work.">
	<Channels>
		<Client Name="cToCom" Required="true" Internal="false" Comment="Object channel to SendDataCMD."/>
		<Client Name="cUserFunction" Required="true" Internal="false" Comment="Connect this client to the user function."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.0" Date="2016-06-02" Author="HötAnt" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
	<Network Name="DiagnosticWork">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{0275C8C1-BFF4-47FF-8D16-80C43D2057D8}"
				Class      = "DiagnosticStationBase"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="sStationName"/>
					<Server Name="sStatus"/>
					<Client Name="cHandler"/>
					<Client Name="cSigCLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.sStatus" Destination="_base.sStatus" Vertices="(844,210),(672,210),"/>
			<Connection Source="_base.cHandler" Destination="this.cHandler" Vertices="(218,210),(38,210),"/>
			<Connection Source="this.sStationName" Destination="_base.sStationName" Vertices="(844,270),(672,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using DiagnosticStationBase

DiagnosticWork : CLASS
: DiagnosticStationBase
	TYPE
#pragma pack(push, 1)
	  _JobState : STRUCT
	    JobID : DINT;
	    State : BOOL;  //! <Type Comment="FALSE Fehler beim Senden&#13;&#10;TRUE  wurde gesendet.&#13;&#10;" Name="_JobState.State"/>
	  END_STRUCT;
#pragma pack(pop)
	  _SSW_DW :
	  (
	    DW_WaitForTrigger,
	    DW_SetUserDrivePath,
	    DW_SendCMDToPLC,
	    DW_CheckSending,
	    DW_WaitForResponse,
	    DW_CallUserFunktion,
	    DW_Ready
	  )$UDINT;
	END_TYPE
  //Servers:
  //Clients:
	cToCom 	: CltChCmd_SendDataCMD;
	cUserFunction 	: CltChCmd_DiagnosticUserFunction;
  //Variables:
		ssw 	: _SSW_DW;
		TempJobID 	: DINT;
		JobData 	: DINT;
		JobState 	: _JobState;
		DrivePathStation 	: _DiagString;
		Fault 	: _DiagErrorCode;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="This method is called when the diagnostic export starts." Name="StartAction"/>
	FUNCTION VIRTUAL GLOBAL StartAction
		VAR_INPUT
			pDP 	: ^CHAR;			//! <Variable Comment="Pointer to the folder path." Name="StartAction.pDP"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="FALSE..Error&#13;&#10;TRUE..Ok" Name="StartAction.retcode"/>
		END_VAR;
				//! <Function Comment="Receive data." Name="ReceivedData"/>
	FUNCTION VIRTUAL GLOBAL ReceivedData
		VAR_INPUT
			size 	: UDINT;			//! <Variable Comment="Size of the received data." Name="ReceivedData.size"/>
			pdata 	: ^USINT;			//! <Variable Comment="Pointer to the received data." Name="ReceivedData.pdata"/>
			OptCMD 	: USINT;			//! <Variable Comment="Optional command." Name="ReceivedData.OptCMD"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="TRUE..Data received&#13;&#10;FALSE..Error" Name="ReceivedData.retcode"/>
		END_VAR;
				//! <Function Comment="Save Job ID and JobState in a membervariable." Name="ResponseJobState"/>
	FUNCTION GLOBAL ResponseJobState
		VAR_INPUT
			JobID 	: DINT;			//! <Variable Comment="Job ID." Name="ResponseJobState.JobID"/>
			SendOK 	: BOOL;			//! <Variable Comment="State of the job." Name="ResponseJobState.SendOK"/>
		END_VAR;
				//! <Function Comment="Get the actual state of a job." Name="GetJobState"/>
	FUNCTION GLOBAL GetJobState
		VAR_INPUT
			JobID 	: DINT;			//! <Variable Comment="ID of the job from which you want to get the state." Name="GetJobState.JobID"/>
		END_VAR
		VAR_OUTPUT
			SendOK 	: DINT;			//! <Variable Comment="-1..Error while sending&#13;&#10; 0..Wait for JobID&#13;&#10; 1..Sended&#13;&#10;" Name="GetJobState.SendOK"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd DiagnosticUserFunction
#pragma usingLtd SendDataCMD


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DiagnosticWork::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_DIAGNOSTICWORK
1$UINT, 0$UINT, (SIZEOF(::DiagnosticWork))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(435391692), "DiagnosticWork", //Class
TO_UDINT(2640067302), "DiagnosticStationBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::DiagnosticWork.cToCom.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1002087807), "cToCom", TO_UDINT(2500758279), "SendDataCMD", 1$UINT, 0$UINT, 
(::DiagnosticWork.cUserFunction.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(121626066), "cUserFunction", TO_UDINT(487743715), "DiagnosticUserFunction", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_DiagnosticWork 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DiagnosticWork] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DiagnosticWork::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= DiagnosticStationBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DiagnosticStationBase::sStatus.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DiagnosticStationBase::sStatus.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_DiagnosticWork;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #StartAction();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #ReceivedData();

#pragma warning (default : 74)
	DiagnosticStationBase::sStatus.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DiagnosticStationBase::sStatus.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL DiagnosticWork::Init
  // aufruf der base , da diese die Initialisierung der Station durchführt.
  DiagnosticStationBase::Init();
  // wird benötigt , da 0 eine gültige JobID ist.
  JobState.JobID := -1;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL DiagnosticWork::StartAction
	VAR_INPUT
		pDP 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode :=FALSE;
  if ssw = DW_WaitForTrigger then
    cSigCLib.StrCpy(dst0:=#DrivePathStation[0], src0:=pDP);
    ssw :=DW_SetUserDrivePath;
    retcode := TRUE;
    sStatus := BUSY;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiagnosticWork::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
  case ssw of
    
    DW_WaitForTrigger : // Warten bis wir von der Funktion angestoßen werden. ( StartAction )
    
    DW_SetUserDrivePath: // Pfad an User weiterleiten.
        cUserFunction.SetDrivePath(pDP:=#DrivePathStation[0]);
        ssw := DW_SendCMDToPLC;
    
    
    DW_SendCMDToPLC :  // Der Gegenstelle mitteilen , dass sie jetzt starten kann.
        TempJobID := cToCom.SendData(pData:=#JobData, length:=sizeof(JobData), timeout:=0, OptCMD:=Diagnostic_OptCMD_StartWorkOnPLC);
        if TempJobID >=0 then
          ssw := DW_CheckSending;
        else
          // Felermeldung noch ausgeben.
          sStatus := ERROR;
          ssw := DW_WaitForTrigger;
        end_if;
    
    DW_CheckSending : // Wait for Callback of JobState ( wurd erfolgreich gesendet ) ResponseJobState 
        case GetJobState(JobID:= TempJobID ) of
          -1 :// Konnte nicht gesendet werden
              // Error
           0 :// noch keinen Callback bekommen.
           1 :// erfolgreich gesendet.
              ssw := DW_WaitForResponse;
        end_case;
 
        
        
    DW_WaitForResponse : // Wait for Response ( ReceivedData )
    
    DW_CallUserFunktion : // Antwort bekommen , Daten verarbeiten.
        // Funktion vom User Zyklisch aufrufen , bis die Methode GetWorkState nicht mehr Busy zurückliefert.
        cUserFunction.WorkMethode();
        // Prüfen ob User fertig ist.
        case cUserFunction.GetWorkState() of
          BUSY :  // User ist noch am Arbeiten.
          Ready:  // User konnte die Daten erfolgreich verarbeiten.
                  cHandler.LogFunction(pStationName:=GetStationName(), bState:=TRUE);
                  ssw := DW_Ready;
        else
          // Fehler Errorcode vom User holen , muß noch ausgegenben werden.
          cHandler.LogFunction(pStationName:=GetStationName(), bState:=FALSE);
          Fault := cUserFunction.GetErrorCode();
          cUserFunction.EndWork();
          ssw := DW_WaitForTrigger;
          sStatus := ERROR;
        end_case;
    
    DW_Ready : // Abarbeitung fertig , Status auf Ready
        cUserFunction.EndWork();
        ssw := DW_WaitForTrigger;
        sStatus := READY;
   
       
   
  end_case;

	state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiagnosticWork::ReceivedData
	VAR_INPUT
		size 	: UDINT;
		pdata 	: ^USINT;
		OptCMD 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := FALSE;
  case OptCMD of
    Diagnostic_OptCMD_ResponseSuccesData:
      // Empfange Daten von Gegenstelle an User weiterleiten
      retcode := cUserFunction.ReceivedData(size, pdata, OptCMD);
      if retcode = TRUE then
        ssw := DW_CallUserFunktion;
      else
        // Fehlermeldung noch ausgeben.
        ssw := DW_WaitForTrigger;
        Fault := cUserFunction.GetErrorCode();
        SetError(ErrorNr:=Fault.ErrorNr, ErrorCode:=Fault.ErrorCode);
        sStatus := ERROR;
      end_if;
      
    Diagnostic_OptCMD_ResponseError:
      if size = sizeof(_DiagErrorCode) then
        if pdata <> NIL then
          cSigCLib.MemCpy(dst0:=#Fault, src0:=pdata, len0:=sizeof(_DiagErrorCode));
          SetError(ErrorNr:=Fault.ErrorNr, ErrorCode:=Fault.ErrorCode);
        else
          SetError(ErrorNr:=DENR_HMI_ErrorPLC, ErrorCode:=DECD_DataPointer);
        end_if;
      else
        SetError(ErrorNr:=DENR_HMI_ErrorPLC, ErrorCode:=DECD_DataSize);
      end_if;
      cUserFunction.EndWork();
      ssw := DW_WaitForTrigger;
      sStatus := ERROR;
      retcode := TRUE;
  
  end_case;

  

END_FUNCTION

FUNCTION GLOBAL DiagnosticWork::ResponseJobState
	VAR_INPUT
		JobID 	: DINT;
		SendOK 	: BOOL;
	END_VAR
  
  // Statusmeldung für Background merken.
  JobState.JobID := JobID;
  JobState.State := SendOK;
  
END_FUNCTION

FUNCTION GLOBAL DiagnosticWork::GetJobState
	VAR_INPUT
		JobID 	: DINT;
	END_VAR
	VAR_OUTPUT
		SendOK 	: DINT;
	END_VAR
  
  // prüfen ob unser Job gemeint ist.
  if JobID = JobState.JobID then
    if JobState.State =FALSE then
      // Job konnte nicht gesendet werden.
      SendOK := -1;
    else
      // Job wurde korrekt gesendet.
      SendOK := 1;
    end_if;
  else
    // noch keine Antwort für unseren Job.
    SendOK := 0;
  end_if;
  

END_FUNCTION



