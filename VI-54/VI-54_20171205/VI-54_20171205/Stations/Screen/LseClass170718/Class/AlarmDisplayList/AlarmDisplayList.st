//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\AlarmDisplayList\AlarmTemp.h"

(*!
<Class
	Name               = "AlarmDisplayList"
	Revision           = "1.2"
	GUID               = "{B681CDD4-0999-41FE-8CE0-8F1C06B0C4AB}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,420)">
	<Channels>
		<Server Name="Acknowledge" WriteProtected="false">
		</Server>
		<Server Name="AlaTxtLong" GUID="{25E41461-5DFD-4185-8170-7ABA528154D8}" Class="VirtualBaseInit" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="AlaTxtShort" GUID="{A808CD88-615A-4578-ADD8-AC25A24224BF}" Class="VirtualBaseInit" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="Delete" WriteProtected="false">
		</Server>
		<Server Name="HelpTxt" GUID="{156C30AF-766C-4659-986D-16746F8A50A9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="command read the alarm textes for alarm details"/>
		<Client Name="AlarmTxtLong" Required="true" Internal="true"/>
		<Client Name="AlarmTxtShort" Required="true" Internal="true"/>
		<Client Name="ccAlarmChanged" Required="false" Internal="false" Comment="command channel to share alarm changes (optional)"/>
		<Client Name="coAlarmTitle" Required="false" Internal="false" Comment="objekt channel to AlarmTitleLine (optional)"/>
		<Client Name="ColumnChoice" Required="true" Internal="false" Comment="Bitmuster zum Enablen der Darstellung von Display-Items&#13;&#10;2#1000 = Alarmnummer&#13;&#10;2#0100 = Zeit gekommen/gegangen&#13;&#10;2#0010 = Zyklusnummer (KaiAnd: real &quot;Para1&quot;)&#13;&#10;2#0001 = Alarmtext &#13;&#10;"/>
		<Client Name="coSystemLogging" Required="false" Internal="false" Comment="object channel to SystemLogging (optional)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\AlarmDisplayList\AlarmTemp.h" Include="true"/>
			<File Path=".\Class\AlarmDisplayList\AlarmDisplayList.UDC"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="KruAle"/>
		<Dokumentation Revision="1.2" Date="2016-08-24" Author="HubChr" Company="Sigmatek" Description="Textpositions were calculated wrong in case Column AlarmNr was deactivated."/>
		<Dokumentation Revision="1.1" Date="2016-07-11" Author="KaiAnd" Company="Sigmatek" Description="--&gt; command channel &quot;ccAlarmChanged&quot; implemented to share changed alarms for external use&#13;&#10;--&gt; ::CreateAlarmTxt(): casts to ^_UNI for building AlarmTxtShort and AlarmTxtLong"/>
		<Dokumentation Revision="1.0" Date="2016-05-13" Author="KaiAnd" Company="Sigmatek" Description="new class &quot;AlarmDisplayList&quot; (old: &quot;AlarmTemporary&quot; from KruAle; upgraded by KaiAnd)"/>
	</RevDoku>
	<Network Name="AlarmDisplayList">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{1330FF43-46DA-41B9-B8EA-BAE527386023}"
				Class      = "_AlarmDisplay"
				Position   = "(810,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Acknowledge"/>
					<Server Name="ActPos"/>
					<Server Name="Delete"/>
					<Server Name="NoActive"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Server Name="SortAlgorithm"/>
					<Client Name="Filter" Value="2#01010"/>
					<Client Name="HistoryTemporary" Value="1"/>
					<Client Name="Lse"/>
					<Client Name="MaxNo"/>
				</Channels>
			</Object>
			<Object
				Name       = "AlarmTxtLong"
				GUID       = "{208F6BFE-2253-4340-BA13-3086C0D6CDF0}"
				Class      = "String"
				Position   = "(300,1050)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "AlarmTxtShort"
				GUID       = "{EF10F060-8F73-4E50-8D5A-6F46839DCA5D}"
				Class      = "String"
				Position   = "(300,900)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
			<Comment Position="(300,630)" Size="(1170,240)" Text="Filter                                                                                                                        &#13;&#10;Bit0 = 1: Beim Alarm wird Zeit gekommen und Zeit gegangen eingetragen  &#13;&#10;Bit1 = 0: Häufigkeit vom Alarm wird nicht gezählt                                            &#13;&#10;Bit2 = 1: Aktive Alarme können nicht gelöscht werden                                    &#13;&#10;Bit3 = 1: Kurztext wird angezeigt                                                                      &#13;&#10;"/>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(1626,210),(1362,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(1626,270),(1362,270),"/>
			<Connection Source="this.Acknowledge" Destination="_base.Acknowledge" Vertices="(1626,330),(1362,450),"/>
			<Connection Source="this.Delete" Destination="_base.Delete" Vertices="(1626,390),(1362,510),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(810,210),(38,210),"/>
			<Connection Source="_base.MaxNo" Destination="this.MaxNo" Vertices="(810,330),(38,270),"/>
			<Connection Source="this.AlarmTxtShort" Destination="AlarmTxtShort.Data"/>
			<Connection Source="this.AlarmTxtLong" Destination="AlarmTxtLong.Data"/>
			<Connection Source="this.AlaTxtShort" Destination="AlarmTxtShort.Data" Vertices="(1626,570),(856,990),"/>
			<Connection Source="this.AlaTxtLong" Destination="AlarmTxtLong.Data" Vertices="(1626,630),(856,1140),"/>
			<Connection Source="this.NoActive" Destination="_base.NoActive" Vertices="(1626,450),(1362,570),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _AlarmDisplay

AlarmDisplayList : CLASS
: _AlarmDisplay
  //Servers:
	HelpTxt 	: SvrCh_DINT;
	AlaTxtShort 	: SvrChCmd_UDINT;
	AlaTxtLong 	: SvrChCmd_UDINT;
  //Clients:
	ColumnChoice 	: CltChCmd__Bit32;
	coAlarmTitle 	: CltChCmd_AlarmTitleLine;
	coSystemLogging 	: CltChCmd_SystemLogging;
	AlarmTxtShort 	: CltChCmd_String;
	AlarmTxtLong 	: CltChCmd_String;
	ccAlarmChanged 	: CltChCmd_DINT;
  //Variables:
		bSetScrollOffset 	: BOOL;
		aColumnWidths : ARRAY [0..AlarmTemp_VariableNo-1] OF DINT;

		IsCon_coAlarmTitle 	: BOOL;
		IsCon_coSystemLogging 	: BOOL;
		pSingleAlarm 	: ^_SINGLEALARM;
		tmpText : ARRAY [0..599] OF _CHAR;

		txtLong : ARRAY [0..599] OF _CHAR;

		txtShort : ARRAY [0..599] OF _CHAR;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when redraw of a single line is necessary.&#13;&#10;ps ..... --&gt; to structure _SCROLL&#13;&#10;pr ..... --&gt; to place where line should be drawn&#13;&#10;line ... number of line which should be drawn&#13;&#10;state .. line ia selected (TRUE) or passive (FALSE)&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to structure _SCROLL" Name="Line.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to place where line should be drawn" Name="Line.pr"/>
			line 	: UINT;			//! <Variable Comment="16 bit linenumber " Name="Line.line"/>
			state 	: BOOL;			//! <Variable Comment="line is selected (true) or passive (false)" Name="Line.state"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL LineHeight
		VAR_INPUT
			preselect 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode (AX) 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when system wants to insert an entry into ringbuffer&#13;&#10;call this methode if you want to add an entry&#13;&#10;if you decide that entry shouldn&apos;t be added, dont call function add_SINGLEALARM() inside&#13;&#10;ptr .... --&gt; to new entry&#13;&#10;at success method returns TRUE, on the other hand FALSE&#13;&#10;" Name="AddEntry"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AddEntry
		VAR_INPUT
			ptr 	: ^_SINGLEALARM;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION WriteAlarmNo
		VAR_INPUT
			uiAlarmNo 	: UINT;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION WriteAlarmText
		VAR_INPUT
			pText 	: ^_CHAR;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION WriteAlarmTime
		VAR_INPUT
			pAlarm 	: ^_SINGLEALARM;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION WriteCycleNo
		VAR_INPUT
			pAlarm 	: ^_SINGLEALARM;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION WriteLine
		VAR_INPUT
			pAlarm 	: ^_SINGLEALARM;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION TableLines
		VAR_INPUT
			sColor 	: _COLOR;
			pRoom 	: ^_ROOM;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION CalcWidth;
				//! <Function Comment="reads two alarm-texts and writes them to objects &quot;AlarmTxtShort&quot; and &quot;AlarmTxtLong&quot;" Name="SetAlarmInfo"/>
	FUNCTION GLOBAL SetAlarmInfo
		VAR_INPUT
			psa 	: ^_SINGLEALARM;			//! <Variable Comment="pointer to a SingleAlarm-object" Name="SetAlarmInfo.psa"/>
		END_VAR;
	
	FUNCTION CreateAlarmTxt
		VAR_INPUT
			psa 	: ^_SINGLEALARM;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HelpTxt::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AlaTxtShort::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AlaTxtShort::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AlaTxtLong::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AlaTxtLong::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _Bit32
#pragma usingLtd AlarmTitleLine
#pragma usingLtd SystemLogging


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AlarmDisplayList::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_ALARMDISPLAYLIST
1$UINT, 2$UINT, (SIZEOF(::AlarmDisplayList))$UINT, 
3$UINT, 6$UINT, 0$UINT, 
TO_UDINT(3279795640), "AlarmDisplayList", //Class
TO_UDINT(1738954212), "_AlarmDisplay", 0$UINT, 9$UINT, //Baseclass
//Servers:
(::AlarmDisplayList.HelpTxt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2529296776), "HelpTxt", 
(::AlarmDisplayList.AlaTxtShort.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(3644404395), "AlaTxtShort", 
(::AlarmDisplayList.AlaTxtLong.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2582741885), "AlaTxtLong", 
//Clients:
(::AlarmDisplayList.ColumnChoice.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3823519998), "ColumnChoice", TO_UDINT(3745297859), "_Bit32", 0$UINT, 1$UINT, 
(::AlarmDisplayList.coAlarmTitle.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3367877714), "coAlarmTitle", TO_UDINT(718326546), "AlarmTitleLine", 1$UINT, 1$UINT, 
(::AlarmDisplayList.coSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(292037947), "coSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 4$UINT, 
(::AlarmDisplayList.AlarmTxtShort.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(938161621), "AlarmTxtShort", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AlarmDisplayList.AlarmTxtLong.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1167577471), "AlarmTxtLong", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AlarmDisplayList.ccAlarmChanged.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(86960371), "ccAlarmChanged", 
END_FUNCTION


#define USER_CNT_AlarmDisplayList 28

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AlarmDisplayList] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AlarmDisplayList::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _AlarmDisplay::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AlarmDisplayList;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #LineHeight();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #AddEntry();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HelpTxt.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HelpTxt::Write() );
	IF HelpTxt.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, AlaTxtShort.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #AlaTxtShort::Read();
	vmt.CmdTable.Write		:= #AlaTxtShort::Write();
	AlaTxtShort.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF AlaTxtShort.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, AlaTxtLong.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #AlaTxtLong::Read();
	vmt.CmdTable.Write		:= #AlaTxtLong::Write();
	AlaTxtLong.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF AlaTxtLong.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL AlarmDisplayList::Init
  
  // Methode der Basis-Klasse
  _AlarmDisplay::Init();
  
  // Horizontale Breite berechnen
  //CalcWidth();
  
  if (_FirstScan) then

    //-------------------------------------------------------------------------
    //  check client-connnections and set flags                   KaiAnd 
    //-------------------------------------------------------------------------
    if (IsClientConnected(#coSystemLogging)) then
      IsCon_coSystemLogging := TRUE;
    else
      IsCon_coSystemLogging := FALSE;
    end_if;
    if (IsClientConnected(#coAlarmTitle)) then
      IsCon_coAlarmTitle := TRUE;
    else
      IsCon_coAlarmTitle := FALSE;
    end_if;
    //-------------------------------------------------------------------------
  end_if;

  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::Line
	VAR_INPUT
		ps 	: ^_SCROLL;
		pr 	: ^_ROOM;
		line 	: UINT;
		state 	: BOOL;
	END_VAR
  VAR
    tmpTextColor  : _COLOR;
    tmpBgColor  : _COLOR; //KAMMIC
    tmpAlarm      : ^_SINGLEALARM;
    tmpLSEAlarm   : ^_SINGLE_ALARM;
    tmpNumber     : UINT; 
  END_VAR
  
  // Übergabeparameter prüfen
  if ps = NIL | pr = NIL then
    return;
  end_if;

  // Anzahl der Einträge in Ringbuffer lesen
  tmpNumber := TO_UINT(no_RINGBUFFER(#Pms^.ringbuffer)); 

  // KaiAnd V.1.0: reset scroll if no Alarm in list
  if(tmpNumber <= 0) then
    ps^.hposition.begin := 0;
    ps^.hposition.pos := 0;
    if (IsCon_coAlarmTitle = True) then    // KaiAnd
      coAlarmTitle.setActLineBegin(NewScrollOffset := pr^.xy1.x);
    end_if;
  end_if;

  // KaiAnd V.1.0: reset mark if too high
  if (ps^.position.pos+1 > ps^.position.no) then
    ps^.position.pos := -1;
  end_if;


  if(line < tmpNumber) then

    // an oberster Stelle der aktuellste Alarm
    line := tmpNumber - line - 1; 
    
    // Pointer zu Alarm bilden
    tmpAlarm := Pms^.ptr + (rpos_RINGBUFFER(#Pms^.ringbuffer, line) * sizeof(_SINGLEALARM)); 
    
    // Pointer zu LSE-Informationen von Alarm bilden
    tmpLSEAlarm := get_ANYTHING(x0  := #tmpAlarm^.anything, 
                                x1  := NIL)$^_SINGLE_ALARM;
    
    // Prüfen ob Informationen verfügbar
    //*****************************************************************************
    if tmpAlarm <> NIL then
    
      // Prüfen ob Alarm in LSE verfügbar
      if tmpLSEAlarm <> NIL then
          
        if state then
          
          tmpTextColor := GetPenColor(x0 := ps^.color_activ);//KAMMIC
          tmpBgColor   := GetBackColor(x0 := ps^.color_activ);//KAMMIC
        else
          // Alarm ist aktiv
          if tmpAlarm^.state = true then
            
            // Alarm wurde quittiert
            if tmpAlarm^.acknowledge = true then
              tmpTextColor := GetPenColor(x0 := tmpLSEAlarm^.quit_active); //KAMMIC
              tmpBgColor   := GetBackColor(x0 := tmpLSEAlarm^.quit_active);//KAMMIC
            // Alarm wurde nicht quittiert
            else
              tmpTextColor := GetPenColor(x0 := tmpLSEAlarm^.active); //KAMMIC
              tmpBgColor   := GetBackColor(x0 := tmpLSEAlarm^.active);//KAMMIC
            end_if;

            
          // Alarm ist nicht aktiv
          else
            
            // Alarm wurde quittiert
            if tmpAlarm^.acknowledge = true then
              tmpTextColor  := GetPenColor(x0 := tmpLSEAlarm^.quit_passive);//KAMMIC
              tmpBgColor  := GetBackColor(x0 := tmpLSEAlarm^.quit_passive);//KAMMIC
            // Alarm wurde nicht quittiert
            else
              tmpTextColor  := GetPenColor(x0 := tmpLSEAlarm^.passive);//KAMMIC
              tmpBgColor  := GetBackColor(x0 := tmpLSEAlarm^.passive); //KAMMIC
            end_if;
            
          end_if;
        end_if;

      // Alarm im LSE nicht definiert
      else
      
        if state then
          tmpTextColor  := GetPenColor(x0 := ps^.color_activ);//KAMMIC
          tmpBgColor  := GetBackColor(x0 := ps^.color_activ);//KAMMIC
        else
          tmpTextColor := ALARMTEMP_SELECTEDCOLOR;//KAMMIC
          tmpBgColor  := GetBackColor(x0 := ps^.color_inactiv);//KAMMIC
        end_if;
      
      end_if;

      
      // Zeile schreiben
      if WriteLine( pAlarm      := tmpAlarm, 
                    pRoom       := pr, 
                    sFont       := ps^.font, 
                    sTextColor  := tmpTextColor, 
                    sBackColor  := tmpBgColor) = false then //KAMMIC
        
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("AlarmDisplayList::Line(): Schreiben der Alarmzeile fehlgeschlagen");
        end_if;
      
      end_if;
      
      // Farbe für Unterteilung bestimmen
      
      //tmpTextColor := Graphic.MakeColor(fgcol := ps^.frame_out, 
      //                                  bgcol := tmpBgColor); //KAMMIC
      
      tmpTextColor := ps^.color_activ;  // KaiAnd V.1.0: change line-color (old version will not work)

      // Zeilenunterteilung zeichnen
      if TableLines(sColor:=tmpTextColor, pRoom:=pr) = false then
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("AlarmDisplayList::Line(): Zeichnen der Zeilenunterteilung fehlgeschlagen");
        end_if;
      else
        if bSetScrollOffset = false then
          bSetScrollOffset := true;
          // Aktuellen Zeilenbeginn für TitleLine speichern
          if (IsCon_coAlarmTitle = True) then    // KaiAnd
            coAlarmTitle.setActLineBegin(NewScrollOffset := pr^.xy1.x);
          end_if;
        end_if;
      end_if;

    // Alarm ist nicht definiert
    //*****************************************************************************
    else
      if (IsCon_coSystemLogging = True) then    // KaiAnd
        coSystemLogging.LogEventText("AlarmDisplayList::Line(): keine Informationen zum Alarm verfügbar");
      end_if;

    end_if;
    
    // Rahmen erneut zeichnen
    DrawButton(#ps^.out_room, T_FILL or T_COPY or T_SOLID, ps^.frametype, INVISIBLE, ps^.frame_out);
    
  end_if; 

END_FUNCTION


FUNCTION AlarmDisplayList::WriteAlarmNo
	VAR_INPUT
		uiAlarmNo 	: UINT;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpText : ARRAY[0..10] OF _CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if pRoom = NIL then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;

  // Alarmnummer zu Zahl wandeln
  DToA( p0 := #tmpText[0], 
        x1 := uiAlarmNo, 
        x2 := ALARMTEMP_CONFIGALARMNO, 
        x3 := sizeof(tmpText[0]));
        
  // Text ausgeben
  OutTextAlign( p0  := #tmpText[0], 
                x1  := 0, 
                p1  := pRoom, 
                x2  := sFont, 
                x3  := ALARMTEMP_ATTRSTANDARD OR ALARMTEMP_ATTRALARMNO, 
                x9  := _DEFFRAME, 
                x4  := sTextColor, 
                x5  := sBackColor, 
                x6  := sBackColor, 
                x7  := sizeof(tmpText[0]));
  
END_FUNCTION


FUNCTION AlarmDisplayList::WriteAlarmTime
	VAR_INPUT
		pAlarm 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpRoom : _ROOM;
  	tmpDate : _DATE;
    tmpTime : _TIME;
    tmpText : ARRAY [0..100] OF _CHAR;
    tmpHelp : ARRAY [0..50] OF _CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if pAlarm = NIL | pRoom = NIL then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
  
  
  // Datum + Zeit gekommen
  //*****************************************************************************
  
  // Platz berechnen
  tmpRoom.xy1.x := pRoom^.xy1.x;
  tmpRoom.xy1.y := pRoom^.xy1.y;
  tmpRoom.xy2.x := pRoom^.xy2.x;
  tmpRoom.xy2.y := pRoom^.xy1.y + to_int(Scroll.line_height) / 2;
  
  // Datum wandeln
  lasal_to_DATE(p0 := #tmpDate, 
                x1 := pAlarm^.date_on);
                
  
  // String erzeugen
  format_date(p0 := #tmpHelp[0], 
              p1 := #tmpDate, 
              x2 := SIZE_DDMMYY);
              
  // String anfügen
  StrNCpy( p0 := #tmpText[0], 
          x1 := sizeof(tmpText[0]), 
          p2 := #tmpHelp[0], 
          x3 := sizeof(tmpHelp[0]),
          ml := sizeof(tmpText)/sizeof(_CHAR));
  
  // Seperator einfügen
  StrCat( p0 := #tmpText[0], 
          x1 := sizeof(_CHAR), 
          p2 := "  ", 
          x3 := sizeof(CHAR));
          
  // Zeit wandeln
  lasal_to_TIME(p0 := #tmpTime, 
                x1 := pAlarm^.time_on);
  
  // String erzeugen
  format_time(p0 := #tmpHelp[0], 
              p1 := #tmpTime, 
              x2 := SIZE_HHMMSS);
              
  // String anfügen
  StrCat( p0 := #tmpText[0], 
          x1 := sizeof(tmpText[0]), 
          p2 := #tmpHelp[0], 
          x3 := sizeof(tmpHelp[0]));
          
  // Datum + Zeit gekommen ausgeben
  OutTextAlign( p0 := #tmpText[0], 
                x1 := 0, 
                p1 := #tmpRoom, 
                x2 := sFont,
                x3 := ALARMTEMP_ATTRSTANDARD OR ALARMTEMP_ATTRTIME,
                x9 := _DEFFRAME,
                x4 := sTextColor,
                x5 := sBackColor,
                x6 := sBackColor,
                x7 := sizeof(tmpText[0]));
                
  
  // Datum + Zeit gegangen
  //*****************************************************************************
  
  // Platz berechnen
  tmpRoom.xy1.x := pRoom^.xy1.x;
  tmpRoom.xy1.y := pRoom^.xy1.y + to_int(Scroll.line_height) / 2;
  tmpRoom.xy2.x := pRoom^.xy2.x;
  tmpRoom.xy2.y := pRoom^.xy2.y;
  
  // Alarm noch aktiv
  //---------------------------------------------
  if pAlarm^.state then
  
    StrCpy( p0 := #tmpText[0], 
            x1 := sizeof(_CHAR), 
            p2 := "  --.--.--     --:--:-- ", 
            x3 := sizeof(CHAR));
            
  // Alarm bereits weg
  //---------------------------------------------
  else
  
    
    // Datum wandeln
    lasal_to_DATE(p0 := #tmpDate, 
                  x1 := pAlarm^.date_off);
                  
    
    // String erzeugen
    format_date(p0 := #tmpHelp[0], 
                p1 := #tmpDate, 
                x2 := SIZE_DDMMYY);
                
    // String anfügen
    StrNCpy( p0 := #tmpText[0], 
            x1 := sizeof(tmpText[0]), 
            p2 := #tmpHelp[0], 
            x3 := sizeof(tmpHelp[0]),
            ml := sizeof(tmpText)/sizeof(_CHAR));
  
    // Seperator einfügen
    StrCat( p0 := #tmpText[0], 
            x1 := sizeof(_CHAR), 
            p2 := "  ", 
            x3 := sizeof(CHAR));
                
    // Zeit wandeln
    lasal_to_TIME(p0 := #tmpTime, 
                  x1 := pAlarm^.time_off);
    
    // String erzeugen
    format_time(p0 := #tmpHelp[0], 
                p1 := #tmpTime, 
                x2 := SIZE_HHMMSS);
                
    // String anfügen
    StrCat( p0 := #tmpText[0], 
            x1 := sizeof(tmpText[0]), 
            p2 := #tmpHelp[0], 
            x3 := sizeof(tmpHelp[0]));
  
  end_if;
          
  // Datum + Zeit gekommen ausgeben
  OutTextAlign( p0 := #tmpText[0], 
                x1 := 0, 
                p1 := #tmpRoom, 
                x2 := sFont,
                x3 := ALARMTEMP_ATTRSTANDARD OR ALARMTEMP_ATTRTIME,
                x9 := _DEFFRAME,
                x4 := sTextColor,
                x5 := sBackColor,
                x6 := sBackColor,
                x7 := sizeof(tmpText[0]));

END_FUNCTION


FUNCTION AlarmDisplayList::WriteCycleNo
	VAR_INPUT
		pAlarm 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpText : ARRAY[0..11] OF _CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if pAlarm = NIL | pRoom = NIL then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;

  // Wert ausgeben
  //------------------------------------------------------------------------
  // Wert zu Zahl wandeln
  if (pAlarm^.no_para > 0) then  // KaiAnd V.1.0: nur wenn Para vorhanden
  
  DToA( p0 := #tmpText[0], 
        x1 := pAlarm^.para[pAlarm^.no_para - 1], 
        x2 := ALARMTEMP_CONFIGCYCLENO, 
        x3 := sizeof(tmpText[0]));
        
  else        // KaiAnd V.1.0: wenn KEIN Para vorhanden, dann LZ ausgeben
    tmpText[0] := ' ';
    tmpText[1] := 0;
  end_if;

  // Text ausgeben
  OutTextAlign( p0  := #tmpText[0], 
                x1  := 0, 
                p1  := pRoom, 
                x2  := sFont, 
                x3  := ALARMTEMP_ATTRSTANDARD OR ALARMTEMP_ATTRCYCLENO, 
                x9  := _DEFFRAME, 
                x4  := sTextColor, 
                x5  := sBackColor, 
                x6  := sBackColor, 
                x7  := sizeof(tmpText[0]));

  
END_FUNCTION


FUNCTION AlarmDisplayList::WriteAlarmText
	VAR_INPUT
		pText 	: ^_CHAR;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR

  // Übergabeparameter prüfen
  if pRoom = NIL then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
 
  // Prüfen ob Text verfügbar
  if pText = NIL then
     
    // Infotext bauen, dass kein Text verfügbar ist
    StrNCpy( p0  := #tmpText[0],  
            x1  := sizeof(_CHAR), 
            p2  := " ALARM IS NOT DEFINED IN LSE", 
            x3  := 1, // HubChr hardcoded source string is always ascii
            ml  := sizeof(tmpText)/sizeof(_CHAR));
  
    pText := #tmpText[0];

  else
    // shift text in order to put a BLANK in front of the text  HubChr V.1.0
    StrNCpy( p0  := #tmpText[1],  
        x1  := sizeof(_CHAR), 
        p2  := pText, 
        x3  := sizeof(_CHAR),
        ml  := sizeof(tmpText)/sizeof(_CHAR));

    tmpText[0] := ' '; // put BLANK in first character

    pText := #tmpText[0];

  end_if;


  // Text ausgeben
  OutTextAlign( p0  := pText, 
                x1  := 0, 
                p1  := pRoom, 
                x2  := sFont, 
                x3  := ALARMTEMP_ATTRTEXT, 
                x9  := _DEFFRAME, 
                x4  := sTextColor, 
                x5  := sBackColor, 
                x6  := sBackColor, 
                x7  := sizeof(pText^));
    
END_FUNCTION


FUNCTION AlarmDisplayList::WriteLine
	VAR_INPUT
		pAlarm 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpRoom   : _ROOM;
    tmpText   : ^_CHAR;
    tmpColor  : _COLOR;
  END_VAR


  // Übergabeparameter prüfen
  if pAlarm = NIL | pRoom = NIL then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;

  // Platz definieren
  tmpRoom.xy1.x := pRoom^.xy1.x;
  tmpRoom.xy1.y := pRoom^.xy1.y;
  tmpRoom.xy2.x := pRoom^.xy2.x;
  tmpRoom.xy2.y := pRoom^.xy2.y;

  //---------------------------------------------------------------------------
  // vorerst komplette Zeile färben   KaiAnd
  //---------------------------------------------------------------------------
  Graphic.Beam( x1:=tmpRoom.xy1.x, y1:=tmpRoom.xy1.y, 
                x2:=tmpRoom.xy2.x, y2:=tmpRoom.xy2.y, 
                attrib:=T_SOLID, color:=sBackColor);

  //---------------------------------------------------------------------------
  // einzelne Spalten füllen
  //---------------------------------------------------------------------------

  // Alarmnummer schreiben
  //------------------------------------------------------------
  // Prüfen ob Alarmnummer dargestellt werden soll
  if ColumnChoice AND 2#1000 then
    // Platz für Alarmnummer bestimmen
    tmpRoom.xy1.x := pRoom^.xy1.x;
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[0]);
    tmpRoom.xy2.y := pRoom^.xy2.y;
    
    // Alarmcode ausgeben
    if WriteAlarmNo(uiAlarmNo   := pAlarm^.no, 
                    pRoom       := #tmpRoom, 
                    sFont       := sFont, 
                    sTextColor  := sTextColor, 
                    sBackColor  := sBackColor) = false then
      bSuccessful := false;
    end_if;
  else
    tmpRoom.xy2.x := tmpRoom.xy1.x; // HubChr v1.2 First column as 0-width - this step is necessary so following columns have a valid start coordinate.
  end_if;
  
  
  // Zeit gekommen / gegangen
  //------------------------------------------------------------
  // Prüfen ob Zeit dargestellt werden soll
  if ColumnChoice AND 2#0100 then
    // Platz für Zeit gekommen /  gegangen bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x;
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[1]);
    tmpRoom.xy2.y := pRoom^.xy2.y;
    
    // Zeit gekommen / gegangen ausgeben
    if WriteAlarmTime(pAlarm      := pAlarm, 
                      pRoom       := #tmpRoom,
                      sFont       := sFont,
                      sTextColor  := sTextColor, 
                      sBackColor  := sBackColor) = false then
      bSuccessful := false; 
    end_if;
  end_if;
  

  // Zyklusnummer (KaiAnd: real "Para1")
  //------------------------------------------------------------
  // Prüfen ob Zyklusnummer dargestellt werden soll
  if ColumnChoice AND 2#0010 then
    // Platz für Zyklusnummer bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x;
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[2]);
    tmpRoom.xy2.y := pRoom^.xy2.y;

//  if (pAlarm^.no_para > 0) then   // leiChr Abfrage -> sonst BoundExceed
    if (pAlarm^.no_para >= 0) then  // KaiAnd V.1.0: Abfrage/Auswertung erfolgt in WriteCycleNo()
      if WriteCycleNo(pAlarm      := pAlarm, 
                      pRoom       := #tmpRoom,
                      sFont       := sFont,
                      sTextColor  := sTextColor, 
                      sBackColor  := sBackColor) = false then
        bSuccessful := false; 
      end_if;
    end_if;
  end_if;
  
  
  // Alarmtext
  //------------------------------------------------------------
  // Prüfen ob Alarmtext dargestellt werden soll
  if ColumnChoice AND 2#0001 then
    // Platz für Alarmtext
    tmpRoom.xy1.x := tmpRoom.xy2.x;//KAMMIC + 5;
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[3]);
    tmpRoom.xy2.y := pRoom^.xy2.y;
    
    // Alarmtext bestimmen
    tmpText := create_alarmtext(p0  := pAlarm, 
                                x1  := false, 
                                p2  := #tmpColor);
    
    // Alarmtext ausgeben
    if WriteAlarmText(pText       := tmpText, 
                      pRoom       := #tmpRoom, 
                      sFont       := sFont, 
                      sTextColor  := sTextColor, 
                      sBackColor  := sBackColor) = false then
      bSuccessful := false; 
    end_if;
  end_if;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::LineHeight
	VAR_INPUT
		preselect 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode (AX) 	: UINT;
	END_VAR

  // doppelte Höhe der Zeile
  retcode := 2 * preselect;
  
END_FUNCTION


FUNCTION AlarmDisplayList::TableLines
	VAR_INPUT
		sColor 	: _COLOR;
		pRoom 	: ^_ROOM;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpRoom   : _ROOM;
  END_VAR
  
  
  // Übergabeparameter prüfen
  if pRoom = NIL then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;  
  
  // Platz definieren
  tmpRoom.xy1.x := pRoom^.xy1.x;
  tmpRoom.xy1.y := pRoom^.xy1.y;
  tmpRoom.xy2.x := pRoom^.xy1.x;
  tmpRoom.xy2.y := pRoom^.xy2.y;

  
  // Trennline zwischen Alarmnummer und Zeit
  //--------------------------------------------------
  // Prüfen ob Trennline dargestellt werden soll
  if ColumnChoice AND 2#1000 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x := pRoom^.xy1.x + to_int(aColumnWidths[0]);
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := pRoom^.xy1.x + to_int(aColumnWidths[0]);
    tmpRoom.xy2.y := pRoom^.xy2.y;

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := sColor);
  end_if;
  
  
  // Trennline zwischen Zeit und Zyklusnummer
  //--------------------------------------------------
  // Prüfen ob Trennline dargestellt werden soll
  if ColumnChoice AND 2#0100 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x += to_int(aColumnWidths[1]);
    tmpRoom.xy2.x += to_int(aColumnWidths[1]);

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := sColor);
  end_if;
  
  
  // Trennline zwischen Zyklusnummer und Beschreibung
  //--------------------------------------------------
  // Prüfen ob Trennline dargestellt werden soll
  if ColumnChoice AND 2#0010 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x += to_int(aColumnWidths[2]);
    tmpRoom.xy2.x += to_int(aColumnWidths[2]);

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := sColor);
  end_if;
  
  
  // Trennline zwischen den Zeilen
  //--------------------------------------------------
  Graphic.Line( x1      := pRoom^.xy1.x, 
                y1      := pRoom^.xy2.y, 
                x2      := pRoom^.xy2.x, 
                y2      := pRoom^.xy2.y, 
                attrib  := T_SOLID, 
                color   := sColor);
  
END_FUNCTION


FUNCTION AlarmDisplayList::CalcWidth
  
  // Breite der Zeile berechnen
  //--------------------------------------------------------------------------------------------
  // Konfiguration der Spalten lesen
  ColumnChoice := ColumnChoice.Read();
  
  LineWidth := 0;
  
  // Nummer
  if ColumnChoice AND 2#1000 then
    LineWidth += aColumnWidths[0];
  end_if;

  // Zeit
  if ColumnChoice AND 2#0100 then
    LineWidth += aColumnWidths[1];
  end_if;
  
  // Zyklusnummer
  if ColumnChoice AND 2#0010 then
    LineWidth += aColumnWidths[2];
  end_if;
  
  // Beschreibung
  if ColumnChoice AND 2#0001 then
    LineWidth += aColumnWidths[3];
  end_if;
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR

  // Prüfen ob sich die Auswahl der Spalten geändert hat
  //-----------------------------------------------------------------------------------------
  if ColumnChoice <> ColumnChoice.Read() then
    
    // Konfiguration speichern
    ColumnChoice := ColumnChoice.Read();
    
    // neue horizontale Breite berechnen
    CalcWidth();
        
    // horizontale Position wieder rücksetzen
    Scroll.hposition.pos := 0;
    
    // neu zeichnen
    Out(pio := pio);
    
  end_if;

  // Basisklasse aufrufen
  //-----------------------------------------------------------------------------------------
  _AlarmDisplay::IF_Run(pio   := pio, 
                        input := input);

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR

  // Methode der Basis-Klasse
  retcode := _AlarmDisplay::GetEvent(ped, pe);
  
  // ScrollOffset wieder zum setzen freigeben
  bSetScrollOffset := false;
    
END_FUNCTION

#pragma warning(disable:75); // disable warning in Line 939
FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  
  VAR
  	pVarLabel       : ^_VARLABEL;
    tmpCounter      : USINT;
    aVarSingle      : ARRAY[0..AlarmTemp_VariableNo-1] of _VARSINGLE;
  END_VAR

  
  // Gültiger Übergabeparameter?
  if (pio <> NIL) & (pio^.theurge <> NIL) then
        
    // variable informations
    //--------------------------------------------------------------
    // check number of variables
    if pio^.theurge^.memvarlabel.no = AlarmTemp_VariableNo then
      
      // pointer to variable informations
      pVarLabel := pio^.theurge^.memvarlabel.ptr;
      
      // loop to store all parameter
      for tmpCounter := 0 to sizeof(aVarSingle) / sizeof(aVarSingle[0]) - 1 do
      
        // save variable informations
        aVarSingle[tmpCounter] := pVarLabel^.info[0];
        
        // check for constant
        if aVarSingle[tmpCounter].state = CONST_VAL then
          aColumnWidths[tmpCounter] := aVarSingle[tmpCounter].value;
        end_if;

        // step to next variable
        pVarLabel += sizeof(_VARLABEL);
        
      end_for;

    end_if;
    
  end_if;
  
  
  // Basisklasse aufrufen
  //-----------------------------------------------------------------------------------------
  _AlarmDisplay::IF_Start(pio, firsttime);

END_FUNCTION
#pragma warning(default:75); 

FUNCTION VIRTUAL GLOBAL AlarmDisplayList::HelpTxt::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
    psa   : ^_SINGLEALARM; 
    line : dint;
    no    : DINT; 
  END_VAR
  
  no := TO_DINT(no_RINGBUFFER(#Pms^.ringbuffer)); 

  if(Scroll.position.pos < no) then
    
    line := no - Scroll.position.pos - 1; 

    psa := Pms^.ptr + (rpos_RINGBUFFER(#Pms^.ringbuffer, to_udint(line)) * sizeof(_SINGLEALARM)); 
    
    SetAlarmInfo(psa:=psa);   //  KaiAnd V.1.0 ... Methode nun integriert 

  else
    SetAlarmInfo(psa:=NIL);   //  KaiAnd V.1.0 ... Methode nun integriert 
    
  end_if;
    
	result := input := HelpTxt;

END_FUNCTION


FUNCTION GLOBAL AlarmDisplayList::SetAlarmInfo
//  KaiAnd V.1.0 ... Methode integriert (vormals via Objekt-Kanal auf AlarmHelpTxt)
	VAR_INPUT
		psa 	: ^_SINGLEALARM;
	END_VAR
  
  pSingleAlarm := psa;
  
  CreateAlarmTxt(pSingleAlarm);

END_FUNCTION

FUNCTION AlarmDisplayList::CreateAlarmTxt
//  KaiAnd V.1.0 ... Methode integriert (vormals via Objekt-Kanal auf AlarmHelpTxt)
	VAR_INPUT
		psa 	: ^_SINGLEALARM;
	END_VAR
  VAR
  	pTxtShort : ^_char;
    pTxtLong  : ^_char;
    tmpColor  : _COLOR;
    tmplength : udint;
  END_VAR
  
  if psa = NIL then
  
    StrCpy(p0:=#txtShort[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));  
    StrCpy(p0:=#txtLong[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));
  
  else
  
    // Alarmtext short bestimmen
    pTxtShort := create_alarmtext(p0  := psa, 
                                  x1  := FALSE, 
                                  p2  := #tmpColor);
                                  
    if pTxtShort <> NIL then
      StrNCpy(p0:=#txtShort[0], x1:=sizeof(_char), p2:=pTxtShort, x3:=sizeof(_char), ml := sizeof(txtShort)/sizeof(_CHAR));
    else
      StrCpy(p0:=#txtShort[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));
    end_if;
    
    
    // Alarmtext long bestimmen
    pTxtLong := create_alarmtext (p0  := psa, 
                                  x1  := TRUE, 
                                  p2  := #tmpColor);
    if pTxtLong <> NIL then                              
      StrNCpy(p0:=#txtLong[0], x1:=sizeof(_char), p2:=pTxtLong, x3:=sizeof(_char), ml := sizeof(txtLong)/sizeof(_CHAR));
    else
      StrCpy(p0:=#txtLong[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));
    end_if;
    
  end_if;
  
  tmplength := StrLen(txt:=#txtShort[0], size:=sizeof(_CHAR));
  AlarmTxtShort.WriteDataOffUni(udlen:=(tmplength+1)*2, udOff:=0, pData:=(#txtShort[0])$^_UNI, usSize:=sizeof(_CHAR)); // V.1.1: cast to ^_UNI
  
  tmplength := StrLen(txt:=#txtLong[0], size:=sizeof(_CHAR));
  AlarmTxtLong.WriteDataOffUni(udlen:=(tmplength+1)*2, udOff:=0, pData:=(#txtLong[0])$^_UNI, usSize:=sizeof(_CHAR));  // V.1.1: cast to ^_UNI
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmDisplayList::AlaTxtShort::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	AlaTxtShort := AlarmTxtShort.Data.Read();
	output := AlaTxtShort;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmDisplayList::AlaTxtShort::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	AlaTxtShort := input;
	result := (AlarmTxtShort.Data.Write(AlaTxtShort))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmDisplayList::AlaTxtLong::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	AlaTxtLong := AlarmTxtLong.Data.Read();
	output := AlaTxtLong;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmDisplayList::AlaTxtLong::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	AlaTxtLong := input;
	result := (AlarmTxtLong.Data.Write(AlaTxtLong))$UDINT;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::AddEntry
	VAR_INPUT
		ptr 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		retcode (AL) 	: BOOL;
	END_VAR
  VAR
	  NiGive	:	CmdStruct;
  	NiGet		:	Results;
  END_VAR
 
  // share the changed alarm
  if (IsClientConnected(#ccAlarmChanged)) then

    NiGive.uiCmd := 1;
    NiGive.aPara[0] := (ptr)$DINT;
    ccAlarmChanged.NewInst(#NiGive, #NiGet);

  end_if;

  // call the base function
  retcode := _AlarmDisplay::AddEntry(ptr:=ptr);

END_FUNCTION
