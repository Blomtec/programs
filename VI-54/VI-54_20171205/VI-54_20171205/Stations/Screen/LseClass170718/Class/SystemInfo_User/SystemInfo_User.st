//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "SystemInfo_User"
	Revision           = "1.0"
	GUID               = "{45232BA0-756B-44CA-A8C6-7AF6272F3DAB}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(420,180)"
	Comment            = "This class writes the system information to a file.">
	<Channels>
		<Client Name="cFileSys" Required="false" Internal="false" Comment="Object channel to _FileSys. Does not have to be connected."/>
		<Client Name="cIP" Required="false" Internal="false" Comment="Object channel to _IP. Does not have to be connected."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.0" Date="2016-04-25" Author="GreJoh" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
	<Network Name="SystemInfo_User">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{F968E377-6FBB-4A95-A8AC-30D70188CD3A}"
				Class      = "DiagnosticUserFunction"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="sStatus"/>
					<Client Name="cSigCLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.sStatus" Destination="_base.sStatus" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using DiagnosticUserFunction

SystemInfo_User : CLASS
: DiagnosticUserFunction
	TYPE
	  t_e_SysInfoSteps :
	  (
	    _IDLE,
	    _CREATE_FILE,
	    _OPEN_FILE,
	    _BUILD_STRING,
	    _WRITE_FILE,
	    _CLOSE_FILE,
	    _FINISHED,
	    _CHECK_STATE,
	    _ERROR
	  )$UDINT;
	END_TYPE
  //Servers:
  //Clients:
	cFileSys 	: CltChCmd__FileSys;
	cIP 	: CltChCmd__IP;
  //Variables:
		ssw_SysInfo 	: t_e_SysInfoSteps;
		ssw_NextStep 	: t_e_SysInfoSteps;
		SystemInfo 	: _Diag_SystemInfo;			//! <Variable Comment="Struct with the system informations." Name="SystemInfo"/>
		DrivePath : ARRAY [0..Diagnostic_MAX_FileFolderString] OF CHAR;
			//! <Variable Comment="Path where the file with system infos will be created." Name="DrivePath"/>
		udDataSize 	: UDINT;			//! <Variable Comment="Size of the received system info data." Name="udDataSize"/>
		dRetID 	: DINT;
		dHandle 	: DINT;
		dIdentification 	: DINT;
		pHandleAddress 	: ^DINT;
		arrDataString : ARRAY [0..Diagnostic_MAX_FileFolderString] OF CHAR;
			//! <Variable Comment="String with the system info data." Name="arrDataString"/>
		udLength 	: UDINT;
		arrIpString : ARRAY [0..19] OF CHAR;
			//! <Variable Comment="String with the IP-Infos." Name="arrIpString"/>
		arrLoader : ARRAY [0..9] OF CHAR;
			//! <Variable Comment="String with the loader version." Name="arrLoader"/>
		dWrittenBytes 	: DINT;			//! <Variable Comment="Number of written bytes." Name="dWrittenBytes"/>
  //Functions:
				//! <Function Comment="Use this method to set the drive path." Name="SetDrivePath"/>
	FUNCTION VIRTUAL GLOBAL SetDrivePath
		VAR_INPUT
			pDP 	: ^CHAR;			//! <Variable Comment="Pointer to the data with the drive path." Name="SetDrivePath.pDP"/>
		END_VAR;
				//! <Function Comment="Receive data." Name="ReceivedData"/>
	FUNCTION VIRTUAL GLOBAL ReceivedData
		VAR_INPUT
			size 	: UDINT;			//! <Variable Comment="Size of the received data." Name="ReceivedData.size"/>
			pdata 	: ^USINT;			//! <Variable Comment="Pointer to the received data." Name="ReceivedData.pdata"/>
			OptCMD 	: USINT;			//! <Variable Comment="Optional command." Name="ReceivedData.OptCMD"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="FALSE..Error&#13;&#10;TRUE..Data received" Name="ReceivedData.retcode"/>
		END_VAR;
				//! <Function Comment="This method will be called cyclic when the diagnostic export is started." Name="WorkMethode"/>
	FUNCTION VIRTUAL GLOBAL WorkMethode;
				//! <Function Comment="Get the actual state." Name="GetWorkState"/>
	FUNCTION VIRTUAL GLOBAL GetWorkState
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Actual state." Name="GetWorkState.retcode"/>
		END_VAR;
				//! <Function Comment="Get error code." Name="GetErrorCode"/>
	FUNCTION VIRTUAL GLOBAL GetErrorCode
		VAR_OUTPUT
			retcode 	: _DiagErrorCode;			//! <Variable Comment="Error code." Name="GetErrorCode.retcode"/>
		END_VAR;
				//! <Function Comment="Set the parameters for the GetAsyncState method." Name="SetAsyncParam"/>
	FUNCTION SetAsyncParam
		VAR_INPUT
			pHandleAddr 	: ^DINT;			//! <Variable Comment="Pointer which is used for the input variable Erg of the method GetAsyncState." Name="SetAsyncParam.pHandleAddr"/>
			dId 	: DINT;			//! <Variable Comment="Variable which is used for the input variable ID of the method GetAsyncState." Name="SetAsyncParam.dId"/>
		END_VAR;
				//! <Function Comment="Method to add a carriage return and a line feed to a string." Name="AddCarriageReturnLineFeed"/>
	FUNCTION AddCarriageReturnLineFeed
		VAR_INPUT
			Destination 	: ^CHAR;			//! <Variable Comment="Pointer to an array of char, where the carriage return should be added." Name="AddCarriageReturnLineFeed.Destination"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0..OK&#13;&#10;-1..Input pointer was NIL" Name="AddCarriageReturnLineFeed.Retcode"/>
		END_VAR;
				//! <Function Comment="Build string with the system information." Name="BuildSysInfoString"/>
	FUNCTION BuildSysInfoString;
				//! <Function Comment="Convert data from ops.uiLoaderVersion into a string." Name="ConvertLoaderVersion"/>
	FUNCTION ConvertLoaderVersion;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _IP


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SystemInfo_User::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_SYSTEMINFO_USER
1$UINT, 0$UINT, (SIZEOF(::SystemInfo_User))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(838769538), "SystemInfo_User", //Class
TO_UDINT(487743715), "DiagnosticUserFunction", 1$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::SystemInfo_User.cFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(194275965), "cFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
(::SystemInfo_User.cIP.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3343732531), "cIP", TO_UDINT(3530626343), "_IP", 1$UINT, 6$UINT, 
END_FUNCTION


#define USER_CNT_SystemInfo_User 6

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SystemInfo_User] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SystemInfo_User::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= DiagnosticUserFunction::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DiagnosticUserFunction::sStatus.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DiagnosticUserFunction::sStatus.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SystemInfo_User;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #SetDrivePath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #ReceivedData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #WorkMethode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetWorkState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetErrorCode();

#pragma warning (default : 74)
	DiagnosticUserFunction::sStatus.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DiagnosticUserFunction::sStatus.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL SystemInfo_User::SetDrivePath
	VAR_INPUT
		pDP 	: ^CHAR;
	END_VAR
  
  cSigCLib.StrCpy(dst0:=#DrivePath[0], src0:=pDP);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL SystemInfo_User::ReceivedData
	VAR_INPUT
		size 	: UDINT;
		pdata 	: ^USINT;
		OptCMD 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  // receive data with the system infos
  retcode := FALSE;
  if ssw_SysInfo = _IDLE then
    if pdata <> 0  & size = sizeof(SystemInfo) then
      // copy data of the pointer to a local variable
      _memcpy(ptr1:=#SystemInfo, ptr2:=pdata, cntr:=size);
      retcode := TRUE;
      // set next step of the ssw
      ssw_SysInfo := _CREATE_FILE;
      udDataSize := size;
      sStatus := BUSY;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SystemInfo_User::WorkMethode


  case ssw_SysInfo of

    // Idle
    //**********************************************************************    
    _IDLE : // Wait for Start Aktion (  RecivedData )


    // Create File
    //**********************************************************************    
    _CREATE_FILE :         
        cSigCLib.StrCat(ps1:=#DrivePath[0], ps2:=Diagnostic_SystemInfoName); 
        
        dRetID := cFileSys.FileCreate_A(Async:=1, dpne:=#DrivePath[0], size:=udDataSize, fill:=0, att:=ATT_CREATE_ALWAYS); 
        ssw_NextStep := _OPEN_FILE;
        SetAsyncParam(pHandleAddr:=#dHandle, dId:=dRetID);
        ssw_SysInfo := _CHECK_STATE;


    // Open File
    //**********************************************************************    
    _OPEN_FILE : 
           
        dRetID := cFileSys.FileOpen_A(Async:=1, filename:=#DrivePath[0], attributes:=ATT_READ_WRITE);
        ssw_NextStep := _BUILD_STRING;
        SetAsyncParam(pHandleAddr:=#dHandle, dId:=dRetID);
        ssw_SysInfo := _CHECK_STATE;
        
        
    // Build String
    //**********************************************************************    
    _BUILD_STRING :  
    
        BuildSysInfoString();
        ssw_SysInfo := _WRITE_FILE;


    // Write File
    //**********************************************************************    
    _WRITE_FILE : 
        udLength := cSigCLib.StrLen(str:=#arrDataString[0]);
        dRetID := cFileSys.FileWrite_AV1(Async:=1, handle:=dHandle, buffer:=#arrDataString[0], length:=udLength);
        ssw_NextStep := _CLOSE_FILE;
        SetAsyncParam(pHandleAddr:=#dWrittenBytes, dId:=dRetID);
        ssw_SysInfo := _CHECK_STATE;


    // Close File
    //**********************************************************************    
    _CLOSE_FILE : 
        dRetID := cFileSys.FileClose_A(Async:=1, handle:=dHandle);
        ssw_NextStep := _FINISHED;
        SetAsyncParam(pHandleAddr:=#dHandle, dId:=dRetID);
        ssw_SysInfo := _CHECK_STATE;
        
        
    // Finished
    //**********************************************************************           
    _FINISHED : sStatus := READY;
        ssw_SysInfo := _IDLE;
        
        
    // Check asynchronous state
    //**********************************************************************    
    _CHECK_STATE :

        dRetID := cFileSys.GetAsyncState(ID:=to_udint(dIdentification), Erg:=pHandleAddress);
        
        case dRetID of          
          
          RT_INVALID_ID,
          RT_ERG_DELETED:
            ssw_SysInfo := _ERROR;
          
          0:    
          
            ssw_SysInfo := ssw_NextStep;  
            
            if ssw_NextStep = _CLOSE_FILE then
              
              if dWrittenBytes <> to_dint(udLength) then
                
                ssw_SysInfo := _ERROR;
                
              end_if;

              
            end_if;    

            
        end_case;
    
    
    // Error
    //**********************************************************************    
    _ERROR :
      
      Fault.ErrorNr := to_dint(ssw_SysInfo);
      Fault.ErrorCode := -1;
      
      sStatus := ERROR;
      ssw_SysInfo := _IDLE;
            
  end_case;


END_FUNCTION


FUNCTION SystemInfo_User::BuildSysInfoString
  VAR
    arrString : ARRAY[0..49] OF CHAR;
  END_VAR

  arrDataString[0] := 0;
  arrIpString[0] := 0;
  
  // Build string (PLCType;OSVersion;SerialNumber;LoaderVersion;IPAdress;Subnet;Gateway)
  
  // Add PLC type
  cSigCLib.StrCpy(dst0:=#arrDataString[0], src0:="PLC Type: ");
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:=#SystemInfo.PLCType[0]);
  AddCarriageReturnLineFeed(Destination:=#arrDataString[0]);
  // Add OS - version
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:="OS-Version: ");
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:=#SystemInfo.OSVersion[0]);
  AddCarriageReturnLineFeed(Destination:=#arrDataString[0]);
  // Add serial number
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:="Serial number: ");
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:=#SystemInfo.SerialNumber[0]);
  AddCarriageReturnLineFeed(Destination:=#arrDataString[0]); 
  // Add Loader version
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:="Loader version: ");
  ConvertLoaderVersion();
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:=#arrLoader[0]);
  cSigCLib.IToA(val:=SystemInfo.LoaderVersion.usLoRev, dst:=#arrString[0], base:=10);
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:=#arrString[0]);
  AddCarriageReturnLineFeed(Destination:=#arrDataString[0]);
  
  // Add Ip Infos       
  arrIpString[0] := 0;
  
  // convert IP address to string
  cIP.ConvertBinToStr(strAddress:=#arrIpString[0], strAddressLen:=20, IPAddress:=SystemInfo.IPInfo.IPAdress$UDINT);
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:="IP address: ");         
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:=#arrIpString[0]);
  AddCarriageReturnLineFeed(Destination:=#arrDataString[0]);
  
  arrIpString[0] := 0;
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:="Subnet: "); 
  
  // convert subnet mask to string
  cIP.ConvertBinToStr(strAddress:=#arrIpString[0], strAddressLen:=20, IPAddress:=SystemInfo.IPInfo.Subnet$UDINT);
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:=#arrIpString[0]);
  AddCarriageReturnLineFeed(Destination:=#arrDataString[0]);       
  
  arrIpString[0] := 0;
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:="Gateway: ");
  
  // convert gateway address to string
  cIP.ConvertBinToStr(strAddress:=#arrIpString[0], strAddressLen:=20, IPAddress:=SystemInfo.IPInfo.Gateway$UDINT);
  cSigCLib.StrCat(ps1:=#arrDataString[0], ps2:=#arrIpString[0]);

END_FUNCTION


FUNCTION SystemInfo_User::ConvertLoaderVersion
  VAR
    usVar : USINT;
    udStrLen : UDINT;
  END_VAR
  
  arrLoader[0] := 0;
  // convert the first hex number to a decimal number
  usVar := ops.uiLoaderVersion.usHiRev AND 2#00001111;
  if usVar < 10 then
    // number is smaller than 10, first array entry is 0
    arrLoader[0] := 48;
    cSigCLib.IToA(val:=usVar, dst:=#arrLoader[1], base:=10);
    // add a "."
    arrLoader[2] := 46;
  else
    // number is bigger than 10, first part of the loader version is this number.
    cSigCLib.IToA(val:=usVar, dst:=#arrLoader[0], base:=10);
    arrLoader[2] := 46;
  end_if;

  // convert the second hex number to a decimal number
  usVar := ops.uiLoaderVersion.usHiRev AND 2#11110000;
  usVar := usVar SHR 4;
  if usVar < 10 then
    // number is smaller than 10, first array entry is 0
    arrLoader[3] := 48;
    cSigCLib.IToA(val:=usVar, dst:=#arrLoader[4], base:=10);
    // add a "."
    arrLoader[5] := 46;
  else
    // number is bigger than 10, second part of the loader version is this number
    cSigCLib.IToA(val:=usVar, dst:=#arrLoader[3], base:=10);
    arrLoader[5] := 46;
  end_if;  
  
  // set conclusive null
  udStrLen := cSigCLib.StrLen(str:=#arrLoader[0]);
  arrLoader[udStrLen] := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SystemInfo_User::GetWorkState
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR

  retcode := sStatus;

END_FUNCTION


FUNCTION SystemInfo_User::SetAsyncParam
	VAR_INPUT
		pHandleAddr 	: ^DINT;
		dId 	: DINT;
	END_VAR

    pHandleAddress := pHandleAddr;
    dIdentification := dId;
    ssw_SysInfo := _CHECK_STATE;

END_FUNCTION


FUNCTION SystemInfo_User::AddCarriageReturnLineFeed
	VAR_INPUT
		Destination 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
  
  Retcode := 0;
  
  if Destination = NIL then
    Retcode := -1;
    return;
  end_if;

  cSigCLib.StrCat(ps1:=Destination, ps2:="$R");
  cSigCLib.StrCat(ps1:=Destination, ps2:="$L");

  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SystemInfo_User::GetErrorCode
	VAR_OUTPUT
		retcode 	: _DiagErrorCode;
	END_VAR

  retcode := Fault;

END_FUNCTION
