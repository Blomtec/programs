//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DiagnosticBase_MaxFunctionNr  100
#define DiagnosticBase_MaxNameLength  100

#define RTF_NO_ERROR 0
#define RTF_FILE_EXISTS  -36

#define Diagnostic_LoadBarWindowNr   10000
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "DiagnosticBase"
	Revision           = "1.5"
	GUID               = "{17ECF9C3-90BE-4C19-A15C-06EFB0EA0C79}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "2 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "The different parts of the diagnostic login at this class. When the diagnostic export starts, the logged in diagnostic parts are called consecutively.">
	<Channels>
		<Server Name="sLogError" GUID="{38950B6C-A599-46D1-95F2-24462AFEDF37}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="File" Comment="Set to 1 to create an entry in the logfile when an error occurs."/>
		<Server Name="sProgress" GUID="{84ABFF16-D627-48CD-88E3-C0D2A49D1926}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the actual progress of the diagnostic export (0-100)."/>
		<Server Name="sStartExport" GUID="{AEAE06CB-1153-468F-A35A-6BD4AD4D5CB7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set this server to 1 to start the diagnostic export."/>
		<Server Name="sStatus" GUID="{830A02F6-3B3A-48A4-9084-1C19271ED2E8}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the actual state of the diagnostic export."/>
		<Server Name="sTraceError" GUID="{DEC32873-CAD1-4643-9AEE-89967E80C32B}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="File" Comment="0..No output at the Debugger Trace&#13;&#10;1..Output at the Debugger Trace ( Message )&#13;&#10;2..Output at the Debugger Trace ( Warning )&#13;&#10;3..Output at the Debugger Trace ( Error   )&#13;&#10;"/>
		<Client Name="cDriveLetter" Required="true" Internal="false" Comment="Channel to read the drive letter. The destination path of the export will start with this drive letter."/>
		<Client Name="cFileSys" Required="false" Internal="false" Comment="Object channel to _FileSys. Does not have to be connected."/>
		<Client Name="cSigCLib" Required="false" Internal="false" Comment="Object channel to SigCLib. Does not have to be connected."/>
		<Client Name="cSystemLogging" Required="false" Internal="false" Comment="Object channel to SystemLogging (optional)."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.5" Date="2016-07-13" Author="Roskri" Company="Sigmatek" Description="Chagned define for diagnostic loadbar window in Lasal Screen"/>
		<Dokumentation Revision="1.4" Date="2016-07-13" Author="KaiAnd" Company="Sigmatek" Description="if define &quot;UC_UNICODE&quot; is not set unitToAscci() will not be used"/>
		<Dokumentation Revision="1.3" Date="2016-06-22" Author="GreJoh" Company="Sigmatek" Description="Added function that the path of the export folder can contain subfolders, which will be created when the export starts."/>
		<Dokumentation Revision="1.2" Date="2016-06-01" Author="GreJoh" Company="Sigmatek" Description="Locale Variable TimeStr -&gt; Array was too short."/>
		<Dokumentation Revision="1.1" Date="2016-05-19" Author="GreJoh" Company="Sigmatek" Description="Client coSystemLogging must not be connected."/>
	</RevDoku>
</Class>
*)
DiagnosticBase : CLASS
	TYPE
#pragma pack(push, 1)
	  _FolderPath : STRUCT
	    FolderPath : ARRAY [0..99] OF CHAR;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _FolderPathList : STRUCT
	    uiFolderNr : UINT;
	    FolderPaths : ARRAY [1..Diagnostic_FolderPath_MAX_Folder] OF _FolderPath;
	  END_STRUCT;
#pragma pack(pop)
	  _FunctionName : ARRAY [0..DiagnosticBase_MaxNameLength-1] OF CHAR;
#pragma pack(push, 1)
	  _FunktionListEntry : STRUCT  //! <Type Comment="Informationen über die angemeldete Funktion" Name="_FunktionListEntry"/>
	    name : _FunctionName;  //! <Type Comment="ID des angemeldetem Recivers.&#13;&#10;" Name="_FunktionListEntry.name"/>
	    pThis : pVoid;
	    pFct_StartAction : pVoid;
	    pFct_GetState : pVoid;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _FunctionList : STRUCT
	    nr : UDINT;
	    Entry : ARRAY [0..DiagnosticBase_MaxFunctionNr-1] OF _FunktionListEntry;
	  END_STRUCT;
#pragma pack(pop)
	  _SSW_DIAG :
	  (
	    DB_WaitForStartTrigger,
	    DB_GetDriveName,
	    DB_CreateDiagnosticFolder,
	    DB_CreateDiagnosticLogFile,
	    DB_CheckInstalledFunction:=4,
	    DB_CheckForNextFunction:=5,
	    DB_CreateFunctionFolder:=6,
	    DB_CallNextFunction:=7,
	    DB_WaitForResponse:=8,
	    DB_Error:=9
	  )$UDINT;
	END_TYPE
  //Servers:
	sStatus 	: SvrChCmd_iprStates;
	sStartExport 	: SvrCh_DINT;
	sProgress 	: SvrCh_UDINT;
	sTraceError 	: SvrCh_DINT;
	sLogError 	: SvrCh_DINT;
  //Clients:
	cSigCLib 	: CltChCmd_SigCLib;
	cSystemLogging 	: CltChCmd_SystemLogging;
	cDriveLetter 	: CltChCmd_String;
	cFileSys 	: CltChCmd__FileSys;
  //Variables:
		InstalledFunctions 	: _FunctionList;			//! <Variable Comment="List with the installed functions." Name="InstalledFunctions"/>
		ActualFunctionIndex 	: UDINT;
		SSW 	: _SSW_DIAG;
		DriveLetter 	: _DiagString;
		DriveLetterFolder 	: _DiagString;			//! <Variable Comment="String with the path of the diagnostic folder (C:\Diagnostic)." Name="DriveLetterFolder"/>
		TmpDP 	: _DiagString;
		dDiagnosticFileHandle 	: DINT;
		LogData : ARRAY [0..500] OF CHAR;
			//! <Variable Comment="String which is written to the diagnostic log file." Name="LogData"/>
		sActTime 	: _TIME;
		sActDate 	: _DATE;
		udOneProgressPart 	: UDINT;			//! <Variable Comment="This is added to the Progress when a function is finished." Name="udOneProgressPart"/>
		udRest 	: UDINT;			//! <Variable Comment="This is added at the end to the progress, so the Progress is 100." Name="udRest"/>
		FolderPathList 	: _FolderPathList;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Use this method to login a function. All functions which are logged in, will be called in case of a diagnostic export." Name="InstallFunction"/>
	FUNCTION VIRTUAL GLOBAL InstallFunction
		VAR_INPUT
			pName 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the function." Name="InstallFunction.pName"/>
			pThis 	: pVoid;			//! <Variable Comment="This pointer." Name="InstallFunction.pThis"/>
			pFct_StartAction 	: pVoid;			//! <Variable Comment="This method of the function will be called when the diagnostic export starts." Name="InstallFunction.pFct_StartAction"/>
			pFct_GetState 	: pVoid;			//! <Variable Comment="Mehod which returns the actual state of the function." Name="InstallFunction.pFct_GetState"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="-1..Max number of functions reached.&#13;&#10;1..OK, function is logged in." Name="InstallFunction.dRetcode"/>
		END_VAR;
				//! <Function Comment="Call this method to write into the debugger trace or to the log file. Configuration with the server sTraceError and sLogError." Name="SetError"/>
	FUNCTION GLOBAL SetError
		VAR_INPUT
			pFunctionName 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the function." Name="SetError.pFunctionName"/>
			pStationName 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the station." Name="SetError.pStationName"/>
			ErrorNr 	: DINT;			//! <Variable Comment="Error number." Name="SetError.ErrorNr"/>
			ErrorCode 	: DINT;			//! <Variable Comment="Error code." Name="SetError.ErrorCode"/>
		END_VAR;
				//! <Function Comment="Create a text for an entry to the debugger trace or to the logfile." Name="CreateTraceText"/>
	FUNCTION CreateTraceText
		VAR_INPUT
			pFunctionName 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the function." Name="CreateTraceText.pFunctionName"/>
			pStationName 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the station." Name="CreateTraceText.pStationName"/>
			ErrorNr 	: DINT;			//! <Variable Comment="Error number." Name="CreateTraceText.ErrorNr"/>
			ErrorCode 	: DINT;			//! <Variable Comment="Error code." Name="CreateTraceText.ErrorCode"/>
			pTraceText 	: ^CHAR;			//! <Variable Comment="Pointer to the created trace text." Name="CreateTraceText.pTraceText"/>
		END_VAR;
				//! <Function Comment="Method to create the first line in the diagnostic-log file. (YYYY-MM-DD;HH-MM-SS;Diagnostic export started)" Name="LogDiagStart"/>
	FUNCTION LogDiagStart;
				//! <Function Comment="Call this method to write a line to the diagnostic log file (date;time;functionname;stationname;state)." Name="LogFunction"/>
	FUNCTION GLOBAL LogFunction
		VAR_INPUT
			pFunctionName 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the function." Name="LogFunction.pFunctionName"/>
			pStationName 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the station." Name="LogFunction.pStationName"/>
			bState 	: BOOL;			//! <Variable Comment="FALSE..Error&#13;&#10;TRUE..Function successfull" Name="LogFunction.bState"/>
		END_VAR;
				//! <Function Comment="Calculate the progress value of one part of the function, and the rest." Name="CalcProgressParts"/>
	FUNCTION CalcProgressParts;
				//! <Function Comment="Split the export folder path.&#13;&#10;e.g.: &quot;C:\Hugo\Sepp\Hans&quot;&#13;&#10; -&gt; 1.: &quot;C:\Hugo&quot;&#13;&#10; -&gt; 2.: &quot;C:\Hugo\Sepp&quot;&#13;&#10; -&gt; 3.: &quot;C:\Hugo\Sepp\Hans&quot;" Name="SplitPath"/>
	FUNCTION SplitPath
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 .. Ok&#13;&#10;-1 .. false length of the path&#13;&#10;-2 .. array is too short" Name="SplitPath.retcode"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd SigCLib
#pragma usingLtd String
#pragma usingLtd SystemLogging


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DiagnosticBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_DIAGNOSTICBASE
1$UINT, 5$UINT, (SIZEOF(::DiagnosticBase))$UINT, 
5$UINT, 4$UINT, 0$UINT, 
TO_UDINT(2315852333), "DiagnosticBase", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DiagnosticBase.sStatus.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3043700589), "sStatus", 
(::DiagnosticBase.sStartExport.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1800768878), "sStartExport", 
(::DiagnosticBase.sProgress.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(751229054), "sProgress", 
(::DiagnosticBase.sTraceError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3312122527), "sTraceError", 
(::DiagnosticBase.sLogError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(525404199), "sLogError", 
//Clients:
(::DiagnosticBase.cSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1539399991), "cSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 14$UINT, 
(::DiagnosticBase.cSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3866353458), "cSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 4$UINT, 
(::DiagnosticBase.cDriveLetter.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3744137883), "cDriveLetter", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::DiagnosticBase.cFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(194275965), "cFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
END_FUNCTION


#define USER_CNT_DiagnosticBase 2

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DiagnosticBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DiagnosticBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DiagnosticBase, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #InstallFunction();

#pragma warning (default : 74)
	sStatus.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF sStatus.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sStartExport.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sStartExport.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sTraceError.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sTraceError.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sLogError.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sLogError.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

// Prototypen für Funktionen
FUNCTION GLOBAL PT_STARTACTION_FNC VAR_INPUT pthis : pvoid; pDP : ^char; END_VAR VAR_OUTPUT dRetcode : DINT; END_VAR;
FUNCTION GLOBAL PT_GETSTATE_FNC VAR_INPUT pthis : pvoid; END_VAR VAR_OUTPUT dRetcode : iprStates; END_VAR;

FUNCTION VIRTUAL GLOBAL DiagnosticBase::InstallFunction
	VAR_INPUT
		pName 	: ^CHAR;
		pThis 	: pVoid;
		pFct_StartAction 	: pVoid;
		pFct_GetState 	: pVoid;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  
  // Maximale Anzahl an Funktionen erreicht.
  dRetcode := -1; 
  
    
  // Kontrolle der Maximalen Anzahl an Funktionen
  if InstalledFunctions.nr < DiagnosticBase_MaxFunctionNr then
    
    // Daten des Funktion eintragen.
    cSigCLib.StrNCpy(dst0:=#InstalledFunctions.Entry[InstalledFunctions.nr].name[0], src0:=pName, count:=DiagnosticBase_MaxNameLength);
    InstalledFunctions.Entry[InstalledFunctions.nr].pThis := pThis ;
    InstalledFunctions.Entry[InstalledFunctions.nr].pFct_StartAction  := pFct_StartAction ;
    InstalledFunctions.Entry[InstalledFunctions.nr].pFct_GetState     := pFct_GetState ;
    
    // Anzahl der Installierten Empfänger erhöhen.
    InstalledFunctions.nr +=1;
    // Funktion erfolgreich installiert.
    dRetcode := 1;
    
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiagnosticBase::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	retStart : dint;
    retStatus: iprStates ;
    tmpLength : udint;
    tmpRetcode : dint;
    i        : UINT;
  END_VAR

  
  case ssw of
    
    DB_WaitForStartTrigger  : // Wait for Trigger to start Export
        if sStartExport <> 0 then
          // Fenster mit dem Ladebalken öffnen
          InsertCmd(x0:=CMD_NEWWINDOW, x1:=Diagnostic_LoadBarWindowNr, x2:=0);
          sProgress := 0;
          sStartExport :=0;
          ssw := DB_GetDriveName;
          sStatus := BUSY;
        end_if;
        
   DB_GetDriveName :
        tmpLength :=  cDriveLetter.GetLength();
        if tmpLength > 0 then
          cDriveLetter.ReadDataOff(udOff:=0, pData:=#DriveLetter[0], udMax:=sizeof(DriveLetter));
          DriveLetter[tmpLength] := 0;
          ssw := DB_CreateDiagnosticFolder;
        else
          // fehler ausgeben.
          sStatus := error;
          ssw := DB_Error;
        end_if;
        
    DB_CreateDiagnosticFolder :
        
        // Zusammenbauen des Export Ordnerpfades
        cSigCLib.StrCpy(dst0:=#DriveLetterFolder[0], src0:=#DriveLetter[0]);
        cSigCLib.StrCat(ps1:=#DriveLetterFolder[0], ps2:=Diagnostic_FolderPath);
        
        // Aufteilen des Ordnerpfades
        tmpRetcode := SplitPath();
        
        if tmpRetcode = 0 then
        
          // For-Schleife zum Erstellen der Ordner
          for i := 1 to FolderPathList.uiFolderNr do
            
            tmpRetcode := cFileSys.CreateDirectory(dirname:=#FolderPathList.FolderPaths[i].FolderPath[0]);
            
            case tmpRetcode of
              
              RTF_NO_ERROR,
              RTF_FILE_EXISTS :
              
            else
              
              // fehler ausgeben.
              sStatus := error;
              ssw := DB_Error;
              return;
            
            end_case;
          
          end_for;
          
        else
        
          // fehler ausgeben.
          sStatus := error;
          ssw := DB_Error;
          return;
          
        end_if;

        ssw := DB_CreateDiagnosticLogFile;
        
        
    DB_CreateDiagnosticLogFile: // Erstellen des Diagnose log Files
        
        // Filepfad zusammenbauen.
        cSigCLib.StrCpy(dst0:=#TmpDP[0], src0:=#DriveLetterFolder[0]);
        cSigCLib.StrCat(ps1:=#TmpDP[0], ps2:="\"); 
        cSigCLib.StrCat(ps1:=#TmpDP[0], ps2:=Diagnostic_LogFile);

        // File erstellen
        tmpRetcode := cFileSys.FileCreate(dpne:=#TmpDP[0], size:=100, fill:=0, att:=ATT_CREATE_ALWAYS);
        
        case tmpRetcode of
          RTF_NO_ERROR,
          RTF_FILE_EXISTS : ssw := DB_CheckInstalledFunction;
        else
          // fehler ausgeben.
          sStatus := error;
          ssw := DB_Error;
        end_case;      
        
        CalcProgressParts();
    
    DB_CheckInstalledFunction: // Prüfen ob sich jemand angemeldet hat.
        if InstalledFunctions.nr > 0 then
          dDiagnosticFileHandle := cFileSys.FileOpen(filename:=#TmpDP[0], attributes:=ATT_READ_WRITE);
          LogDiagStart();
          ActualFunctionIndex := 0;
          ssw := DB_CheckForNextFunction;
        else
          // Fertig. Es sind keine Funktionen installiert worden.
          sProgress += udOneProgressPart;
          ssw := DB_WaitForStartTrigger;
          sStatus := Ready;
        end_if;
        
    DB_CheckForNextFunction: // Prüfen ob wir fertig sind , sonst weiter mit der nächsten Funktion
        if ActualFunctionIndex <= (InstalledFunctions.nr-1) then
          ssw := DB_CreateFunctionFolder;
        else
          // Fertig , alle Funktionen durch.
          if dDiagnosticFileHandle > 0 then
            cFileSys.FileClose(handle:=dDiagnosticFileHandle);
          end_if;
          // schließe das aktuelle Fenster 
          InsertCmd(x0:=CMD_CLOSE, x1:=0, x2:=0);
          sProgress += udRest;
          ssw := DB_WaitForStartTrigger;
          sStatus := Ready;
        end_if;
    
    DB_CreateFunctionFolder:
        cSigCLib.StrCpy(dst0:=#TmpDP[0], src0:=#DriveLetterFolder[0]);
        cSigCLib.StrCat(ps1:=#TmpDP[0], ps2:="\");        
        cSigCLib.StrCat(ps1:=#TmpDP[0], ps2:=#InstalledFunctions.Entry[ActualFunctionIndex].name[0]);

        tmpRetcode := cFileSys.CreateDirectory(dirname:=#TmpDP[0]);

        cSigCLib.StrCat(ps1:=#TmpDP[0], ps2:="\");        
        
        case tmpRetcode of
          RTF_NO_ERROR,
          RTF_FILE_EXISTS : ssw := DB_CallNextFunction;
        else
          // fehler ausgeben.
          sStatus := error;
          ssw := DB_Error;
        end_case;
    
    DB_CallNextFunction: // Aufruf der Funktion -> dort werden die Stationen duchgegangen.
        retStart := InstalledFunctions.Entry[ActualFunctionIndex].pFct_StartAction$PT_STARTACTION_FNC(InstalledFunctions.Entry[ActualFunctionIndex].pThis,#TmpDP[0]);
        if retStart > 0 then 
          // Funktion wurde gestartet
          ssw := DB_WaitForResponse;
        else
          // Fehlermeldung ausgeben + weiter zur nächsten Station
          sProgress += udOneProgressPart;
          ActualFunctionIndex +=1;
          ssw := DB_CheckForNextFunction;
        end_if;
    
    DB_WaitForResponse: // Prüfen wann Funktion fertig ist.
        retStatus :=  InstalledFunctions.Entry[ActualFunctionIndex].pFct_GetState$PT_GETSTATE_FNC(InstalledFunctions.Entry[ActualFunctionIndex].pThis);
        case retStatus of
          iprStates::READY : // Funktion wurde erfolgreich beendet. weiter mit nächster Funktion.
                             ActualFunctionIndex +=1;
                             ssw := DB_CheckForNextFunction;
                             sProgress += udOneProgressPart;
          
          iprStates::ERROR : // Es ist ein Fehler aufgetreten , ErrorCode holen und weiter mit nächster Funktion.
                             ActualFunctionIndex +=1;
                             ssw := DB_CheckForNextFunction;
                             sProgress += udOneProgressPart;
          
          iprStates::BUSY  : // noch beschäfigt , nichts machen.
        else
          // Es ist ein Fehler aufgetreten , ErrorCode holen und weiter mit nächster Funktion.
          sProgress += udOneProgressPart;
          ActualFunctionIndex +=1;
          ssw := DB_CheckForNextFunction;
        end_case;

    DB_Error:
        ssw := DB_WaitForStartTrigger;
  
  end_case;


	state := READY;

END_FUNCTION


FUNCTION GLOBAL DiagnosticBase::SetError
	VAR_INPUT
    pFunctionName : ^CHAR;
		pStationName 	: ^CHAR;
		ErrorNr 	: DINT;
		ErrorCode 	: DINT;
	END_VAR
  VAR
  	tmpTraceTxt : Array [0..199] of Char;
  END_VAR

  // prüfen ob ins Debugger Trace geschrieben werden soll.
  if sTraceError <> 0 then
    CreateTraceText(pFunctionName, pStationName, ErrorNr, ErrorCode, pTraceText:=#tmpTraceTxt[0]);
    case sTraceError of
      1 : TRACE(#tmpTraceTxt[0]);
      2 : TRACE_WARN(#tmpTraceTxt[0]);
      3 : TRACE_ERR(#tmpTraceTxt[0]);
    end_case;
  end_if;
  
  // prüfen ob ins Logfile geschrieben werden soll.
  if sLogError <> 0 then
    CreateTraceText(pFunctionName, pStationName, ErrorNr, ErrorCode, pTraceText:=#tmpTraceTxt[0]);
    if IsClientConnected(#cSystemLogging) then
      cSystemLogging.LogEventText(pChar:=#tmpTraceTxt[0]);
    end_if;
  end_if;
  
  
END_FUNCTION


FUNCTION DiagnosticBase::CreateTraceText
	VAR_INPUT
		pFunctionName 	: ^CHAR;
		pStationName 	: ^CHAR;
		ErrorNr 	: DINT;
		ErrorCode 	: DINT;
		pTraceText 	: ^CHAR;
	END_VAR
  VAR
  	tmpErrorNr : Array [0..199] of Char;
  END_VAR
  
  cSigCLib.StrCpy(dst0:=pTraceText, src0:="Diagnostic : ");
  cSigCLib.StrCat(ps1:=pTraceText, ps2:=pFunctionName);
  cSigCLib.StrCat(ps1:=pTraceText, ps2:=" : ");
  cSigCLib.StrCat(ps1:=pTraceText, ps2:=pStationName);
  cSigCLib.StrCat(ps1:=pTraceText, ps2:=" - Error Nr.: ");
  cSigCLib.IToA(val:=ErrorNr, dst:=#tmpErrorNr[0], base:=10);
  cSigCLib.StrCat(ps1:=pTraceText, ps2:=#tmpErrorNr[0]);
  cSigCLib.StrCat(ps1:=pTraceText, ps2:=" - Error Code: ");
  cSigCLib.IToA(val:=ErrorCode, dst:=#tmpErrorNr[0], base:=10);
  cSigCLib.StrCat(ps1:=pTraceText, ps2:=#tmpErrorNr[0]);
  
END_FUNCTION


FUNCTION DiagnosticBase::LogDiagStart
  VAR
    udLen : UDINT;
    TimeStr : ARRAY[0..9] of _CHAR;
    DateStr : ARRAY[0..10] of _CHAR;
    udStringSize : UDINT;
    tmpStr : ARRAY[0..19] of CHAR;
  END_VAR

  // check if file is opened
  if dDiagnosticFileHandle <= 0 then
    return;
  end_if;

  LogData[0] := 0;

  // get the actual time
  get_TIME(p0:=#sActTime);
  // get the actual date
  get_DATE(p0:=#sActDate);
  format_date(p0:=#DateStr[0], p1:=#sActDate, x2:=SIZE_YYYYMMDD);
  udStringSize := StrLen(txt:=#DateStr[0], size:=sizeof(DateStr[0]));
#ifdef UC_UNICODE
  // convert the unicode string to an ascii string
  UniToAscii(p0:=#tmpStr[0], p1:=#DateStr[0], x2:=udStringSize);
#else
  cSigCLib.StrCpy(dst0:=#tmpStr[0], src0:=(#DateStr[0])$^CHAR);
#endif

  tmpStr[udStringSize] := 0;
  
  // add the actual date to the logging string
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=#tmpStr[0]);
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=";");
  
  format_time(p0:=#TimeStr[0], p1:=#sActTime, x2:=SIZE_HHMMSS);
  udStringSize := StrLen(txt:=#TimeStr[0], size:=sizeof(TimeStr[0]));
#ifdef UC_UNICODE
  // convert the unicode string to an ascii string
  UniToAscii(p0:=#tmpStr[0], p1:=#TimeStr[0], x2:=udStringSize);
#else
  cSigCLib.StrCpy(dst0:=#tmpStr[0], src0:=(#TimeStr[0])$^CHAR);
#endif
  tmpStr[udStringSize] := 0;

  // add the actual time to the logging string
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=#tmpStr[0]);
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=";");
  
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:="Diagnostic export started");
  // add carriage return
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:="$R");
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:="$L");
  
  udLen := cSigCLib.StrLen(str:=#LogData[0]);
  
  // Write the log string to the diagnostic logging file
  cFileSys.FileWrite(handle:=dDiagnosticFileHandle, buffer:=#LogData[0], length:=udLen);


//  cFileSys.FileOpen(filename:=#TmpDP[0], attributes:=ATT_READ_WRITE);
  

END_FUNCTION


FUNCTION GLOBAL DiagnosticBase::LogFunction
	VAR_INPUT
		pFunctionName 	: ^CHAR;
		pStationName 	: ^CHAR;
		bState 	: BOOL;
	END_VAR
  VAR
  	udLen : UDINT;
    TimeStr : ARRAY[0..9] of _CHAR;
    DateStr : ARRAY[0..10] of _CHAR;
    udStringSize : UDINT;
    tmpStr : ARRAY[0..19] of CHAR;
  END_VAR

  if pFunctionName = NIL | pStationName = NIL then
    return;
  end_if;

  // check if file is opened
  if dDiagnosticFileHandle <= 0 then
    return;
  end_if;

  LogData[0] := 0;

  // Get actual date
  get_TIME(p0:=#sActTime);
  // Get actual time
  get_DATE(p0:=#sActDate);
  
  format_date(p0:=#DateStr[0], p1:=#sActDate, x2:=SIZE_YYYYMMDD);
  udStringSize := StrLen(txt:=#DateStr[0], size:=sizeof(DateStr[0]));
#ifdef UC_UNICODE
  // convert the unicode string to an ascii string
  UniToAscii(p0:=#tmpStr[0], p1:=#DateStr[0], x2:=udStringSize);
#else
  cSigCLib.StrCpy(dst0:=#tmpStr[0], src0:=(#DateStr[0])$^CHAR);
#endif
  tmpStr[udStringSize] := 0;
  
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=#tmpStr[0]);
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=";");
  
  format_time(p0:=#TimeStr[0], p1:=#sActTime, x2:=SIZE_HHMMSS);
  udStringSize := StrLen(txt:=#TimeStr[0], size:=sizeof(TimeStr[0]));
#ifdef UC_UNICODE
  // convert the unicode string to an ascii string
  UniToAscii(p0:=#tmpStr[0], p1:=#TimeStr[0], x2:=udStringSize);
#else
  cSigCLib.StrCpy(dst0:=#tmpStr[0], src0:=(#TimeStr[0])$^CHAR);
#endif
  tmpStr[udStringSize] := 0;

  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=#tmpStr[0]);
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=";");
  
  // Add the function name
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=pFunctionName);  
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=";");
  // Add the station name
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=pStationName);
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:=";");
  
  case bState of
    
    FALSE:
      // Error in the function
      cSigCLib.StrCat(ps1:=#LogData[0], ps2:="Error");
    
    TRUE:
      // Function was successfull
      cSigCLib.StrCat(ps1:=#LogData[0], ps2:="Successfull");
    
  end_case;
  
  // add carriage return
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:="$R");
  cSigCLib.StrCat(ps1:=#LogData[0], ps2:="$L");
  
  // Write the log string to the diagnostic logging file
  udLen := cSigCLib.StrLen(str:=#LogData[0]);
  cFileSys.FileWrite(handle:=dDiagnosticFileHandle, buffer:=#LogData[0], length:=udLen);          


END_FUNCTION


FUNCTION DiagnosticBase::CalcProgressParts

  // Calculate the value of one Part
  if InstalledFunctions.nr > 0 then
    udOneProgressPart := (100 / InstalledFunctions.nr);
  else
    udOneProgressPart := 100;
  end_if;
  
  // Calculate the rest
  if udOneProgressPart = 100 then
    udRest := 0;
  else
    udRest := (100 - (udOneProgressPart * InstalledFunctions.nr));
  end_if;
  
END_FUNCTION


FUNCTION DiagnosticBase::SplitPath
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
VAR
	tmpLength : UDINT;
  tmpCounter : USINT;
  i : USINT;
END_VAR

  // ***************************************************************
  // Diese Methode teilt den String mit dem Ordnerpfad in Teile auf,
  // um danach die einzelnen Ordner erstellen zu können.
  // Zum Beispiel: "C:\Hugo\Sepp\Hans", wird aufgeteilt in:
  //    1. Ordnerpfad -> "C:\Hugo"
  //    2. Ordnerpfad -> "C:\Hugo\Sepp"
  //    3. Ordnerpfad -> "C:\Hugo\Sepp\Hans"
  // ***************************************************************
  
  retcode := 0;
  
  tmpCounter := 0;
  
  // Länge des Ordnerpfades holen
  tmpLength := cSigCLib.StrLen(str:=#DriveLetterFolder[0]);
  
  if tmpLength <= 0 then
    retcode := -1;
    return;
  end_if;

  
  for i := 0 to tmpLength - 1 do
    
    // Schauen ob im Ordnerpfad ein "\" steht
    if DriveLetterFolder[i] = '\' then
      
      if tmpCounter = 0 then
      
      elsif tmpCounter > 0 then
        
        // Speichern des Ordnerpfades in einer Struktur
        cSigCLib.StrNCpy(dst0:=#FolderPathList.FolderPaths[tmpCounter].FolderPath[0] , src0:=#DriveLetterFolder[0], count:=i);   
        
      end_if;

      tmpCounter += 1;
      
      // Kontrollieren ob das Array groß genug ist
      if tmpCounter > (sizeof(FolderPathList.FolderPaths) / sizeof(FolderPathList.FolderPaths[1])) then
        
        retcode := -2;

        if IsClientConnected(#cSystemLogging) then
          cSystemLogging.LogEventText(pChar:="DiagnosticBase::SplitPath(): Array für die Ordnerpfade ist zu klein!");
        end_if;        
        
        return;
      end_if;

    
    end_if;
    
    // Letztes Zeichen
    if i = (tmpLength -1) then
      
      // Letzten Ordnerpfad speichern (ist der einzige wenn nur ein Ordner im Pfad enthalten ist)
      if tmpCounter > 0 then
        cSigCLib.StrCpy(dst0:=#FolderPathList.FolderPaths[tmpCounter].FolderPath[0], src0:=#DriveLetterFolder[0]);
        FolderPathList.uiFolderNr := tmpCounter;
      end_if;
    
    end_if;
  
  end_for;

END_FUNCTION
