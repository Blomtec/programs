//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include <.\lsl_st_pci.h>
#include <.\lsl_st_syssernum.h>
#include "..\..\Class\PLC_Info\XRegs.h"
#include <.\LoaderItf.h>
#include <.\lsl_st_sysinfo.h>

(*!
<Class
	Name               = "PLC_Info"
	Revision           = "1.65"
	GUID               = "{558D9A35-A514-4887-AA7B-B932E22A038E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\PLC_Info\C-IPC.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(652,120)"
	Comment            = "class to show extra information about CCL911, CIPC">
	<Channels>
		<Server Name="ApplicationName" GUID="{A21DC7CD-FB10-4EE2-94C4-563AECB7CC68}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="BatteryOk" GUID="{4CE7B2CB-8A5C-4EEF-8422-CE1718AC7C64}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Low warning | 1 = OK"/>
		<Server Name="CPU_Name" GUID="{87A390C1-6C7F-4074-AAA7-09C8A4263635}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="CPUFamily" GUID="{41E60102-1ED0-4DCF-99B3-7AD6E2EB3FD8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="CPUFeatures" GUID="{7756EEEC-B59B-4371-9868-FA7561697A8D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="CPUIDString" GUID="{34CDC86B-BCDB-4B54-A80C-0AB2CA513ABC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Pointer to a 12 byte string"/>
		<Server Name="CPUModel" GUID="{EA9AD75B-BC1D-42D9-9468-C112236506C8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="CPUStepping" GUID="{50B695C8-5438-4117-92DA-751CAAD55B1F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="CPUTemperature" GUID="{264519E2-5D5B-4CD4-8895-6D370FA12D78}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual temperature of processor in °C&#13;&#10;&#13;&#10;-2147483632 = not supported by device"/>
		<Server Name="CPUType" GUID="{D4C5933D-7561-43AE-9266-B54D7CCF8485}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="FanOk" GUID="{D6D9FD5F-78D8-42F9-8E1A-6D98184DF8A1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Fan fault&#13;&#10;1 = OK&#13;&#10;&#13;&#10;-2147483632 = not supported by device"/>
		<Server Name="ProjectRevision" GUID="{4241F0FD-C175-4570-85BD-9F58034C43F2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Revision of the current project in the Format 16#0000xxyy&#13;&#10;where xx is the major revision and yy the minor revision (like 16#00000103 for v1.3)"/>
		<Server Name="SerNum" GUID="{004E30EC-F8AE-46F7-9FB0-26B9D6ED3F3A}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="serial number"/>
		<Server Name="State" GUID="{5EE971A9-0DC5-41CA-8034-9B5B85EC643C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="state of class"/>
		<Server Name="Supply24VOk" GUID="{5508CB8B-34B1-45D6-B991-D2FC4DE5039E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Low warning | 1 = OK"/>
		<Server Name="TemperatureOk" GUID="{1F6FF22B-500D-453C-8FD9-9BC54D12CADA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = High warning&#13;&#10;1 = OK&#13;&#10;&#13;&#10;-2147483632 = not supported by device"/>
		<Server Name="WhoAmI" GUID="{6CABAB76-3CA7-4121-8768-A29B3954CF3C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="32 = CIPC | 36 = CCL911"/>
		<Server Name="XilinxVersion" GUID="{6C63AA4A-B06D-4171-8CAA-F8D1487A189B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual version of xilinx.&#13;&#10;&#13;&#10;16#80000010 .. not supported by device."/>
		<Client Name="AppliName" Required="true" Internal="true"/>
		<Client Name="String0" Required="true" Internal="true"/>
		<Client Name="String1" Required="true" Internal="true"/>
		<Client Name="To_TaskObjectControl" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_pci.h" Include="true"/>
			<File Path=".\lsl_st_syssernum.h" Include="true"/>
			<File Path=".\Class\PLC_Info\cpu_id.c"/>
			<File Path=".\Lsl_st_ifssr.h" Include="false"/>
			<File Path=".\Class\PLC_Info\XRegs.h" Include="true"/>
			<File Path=".\LoaderItf.h" Include="true"/>
			<File Path=".\lsl_st_sysinfo.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="1.65" Date="25.01.2016" Author="EisMic" Company="Sigmatek" Description="Added support to read CPU Temperature on ARM-CPUs."/>
		<Dokumentation Revision="1.64" Date="11.11.2015" Author="ZoePat" Company="Sigmatek" Description="Use the headerfile LoaderItf.h for declaration of function LDR_GetPrjInfo() to prevent compiler error if someone includes the LoaderItf.h as global headerfile."/>
		<Dokumentation Revision="1.63" Date="01.09.2015" Author="EisMic" Company="Sigmatek" Description="Corrected check if temperature sensor is avaialable at hardware for ETVs."/>
		<Dokumentation Revision="1.62" Date="23.10.2014" Author="EisMic" Company="Sigmatek" Description="Prevented access error when trying to get xilinx version at arm-cpus."/>
		<Dokumentation Revision="1.61" Date="04.09.2014" Author="PieSte" Company="Sigmatek" Description="Implemented release version on Edge2- Platform. Initialized not supported features/servers with invalid values."/>
		<Dokumentation Revision="1.60" Date="06.03.2014" Author="EisMic&#13;&#10;RamAnd&#13;&#10;" Company="Sigmatek" Description="BatteryOk and Supply24VOk is now also supported on ARM CPUs.&#13;&#10;Added support for SDIAS PC"/>
		<Dokumentation Revision="1.50" Date="20.01.2014" Author="RamAnd" Company="Sigmatek" Description="Added server ProjectRevision to show the revision of the actual project."/>
		<Dokumentation Revision="1.40" Date="06.12.2013" Author="LanSte" Company="Sigmatek" Description="Added missing h file"/>
		<Dokumentation Revision="1.30" Date="12.09.2013" Author="ZoePat" Company="Sigmatek" Description="Corrected error at EEProm read. Support ARM to read SerNum and AppliName."/>
		<Dokumentation Revision="1.20" Date="30.08.2013" Author="FucHer" Company="Sigmatek" Description="Changed AWL code to Structured Text."/>
		<Dokumentation Revision="1.16" Date="19.03.2012" Author="ZoePat" Company="Sigmatek" Description="BatteryOk and Supply24VOk is now also supported on Edge ETVs."/>
		<Dokumentation Revision="1.15" Date="14.07.2011" Author="BleErn" Company="Sigmatek" Description="Corrected handling of CPU-temperature on ETV-Platform (Only available for all ETV 19&quot; and ETV 1561-H)"/>
		<Dokumentation Revision="1.14" Date="02.05.2011" Author="RamAnd" Company="Sigmatek" Description="Name of application can now also be visualized."/>
		<Dokumentation Revision="1.13" Date="17.03.2010" Author="RamAnd" Company="Sigmatek" Description="Added support for CCP511 and Edge ETVs"/>
		<Dokumentation Revision="1.12" Date="09.11.2009" Author="RamAnd" Company="Sigmatek" Description="Fan and Temperature info is now displayed correctly on ETVs with new FPGA"/>
		<Dokumentation Revision="1.11" Date="17.03.2009" Author="HaaPet" Company="Sigmatek" Description="PH001: display the application name (project name)"/>
		<Dokumentation Revision="1.10" Date="02.02.2009" Author="RamAnd" Company="Sigmatek" Description="corrected for loop count variable type. could have lead to a memory problem."/>
	</RevDoku>
	<Network Name="PLC_Info">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "AppliName"
				GUID       = "{FCD65643-5EB5-4660-B272-DD83947A9B9D}"
				Class      = "String"
				Position   = "(210,1140)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "String0"
				GUID       = "{2A456D16-DF61-49B5-BEAB-DE5021938093}"
				Class      = "String"
				Position   = "(240,330)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "String1"
				GUID       = "{226FE40A-CB64-43F2-93A2-57B7B1968D48}"
				Class      = "String"
				Position   = "(240,750)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.SerNum" Destination="String0.Data" Vertices="(968,630),(796,420),"/>
			<Connection Source="this.CPU_Name" Destination="String1.Data" Vertices="(968,750),(796,840),"/>
			<Connection Source="this.String0" Destination="String0.Data"/>
			<Connection Source="this.String1" Destination="String1.Data"/>
			<Connection Source="this.AppliName" Destination="AppliName.Data"/>
			<Connection Source="this.ApplicationName" Destination="AppliName.Data" Vertices="(968,1170),(766,1230),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
PLC_Info : CLASS
	TYPE
	  s_Version : STRUCT
	    ModelStepping : HSINT;
	    TypeFamily : HSINT;
	    res0 : INT;
	  END_STRUCT;
	  s_cpu_info : STRUCT
	    MaxID : DINT;
	    IDString : ARRAY [0..11] OF CHAR;
	    VersionInformation : s_Version;
	    Res0 : DINT;
	    FeatureInformation : BDINT
	    [
	      1 FPU,
	      2 VME,
	      3 DE,
	      4 PSE,
	      5 TSC,
	      6 MSR,
	      7 PAE,
	      8 MCE,
	      9 CXS,
	      10 APIC,
	      13 MTRR,
	      14 PGE,
	      15 MCA,
	      16 CMOV,
	      24 MMX,
	    ];
	    Res1 : DINT;
	  END_STRUCT;
	  s_DiasInfoType : STRUCT
	    DiasType : UDINT;
	    DiasHWPointer : UDINT;
	    CDIASType : UDINT;
	    CDIASHWPointer : UDINT;
	    CfgRegsType : UDINT;
	    CfgRegsHWPointer : UDINT;
	    XregsType : UDINT;
	    XregsHWPointer : UDINT;
	    PLLType : UDINT;
	    PLLHWPointer : UDINT;
	    EERType : UDINT;
	    EERPointer : UDINT;
	  END_STRUCT;
#pragma pack(push, 1)
	  s_Fan : STRUCT
	    Temperature : INT;
	    Fan1rps : USINT;
	    Fan2rps : USINT;
	    StatusRegister : BSINT
	    [
	      1 PWMactive,
	      2 TwoFanMode,
	      3 Fan1OK,
	      4 Fan2OK,
	      5 TempLimitOK,
	      6 FullSpeed,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  s_SdiasPC : STRUCT
	    CpuTemp : USINT;
	    MemTemp : USINT;
	    SysTemp : USINT;
	    Reserved0 : USINT;
	    PWMHighTime : USINT;
	    PWMPeriod : USINT;
	    Reserved1 : UINT;
	    Fan1rps : UINT;
	    Fan2rps : UINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	State 	: SvrChCmd_IO_State;
	XilinxVersion 	: SvrCh_HDINT;
	BatteryOk 	: SvrCh_DINT;
	Supply24VOk 	: SvrCh_DINT;
	TemperatureOk 	: SvrCh_DINT;
	CPUTemperature 	: SvrCh_DINT;
	FanOk 	: SvrCh_DINT;
	SerNum 	: SvrChCmd_UDINT;
	WhoAmI 	: SvrCh_DM_CPU_Types;
	CPU_Name 	: SvrChCmd_UDINT;
	CPUIDString 	: SvrCh_HDINT;
	CPUModel 	: SvrCh_DINT;
	CPUStepping 	: SvrCh_DINT;
	CPUType 	: SvrCh_DINT;
	CPUFamily 	: SvrCh_DINT;
	CPUFeatures 	: SvrCh_BDINT;
	ApplicationName 	: SvrChCmd_UDINT;
	ProjectRevision 	: SvrCh_HDINT;
  //Clients:
	String0 	: CltChCmd_String;
	To_TaskObjectControl 	: CltChCmd__TaskObjectControl;
	String1 	: CltChCmd_String;
	AppliName 	: CltChCmd_String;
  //Variables:
		us_Firstscan 	: USINT;
		p_XilinxRegs 	: pVoid;
		p_PWMRegs 	: pVoid;
		pSPCIInfo 	: ^LSL_SPCIINFO;
		b_TempOk 	: BOOL;
		b_StateRegsOk 	: BOOL;
		b_CheckFanOk 	: BOOL;
		ud_Timestamp 	: UDINT;
		p_PLCInfo 	: ^LSL_PLCINFO;
		pISysSernum 	: ^LSL_ISYSSERNUM;
		us_NoTask 	: USINT;
		p_period 	: ^UINT;
		ui_TempDivisor 	: UINT;
		ui_TempMult 	: UINT;
		ui_TempOffset 	: UINT;
		cpu_id_data 	: s_cpu_info;
		p_Fan 	: ^s_Fan;
		p_SdiasPc 	: ^s_SdiasPC;
		ErrXREGS 	: UDINT;
		pT_XREGS 	: ^T_XREGS;
		pLSLSysInfo 	: ^LSL_SYSINFO_TYPE;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			InEAX (EAX) 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _TaskObjectControl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB PLC_Info::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_PLC_INFO
1$UINT, 65$UINT, (SIZEOF(::PLC_Info))$UINT, 
18$UINT, 4$UINT, 0$UINT, 
TO_UDINT(1551372421), "PLC_Info", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::PLC_Info.State.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
(::PLC_Info.XilinxVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3261876988), "XilinxVersion", 
(::PLC_Info.BatteryOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3075126500), "BatteryOk", 
(::PLC_Info.Supply24VOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(13545095), "Supply24VOk", 
(::PLC_Info.TemperatureOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1298369681), "TemperatureOk", 
(::PLC_Info.CPUTemperature.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(435927272), "CPUTemperature", 
(::PLC_Info.FanOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3738308276), "FanOk", 
(::PLC_Info.SerNum.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2137718556), "SerNum", 
(::PLC_Info.WhoAmI.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(808643972), "WhoAmI", 
(::PLC_Info.CPU_Name.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1310162464), "CPU_Name", 
(::PLC_Info.CPUIDString.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4243460179), "CPUIDString", 
(::PLC_Info.CPUModel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1531260384), "CPUModel", 
(::PLC_Info.CPUStepping.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4232916659), "CPUStepping", 
(::PLC_Info.CPUType.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2415762775), "CPUType", 
(::PLC_Info.CPUFamily.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3238091204), "CPUFamily", 
(::PLC_Info.CPUFeatures.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3106788165), "CPUFeatures", 
(::PLC_Info.ApplicationName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(4271568587), "ApplicationName", 
(::PLC_Info.ProjectRevision.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3973626999), "ProjectRevision", 
//Clients:
(::PLC_Info.String0.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1600431117), "String0", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::PLC_Info.To_TaskObjectControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2751224004), "To_TaskObjectControl", TO_UDINT(1584830088), "_TaskObjectControl", 1$UINT, 1$UINT, 
(::PLC_Info.String1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(677614747), "String1", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::PLC_Info.AppliName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1033413914), "AppliName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_PLC_Info 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_PLC_Info] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION PLC_Info::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_PLC_Info, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SerNum.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	SerNum.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SerNum.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CPU_Name.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	CPU_Name.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CPU_Name.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, ApplicationName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	ApplicationName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ApplicationName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

(*******************************************************************************
*
*	Class for some PLC infos (CIPC and CCL911 at the moment)
*	Created: 	SR 	/ 	17.01.2005
*
*
*   FOR NEWER CHANGES SEE REVISION DOCUMENTATION OF CLASS
*
*
*		1.7 => 1.8	/	14.11.2007	/	Mark:	//ws002
*			read CPU identification of 586+ cpus.
*		1.6 => 1.7	/	25.01.2006	/	Mark:	//#SR005
*			read temperature of ETV 1561
*		1.5 => 1.6	/	08.01.2006	/	Mark:	//#SR004
*			insert Server with CPUName String
*		1.4 => 1.5	/	04.12.2006	/	Mark:	//#SR003
*			bug in ETV when DIAS - Bus not avaiable
*		1.3 => 1.4	/	29.11.2006	/	Mark:	//#SR002
*			make compatible to ETV terminals
*		1.2 => 1.3	/	25.09.2006	/	Mark:	//#SR001
*			make a global type for _WhoAmI Server to show names of CPU's
*		1.1 => 1.2	/	09.09.2005	/	Mark:	//#SR000
*			make compatible to Neureder Teachbox	
*		1.0 => 1.1 	/ 	07.06.2005	/	Mark:	//ws001
*			replacement of pointer offsets with data structures
*	
*******************************************************************************)

FUNCTION __cdecl cpu_id 
VAR_INPUT 
param : UDINT;	
ret0	: ^USINT; 
END_VAR;


//FUNCTION GLOBAL LDR_GetPrjInfo
//VAR_INPUT
//  pRevHi : ^HSINT;
//  pRevLo : ^HSINT;
//  ppName : ^PCHAR;
//END_VAR
//VAR_OUTPUT
//  result : BOOL;
//END_VAR;

#define INVALID	16#80000010

FUNCTION VIRTUAL GLOBAL PLC_Info::Init
VAR
	//p_p2cil     		: ^pVoid;              // pointer to interface
	p_p2cil 			: ^s_DiasInfoType;
	p_sigmatek_devinfo 	: ^PCICONFDATA;
 	a_name				: ARRAY[0..16] OF USINT;  // max 16 chars + 1 byte closing 0
  SingleChar    : UINT;   // OS_EE_Read returns 1byte char and 1byte 0 for closing the string
  i           : UINT;
  retcode     : UDINT;
  startdelay : UDINT;
  HiRev : HSINT;
  LoRev : HSINT;
  pPrjName : ^CHAR;
	pFunction : ^void;
END_VAR

	if us_Firstscan = 0 then
    
		WhoAmI$UDINT	:= _WhoAMI;		//#SR001 (cast)
    
    //delay for eeprom-read (not available if started too early) - 1ms looks just fine
    startdelay := ops.tAbsolute;
    WHILE (ops.tAbsolute - startdelay) < 2 DO // changed to 2 for at least 1ms delay
    END_WHILE;
  
  
		a_name[ 0 ] := 0;
    
    //Get CPU - Name
    if ( _LSL_POS^.piSSR^.EE_Read <> NIL ) then
      for i := 0 to 15 do
        retcode := OS_SSR_EE_Read(16#70 + i, #SingleChar);
        if ( SingleChar < 32 | SingleChar = 255 ) then
          a_name[i] := 0;
          exit;
        else
          a_name[i] := SingleChar$USINT; // copy only the char
        end_if;
      end_for;
      String1.WriteDataOff( udLen:= i, udOff := 0, pData := #a_name[ 0 ] );
    end_if;


(*//#SR002
		//#SR000 start
		case _WhoAmI of
			32:		CPUName := CIPC;
			36:		CPUName := CCL911;
			43:		CPUName := CCL911Neureder;
			else	CPUName := Undefined;
		end_case;
		//#SR000 start
*)		
		//Look if we have a CIPC device
		case WhoAmI of						//#SR000		//#SR002 (instead of CPUName )

			//----------------------------------------------------------------------------------------------
			C_IPC_CPU:						//#SR002 CIPC:	
				
				State.uiIO_Flags := 0;
				us_Firstscan := 1;

#ifdef _LSL_TARGETARCH_X86
				cpu_id( 0, ( #cpu_id_data.MaxID )$^usint );
#endif
#ifdef _LSL_TARGETARCH_ARM
        cpu_id_data.MaxID := 0;
        _memcpy(#cpu_id_data.IDString[0], "ARM ARM ARM ", cntr:=12);
#endif
				if( cpu_id_data.MaxID >= 1 )then
#ifdef _LSL_TARGETARCH_X86
					cpu_id( 1, ( #cpu_id_data.VersionInformation )$^usint );
#endif
#ifdef _LSL_TARGETARCH_ARM
          cpu_id_data.VersionInformation.ModelStepping := 0;
          cpu_id_data.VersionInformation.TypeFamily    := 0;
          cpu_id_data.FeatureInformation := 0;
#endif
				end_if;
				CPUIDString := ( #cpu_id_data.IDString )$hdint;
				CPUModel := ( cpu_id_data.VersionInformation.ModelStepping shr 4 ) and 16#0f;
				CPUStepping := cpu_id_data.VersionInformation.ModelStepping and 16#0f;
				CPUType := ( cpu_id_data.VersionInformation.TypeFamily shr 4 ) and 16#03;
				CPUFamily := cpu_id_data.VersionInformation.TypeFamily and 16#0f;
				CPUFeatures := cpu_id_data.FeatureInformation;

				// then we have got a CIPC
				if OS_CILGET( "PCICONFIG", #pSPCIInfo ) =  SYS_ERR_NONE then
					p_sigmatek_devinfo 	:= SPCIINFO_FINDDEVICE( 0x0000,0 );
					XilinxVersion 		:= to_udint( p_sigmatek_devinfo^.Version );

					if p_sigmatek_devinfo^.Version >= 16#12 then
					// only possible with Xilinx version 1.2

						b_StateRegsOk := 1; 
						b_TempOk := 1;

						// check fan check ok
						p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0E28,0 );
				
						if p_sigmatek_devinfo <> NIL then
							p_PWMRegs := SPCIINFO_GETADDRESS( p_sigmatek_devinfo );
					
							if p_PWMRegs <> NIL then
								b_CheckFanOk := 1;
							end_if;
						end_if;				
						
					elsif p_sigmatek_devinfo^.Version = 16#11 then
					// only possible with Xilinx version 1.1

						b_StateRegsOk := 1; 
					end_if;

					if OS_CILGET( "DiasInfo", #p_p2cil ) = SYS_ERR_NONE then
						//p_XilinxRegs	:= ( p_p2cil+28 )^;
						p_XilinxRegs := ( p_p2cil^.XregsHwPointer )$^void; //ws001
					
					//#SR003 start
						if ( p_XilinxRegs = NIL ) then
							us_NoTask := 1;
							BatteryOk$UDINT := INVALID;
							Supply24VOk$UDINT := INVALID;
							TemperatureOk$UDINT := INVALID;
						end_if;	
					else
						us_NoTask := 1;
						BatteryOk$UDINT := INVALID;
						Supply24VOk$UDINT := INVALID;
						TemperatureOk$UDINT := INVALID;

					//#SR003 end
					end_if;
				
				//#SR003 start
				else
					us_NoTask := 1;
					BatteryOk$UDINT := INVALID;
					Supply24VOk$UDINT := INVALID;
					TemperatureOk$UDINT := INVALID;
					CPUTemperature$UDINT := INVALID;
					FanOk$UDINT := INVALID;
					XilinxVersion$UDINT := INVALID;
				//#SR003 end
				end_if;				

			//----------------------------------------------------------------------------------------------
			//Or if we have a CCL911 device
			CCL911_CPU, Teachbox_CPU, ETV_CPU, CCP511_CPU, ETVEDGE_CPU:								//#SR002 CCL911,CCL911Neureder:			//#SR000

				CPUTemperature		:= INVALID$DINT;
				TemperatureOk		:= INVALID$DINT;
				FanOk				:= INVALID$DINT;

				State.uiIO_Flags := 0;
				us_Firstscan := 1;
		
#ifdef _LSL_TARGETARCH_X86
				cpu_id( 0, ( #cpu_id_data.MaxID )$^usint );
#endif
				if( cpu_id_data.MaxID >= 1 )then
#ifdef _LSL_TARGETARCH_X86
					cpu_id( 1, ( #cpu_id_data.VersionInformation )$^usint );
#endif
				end_if;
				CPUIDString := ( #cpu_id_data.IDString )$hdint;
				CPUModel := ( cpu_id_data.VersionInformation.ModelStepping shr 4 ) and 16#0f;
				CPUStepping := cpu_id_data.VersionInformation.ModelStepping and 16#0f;
				CPUType := ( cpu_id_data.VersionInformation.TypeFamily shr 4 ) and 16#03;
				CPUFamily := cpu_id_data.VersionInformation.TypeFamily and 16#0f;
				CPUFeatures := cpu_id_data.FeatureInformation;

				// then we have got a CIPC
				if OS_CILGET( "PCICONFIG", #pSPCIInfo ) =  SYS_ERR_NONE then
					p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0000,0 );
					XilinxVersion := to_udint( p_sigmatek_devinfo^.Version );

					if OS_CILGET( "DiasInfo", #p_p2cil ) = SYS_ERR_NONE then
						//p_XilinxRegs	:= ( p_p2cil + 28 )^;
						p_XilinxRegs := ( p_p2cil^.XregsHwPointer )$^void; //ws001

					//#SR003 start
						if ( p_XilinxRegs = NIL ) then
							us_NoTask := 1;
							BatteryOk$UDINT := INVALID;
							Supply24VOk$UDINT := INVALID;
						end_if;	
					else
            p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0730,0 );
            if ( p_sigmatek_devinfo <> NIL ) then
              p_XilinxRegs := ( SPCIINFO_GETADDRESS( p_sigmatek_devinfo ) )$^UINT;
              us_NoTask := 0;
              BatteryOk$UDINT := 0;
              Supply24VOk$UDINT := 0;
            else
              us_NoTask := 1;
              BatteryOk$UDINT := INVALID;
              Supply24VOk$UDINT := INVALID;
            end_if;
					//#SR003 end
					end_if;

					//#SR005 start
					//look for temperature
          p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0E70,0 );
          if p_sigmatek_devinfo = NIL then
            if ( XilinxVersion <= 16#13 ) then
              p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0920,0 );
            else
              p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0920,16#10 );
            end_if;          

            //look if device is found
            if ( p_sigmatek_devinfo <> NIL ) then
              p_period := ( SPCIINFO_GETADDRESS( p_sigmatek_devinfo ) )$^UINT;
              // According to SilBer (SA 18936): only ETV1561H & all 19" ETV's do have a temperature sensor
              if   WhoAmI = ETV_CPU 
                 & _strcmp(str1:="ETV 1561-H", str2:=#a_name[0]) <> 0
                 & _memcmp(ptr1:="ETV 19", ptr2:=#a_name[0], cntr:=6) <> 0 then
                p_period := NIL;
              end_if;

              //start task
              if ( p_period <> NIL ) then

                case ( ( p_sigmatek_devinfo + 13 )$^USINT )^ of
                  16#30: 	ui_TempDivisor 	:= 10;
                      ui_TempMult		:= 1;
                      ui_TempOffset 	:= 273;
                      us_NoTask := 0;
                  16#31:	ui_TempDivisor 	:= 1;
                      ui_TempMult		:= 1;
                      ui_TempOffset 	:= 273;
                      us_NoTask := 0;
                  16#32:	ui_TempDivisor 	:= 1;
                      ui_TempMult		:= 10;
                      ui_TempOffset 	:= 273;
                      us_NoTask := 0;
                  16#38:	ui_TempDivisor 	:= 10;
                      ui_TempMult		:= 1;
                      ui_TempOffset 	:= 0;
                      us_NoTask := 0;
                  16#39:	ui_TempDivisor 	:= 1;
                      ui_TempMult		:= 1;
                      ui_TempOffset 	:= 0;
                      us_NoTask := 0;
                  16#3A:	ui_TempDivisor 	:= 1;
                      ui_TempMult		:= 10;
                      ui_TempOffset 	:= 0;
                      us_NoTask := 0;
                end_case;
              end_if;
            else
              p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0700,0 );
              if p_sigmatek_devinfo <> NIL then
                p_SdiasPc := ( SPCIINFO_GETADDRESS( p_sigmatek_devinfo ) )$^s_SdiasPC;
              end_if;
            end_if;
          else
            // According to SilBer (SA 18936): only ETV1561H & all 19" ETV's do have a temperature sensor
            p_Fan := ( SPCIINFO_GETADDRESS( p_sigmatek_devinfo ) )$^s_Fan;
            if   WhoAmI = ETV_CPU 
               & _strcmp(str1:="ETV 1561-H", str2:=#a_name[0]) <> 0
               & _memcmp(ptr1:="ETV 19", ptr2:=#a_name[0], cntr:=6) <> 0 then
              p_Fan := NIL;
            end_if;
            TemperatureOk$UDINT := INVALID;
            FanOk$UDINT				    := INVALID;
          end_if;
					//#SR005 end

				//#SR003 start
				else
					us_NoTask := 1;
					BatteryOk$UDINT := INVALID;
					Supply24VOk$UDINT := INVALID;
					XilinxVersion$UDINT := INVALID;
				//#SR003 end
				end_if;
			
      ARM_IMX6_CPU :    // e.g.: HZS 731-H, HGT 1035-H  CP111   
      
				CPUTemperature  := INVALID$DINT;
				TemperatureOk		:= INVALID$DINT;
				FanOk				    := INVALID$DINT;
        XilinxVersion   := INVALID$HDINT;
  
        State.uiIO_Flags := 0;
        us_Firstscan := 1;
        us_NoTask := 0;
          
        ErrXREGS := OS_CILGET("IXREGS", #pT_XREGS);

        if ErrXREGS$SYS_ERROR <> SYS_ERR_NONE then
          pT_XREGS := NIL;
        end_if;    
        
        if OS_CILGET( "PCICONFIG", #pSPCIInfo ) =  SYS_ERR_NONE then
          p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0000,0 );
          //Check pointer, because if hardware has no fpga inside the pointer is nil
          if p_sigmatek_devinfo then
            XilinxVersion := to_udint( p_sigmatek_devinfo^.Version );   
          end_if;
        end_if;              
        
        //Get OS-Interface for system info (to get CPU Temperature)
        OS_CILGET(INTERFACE_LSL_SYSINFO, #pLSLSysInfo);

        
        // at the moment we have not more informations avaliable
        // it would be best if we get an OS-Interface for CPUInfo


			else													//#SR002 Undefined:						//#SR000

				State.uiIO_Flags.WrongHW := 1;
				State.uiIO_Flags.PhysicAccessOff := 1;
		end_case;

		//-----------------------------------------------------------------------------------------------
		if State.uiIO_Flags = 0 then								//#SR002 CPUName <> Undefined then		//#SR000
		
			//*** System get Serialnumber ***************************************
			if OS_CILGET( "ISYSSERNUM", #pISysSernum ) = SYS_ERR_NONE then
			
				p_PLCInfo := ISYSSERNUM_SERNUMGETPLCINFO();
							
				if p_PLCInfo <> NIL then
					String0.WriteDataOff(udLen:=_StrLen(#p_PLCInfo^.szSerialNumber[0]), udOff:=0, pData:=#p_PLCInfo^.szSerialNumber[0]);
          
          //PH001: also get the application name
          AppliName.WriteDataOff(udLen:=_StrLen(#p_PLCInfo^.szApplication[0]), udOff:=0, pData:=#p_PLCInfo^.szApplication[0]);

          pFunction := _FindFctName("LDR_GetPrjInfo");
          if ( pFunction <> NIL ) then
            pFunction $ LDR_GetPrjInfo((#HiRev)$^BYTE, (#LoRev)$^BYTE, #pPrjName);
          
            ProjectRevision := (HiRev SHL 8) OR LoRev;
          else
            ProjectRevision := INVALID;
          end_if;
				end_if;
			
      
			//#SR003 start
			else
				SerNum$UDINT := INVALID;
			//#SR003 end
        
        //PH001
        ApplicationName := INVALID;
			end_if;

			//look if we need a task
			if ( us_NoTask = 0 ) then		//#SR003
				ud_Timestamp := ops.tAbsolute - 1secs;
				CyWork(0);
				To_TaskObjectControl.AddCyclicObject(	  pObj		:= this
														, udMode	:= 2 // TASK_TIMED
														, udTime	:= 100ms
														, udPhase	:= 0
														);
			end_if;							//#SR003
		end_if;
	end_if;

END_FUNCTION //VIRTUAL GLOBAL PLC_Info::Init


FUNCTION VIRTUAL GLOBAL PLC_Info::CyWork
	VAR_INPUT
		InEAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state 	: UDINT;
	END_VAR
  VAR
  	XilinxRegs        : SINT;       // 8 bit signed int
    retval : DINT;
  END_VAR


  case WhoAmI of
  
    ARM_IMX6_CPU:
    
      if ops.tAbsolute - ud_Timestamp >= 250ms then
        ud_Timestamp := ops.tAbsolute;

        BatteryOk := pT_XREGS^.Batt_funct$funct_XREGS_BattGood();
        Supply24VOk := pT_XREGS^.Power_funct$funct_XREGS_PowerGood();
        
        //Get CPU Temperature        
        if pLSLSysInfo then
          //due to compatibility reasons we use the value 55 here instead of LSL_SYSINFO_ID_TEMPSENS_CPU0 from the headerfile lsl_st_sysinfo, e.g. someone uses an older lasal version
          retval := OS_SYSINFO_GET_PROP(pLSLSysInfo, 55$LSL_SYSINFO_ID, #CPUTemperature, sizeof(CPUTemperature));
          
          //use 0 instead of LSL_SYSINFO_ERR_NONE due to compatibility reasons
          if retval = 0 then
            //Convert to °C
            CPUTemperature := CPUTemperature / 1000;
          else
            CPUTemperature := INVALID$DINT;
          end_if;
        
        end_if;
      end_if;
      
    C_IPC_CPU:
      //Update CIPC
      if ops.tAbsolute - ud_Timestamp >= 250ms then
        ud_Timestamp := ops.tAbsolute;
        
        if b_StateRegsOk then
          XilinxRegs := (p_XilinxRegs+2)^$SINT;
          XilinxRegs := XilinxRegs XOR 2#110;

          if XilinxRegs AND 2#00000001 then
            BatteryOk := 1;
          else
            BatteryOk := 0;
          end_if;
          
          if XilinxRegs AND 2#00000010 then
            Supply24VOk := 1;
          else
            Supply24VOk := 0;
          end_if;
          
          if XilinxRegs AND 2#00000100 then
            TemperatureOk := 1;
          else
            TemperatureOk := 0;
          end_if;
        end_if;

        //UpdateFanTemp
        if b_TempOk then
          CPUTemperature := (p_XilinxRegs+1)^$SINT;
        end_if;

        //UpdateFan
        if b_CheckFanOk then
          if p_XilinxRegs^$SINT | (p_PWMRegs+4)^$SINT < 16#C then
            FanOk := 1;
          else
            FanOk := 0;
          end_if;
        end_if;
      end_if;



    CCL911_CPU:
      //Update CCL911 standard
      if ops.tAbsolute - ud_Timestamp >= 250ms  then
        ud_Timestamp := ops.tAbsolute;

        XilinxRegs := (p_XilinxRegs+1)^$SINT;

        if XilinxRegs AND 2#00000001 then
          Supply24VOk := 1;
        else
          Supply24VOk := 0;
        end_if;

        if XilinxRegs AND 2#00000010 then
          BatteryOk := 1;
        else
          BatteryOk := 0;
        end_if;
      end_if;


    Teachbox_CPU:
      //Neureder Teachbox     //#SR002 cmp.d		CPUName,CCL911Neureder
      if ops.tAbsolute - ud_Timestamp >= 250ms then
        ud_Timestamp := ops.tAbsolute;
      
        XilinxRegs := p_XilinxRegs^$SINT;
        
        if XilinxRegs AND 2#00000001 then
          BatteryOk := 1;
        else
          BatteryOk := 0;
        end_if;

        if XilinxRegs AND 2#00001000 then
          Supply24VOk := 1;
        else
          Supply24VOk := 0;
        end_if;
      end_if;


    ETV_CPU,
    ETVEDGE_CPU,
    CCP511_CPU:
      //ETV Terminals
      if ops.tAbsolute - ud_Timestamp >= 250ms then
        ud_Timestamp := ops.tAbsolute;
      
        if p_XilinxRegs <> NIL then
          XilinxRegs := p_XilinxRegs^$SINT;
        
          if XilinxRegs AND 2#00000001 then
            BatteryOk := 1;
          else
            BatteryOk := 0;
          end_if;

          if XilinxRegs AND 2#00001000 then
            Supply24VOk := 1;
          else
            Supply24VOk := 0;
          end_if;
        end_if;

        //Look4Temp
        if p_Period <> NIL then
          CPUTemperature := p_Period^ * ui_TempMult / ui_TempDivisor - ui_TempOffset;
        else
          //Look4Temp2
          if p_Fan <> NIL then
            CPUTemperature := p_Fan^.Temperature - 273;   //convert kelvin to celcius
            
            // check both fan bits
            if p_Fan^.StatusRegister.Fan1OK & p_Fan^.StatusRegister.Fan2OK then
              FanOk := 1;
            else
              FanOk := 0;
            end_if;

            if p_Fan^.StatusRegister.TempLimitOK then
              TemperatureOk := 1;
            else
              TemperatureOk := 0;
            end_if;
          else
            //Look4Temp3
            if p_SdiasPc <> NIL then
              CPUTemperature := p_SdiasPc^.CpuTemp;
            end_if;
          end_if;
        end_if;
      end_if;

  end_case;
  
  state := READY;

END_FUNCTION //VIRTUAL GLOBAL PLC_Info::CyWork








