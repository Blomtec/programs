//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define FileTransfer_MEM_MARK  7

#define FileTransfer_MAX_STRING_LEN      250
#define FileTransfer_MAX_FOLDER_ENTRIES  200

#define FileTransfer_GetFile              0
#define FileTransfer_GetFile_RSP          1
#define FileTransfer_GetFile_RSP_Start    2
#define FileTransfer_GetFile_RSP_Part     3
#define FileTransfer_GetFile_RSP_End      4

#define FileTransfer_GetFolderContent             10
#define FileTransfer_GetFolderContent_RSP         11

#define FileTransfer_Error                        100

#define FileTransfer_MAX_TCP_PACKAGE_LENGTH  100000 // ca 100kB

#define FileTransfer_ReceiveTimeout 10 SEC
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "FileTransferHandle"
	Revision           = "1.2"
	GUID               = "{689E6615-18F2-485D-9397-B8FF5E1CAC4A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(630,300)">
	<Channels>
		<Server Name="sCallbackError" GUID="{02F532A7-5C5F-4FC3-B44A-4F1157D09FBC}" Visualized="false" Initialize="true" DefValue="-1" WriteProtected="false" Retentive="false"/>
		<Server Name="sCallbackOK" GUID="{ADF2164A-F6F7-4B1A-AD82-F55FAF336F91}" Visualized="false" Initialize="true" DefValue="-1" WriteProtected="false" Retentive="false"/>
		<Server Name="sErrorNr" GUID="{64904849-2503-4B68-A161-2F56323FF84B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="sState" GUID="{26C444E5-3E02-4224-A9D1-C20CDCE48148}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="sSubState" GUID="{C0C895C0-50D1-436B-B9B3-13AE6A9F8CF6}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="cFileSys" Required="false" Internal="false"/>
		<Client Name="cGrafix" Required="false" Internal="false"/>
		<Client Name="cSigCLib" Required="false" Internal="false"/>
		<Client Name="cToCom" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="hötant"/>
		<Dokumentation Revision="1.2" Date="2016-05-02" Author="GreJoh" Company="Sigmatek" Description="Added Timeout errors, and fixed some errors."/>
		<Dokumentation Revision="1.1" Date="2015-10-21" Author="hötant" Company="Sigmatek" Description="added error handling and some improvements"/>
		<Dokumentation Revision="1.0" Date="2015-10-15" Author="hötant" Company="Sigmatek" Description="creation of class"/>
	</RevDoku>
</Class>
*)
FileTransferHandle : CLASS
	TYPE
	  _FT_Attrib :  //! <Type Public="true" Name="_FT_Attrib"/>
	  (
	    FT_File,
	    FT_Folder
	  )$UDINT;
	  _FT_String : ARRAY [0..FileTransfer_MAX_STRING_LEN-1] OF CHAR;  //! <Type Public="true" Name="_FT_String"/>
#pragma pack(push, 1)
	  _FT_FolderContentEntrie : STRUCT  //! <Type Public="true" Name="_FT_FolderContentEntrie"/>
	    Attrib : _FT_Attrib;
	    ContentString : _FT_String;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _FT_FolderContent : STRUCT  //! <Type Public="true" Name="_FT_FolderContent"/>
	    Nr : UDINT;
	    Entrie : ARRAY [0..FileTransfer_MAX_FOLDER_ENTRIES-1] OF _FT_FolderContentEntrie;
	  END_STRUCT;
#pragma pack(pop)
	  _FT_State :  //! <Type Public="true" Name="_FT_State"/>
	  (
	    FT_NoAction,
	    FT_Error,
	    FT_WaitForResponseGetFile,
	    FT_ReciveFile,
	    FT_SaveRecivedFile,
	    FT_OperationReady,
	    FT_SendRequestedFile,
	    FT_WaitForResponseGetFolderContent,
	    FT_ReciveFolderContent,
	    FT_SendRequestedFolderContent,
	    FT_FolderContextReady,
	    FT_WorkOnRequestedFolder
	  )$UDINT;
	  _FT_SubState :  //! <Type Public="true" Name="_FT_SubState"/>
	  (
	    FT_SUB_NoAction,
	    FT_SUB_CreateDir,
	    FT_SUB_WaitCreateDir,
	    FT_SUB_CreateFile,
	    FT_SUB_WaitCreateFile,
	    FT_SUB_WriteFile,
	    FT_SUB_WaitWriteFile,
	    FT_SUB_WaitCloseFile,
	    FT_SUB_FreeMemory,
	    FT_SUB_FindFirst,
	    FT_SUB_CloseFindFirst,
	    FT_SUB_WaitFindClose,
	    FT_SUB_OpenFile,
	    FT_SUB_WaitOpenFile,
	    FT_SUB_GetFileLength,
	    FT_SUB_WaitGetFileLength,
	    FT_SUB_AllocMemory,
	    FT_SUB_ReadFile,
	    FT_SUB_WaitReadFile,
	    FT_SUB_StartSendingFile,
	    FT_SUB_WaitResponseSendedFile,
	    FT_SUB_WaitResponseFileSize,
	    FT_SUB_SendingFilePart,
	    FT_SUB_WaitResponseFilePart,
	    FT_SUB_GetFolderContent,
	    FT_SUB_SendFolderContent,
	    FT_SUB_SendRequestFolderContent,
	    FT_SUB_WaitFolderContent,
	    FT_SUB_WaitResponseSendedFolderContent,
	    FT_SUB_CheckForFileOrFolder,
	    FT_SUB_WaitCreateDirFolder,
	    FT_SUB_GetFile,
	    FT_SUB_WaitGetFile,
	    FT_SUB_OperationReady,
	    FT_SUB_FindFirstFolder,
	    FT_SUB_Error_CreateDir,
	    FT_SUB_Error_CreateFile,
	    FT_SUB_Error_WriteFile,
	    FT_SUB_Error_CloseFile,
	    FT_SUB_Error_FindFile,
	    FT_SUB_Error_FileOpen,
	    FT_SUB_Error_FileLength,
	    FT_SUB_Error_AllocMemory,
	    FT_SUB_Error_ReadFile,
	    FT_SUB_ErrorJobID,
	    FT_SUB_ErrorCallback,
	    FT_SUB_Error_GettingFile,
	    FT_SUB_Error_OtherProcessRunning,
	    FT_SUB_Error_GetFolderContent,
	    FT_SUB_Error_GetFileFromContent,
	    FT_SUB_Error_GetFolder_EmptyFolder,
	    FT_SUB_Error_GetFolder_ToMuchEntries
	  )$UDINT;
	END_TYPE
  //Servers:
	sState 	: SvrChCmd__FT_State_PTofCls_FileTransferHandle;
	sSubState 	: SvrCh__FT_SubState_PTofCls_FileTransferHandle;
	sErrorNr 	: SvrCh_DINT;
	sCallbackOK 	: SvrCh_DINT;
	sCallbackError 	: SvrCh_DINT;
  //Clients:
	cToCom 	: CltChCmd_Comm_SendData;
	cSigCLib 	: CltChCmd_SigCLib;
	cFileSys 	: CltChCmd__FileSys;
	cGrafix 	: CltChCmd__Grafix;
  //Variables:
		SourceDPNE 	: _FT_String;
		SSW_Send_File 	: _FT_SubState;
		SSW_Send_FolderContent 	: _FT_SubState;
		SSW_Save_Recived 	: _FT_SubState;
		FindHandle 	: DINT;
		CloseHandle 	: DINT;
		OpenHandle 	: DINT;
		FileHandle 	: DINT;
		LengthHandle 	: DINT;
		FileLength 	: DINT;
		pFileDataSend 	: ^DINT;
		ReadHandle 	: DINT;
		WriteHandle 	: DINT;
		ReadLength 	: DINT;
		WriteLength 	: DINT;
		DestFileName 	: _FT_String;
		DestFileLength 	: UDINT;
		CreateDirHandle 	: DINT;
		DestDrivePath 	: _FT_String;
		pStartPointer 	: ^DINT;
		DataSended 	: DINT;
		pWritePointer 	: ^DINT;
		tmpName : ARRAY [0..FileTransfer_MAX_STRING_LEN-1] OF CHAR;

		JobID 	: DINT;
		pFileDataRecive 	: ^DINT;
		SourceDPContent 	: _FT_String;
		FolderContent 	: _FT_FolderContent;
		CreateDirPath 	: _FT_String;
		udTimeMarkTimeout 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetFile
		VAR_INPUT
			pSourceDP 	: ^CHAR;
			pSourceNE 	: ^CHAR;
			pDestinationDP 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment=" 1..Job wurde gestartet&#13;&#10; 0..Job wurde abgelehnt , es läuft bereits ein Job&#13;&#10;-1..Pointer sind ungültig.&#13;&#10;-2..Job wurde von der Kommunikation abgelehnt." Name="GetFile.retcode"/>
		END_VAR;
	
	FUNCTION GLOBAL CallBackReciverCMD
		VAR_INPUT
			DestinationID 	: DINT;
			SourceID 	: DINT;
			size 	: UDINT;
			pdata 	: ^USINT;
			OptCMD 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION Send_Requested_File;
	
	FUNCTION Save_Recived_File;
	
	FUNCTION CheckStartOperation
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetContentList
		VAR_INPUT
			pSourceDP 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION Send_Requested_FolderContent;
	
	FUNCTION AddContent
		VAR_INPUT
			pContentString 	: ^CHAR;
			Attrib 	: _FT_Attrib;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetRecivedContentList
		VAR_INPUT
			pFolderContent 	: ^_FT_FolderContent;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GetFileContentRecursive
		VAR_INPUT
			pSearchPath 	: ^CHAR;
			pNextPath 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment=" 1..OK es wurden Einträge gefunden.&#13;&#10; 0..Keine Einträge vorhanden oder Ordner existiert nicht.&#13;&#10;-1..Maximale Anzahl der Einträge wurde überschritten.&#13;&#10;" Name="GetFileContentRecursive.retcode"/>
		END_VAR;
	
	FUNCTION GLOBAL PrepairPathDelBS
		VAR_INPUT
			pPath 	: ^CHAR;
		END_VAR;
	
	FUNCTION SendError
		VAR_INPUT
			Status 	: _FT_SubState;
		END_VAR;
	
	FUNCTION GLOBAL PrepairPathAddBS
		VAR_INPUT
			pPath 	: ^CHAR;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _Grafix
#pragma usingLtd Comm_SendData
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB FileTransferHandle::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_FILETRANSFERHANDLE
1$UINT, 2$UINT, (SIZEOF(::FileTransferHandle))$UINT, 
5$UINT, 4$UINT, 0$UINT, 
TO_UDINT(496318626), "FileTransferHandle", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::FileTransferHandle.sState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2839362732), "sState", 
(::FileTransferHandle.sSubState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3622246169), "sSubState", 
(::FileTransferHandle.sErrorNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3976045603), "sErrorNr", 
(::FileTransferHandle.sCallbackOK.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2409950527), "sCallbackOK", 
(::FileTransferHandle.sCallbackError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(268437528), "sCallbackError", 
//Clients:
(::FileTransferHandle.cToCom.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1002087807), "cToCom", TO_UDINT(2033074076), "Comm_SendData", 0$UINT, 5$UINT, 
(::FileTransferHandle.cSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1539399991), "cSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 14$UINT, 
(::FileTransferHandle.cFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(194275965), "cFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
(::FileTransferHandle.cGrafix.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2880828741), "cGrafix", TO_UDINT(197854207), "_Grafix", 1$UINT, 2$UINT, 
END_FUNCTION


#define USER_CNT_FileTransferHandle 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_FileTransferHandle] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION FileTransferHandle::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_FileTransferHandle, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	sState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF sState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sCallbackOK.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sCallbackOK.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sCallbackError.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sCallbackError.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION GLOBAL FileTransferHandle::GetFile
	VAR_INPUT
		pSourceDP 	: ^CHAR;
		pSourceNE 	: ^CHAR;
		pDestinationDP 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpDPNE : Array [0..(FILETRANSFER_MAX_STRING_LEN-1)] of char;
  END_VAR

  // Rückgagewert auf Error setzen
  retcode := 0; 
  // Prüfen ob bereits eine andere Operation läuft.
  if CheckStartOperation() = TRUE then
    // Rückgabewert -> Fehler Pointer;
    retcode := -1;
    // auf gültige Pointer prüfen
    if (pSourceDP <> NIL) & (pSourceNE <> NIL) & (pDestinationDP <> NIL) then
      // Filenamen und Pfade speicher , erstellen.
      cSigCLib.StrCpy(dst0:=#tmpDPNE[0], src0:=pSourceDP);
      PrepairPathAddBS(pPath:=#tmpDPNE[0]);
      cSigCLib.StrCat(ps1:=#tmpDPNE[0], ps2:=pSourceNE);
      cSigCLib.StrCpy(dst0:=#DestFileName[0], src0:=pSourceNE);
      cSigCLib.StrCpy(dst0:=#DestDrivePath[0], src0:=pDestinationDP);
      PrepairPathAddBS(pPath:=#DestDrivePath[0]);
      // Rückgabewert -> Fehler Daten Senden;
      retcode := -2;
      // Commando an die Gegenstelle schicken. ( File holen )
      if cToCom.SendData(pData:=#tmpDPNE[0], length:= cSigCLib.StrLen(str:=#tmpDPNE[0])+1 , timeout:=0, OptCMD:=FileTransfer_GetFile) >=0 then
        
        udTimeMarkTimeout := ops.tAbsolute;
        
        // Rückgabewert -> Commando gestartet;
        retcode := 1;
        // Im Background auf die Antwort warten.
        SSW_Save_Recived := FT_SUB_NoAction;
        sState := FT_WaitForResponseGetFile;
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL FileTransferHandle::CallBackReciverCMD
	VAR_INPUT
		DestinationID 	: DINT;
		SourceID 	: DINT;
		size 	: UDINT;
		pdata 	: ^USINT;
		OptCMD 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  // Rückgabewert -> Fehler  
  retcode := FALSE;
  
//******************************************************************************************************
//*******************  Seperieren der einzelnen Commandos     ******************************************
//******************************************************************************************************
  
  
  case OptCMD of

//******************************************************************************************************    
    // Es wurde ein File angefordert zum schicken.
    FileTransfer_GetFile :
      // Prüfen ob Start möglich
      if CheckStartOperation() = TRUE then
        // prüfen der Stringlänge
        if size < FileTransfer_MAX_STRING_LEN then
          // String umkopieren für später
          cSigCLib.StrCpy(dst0:=#SourceDPNE[0], src0:=pdata);
          // Rückgabe -> OK Commando angenommen
          retcode := TRUE;
          // Abarbeitung starten im Background
          sState := FT_SendRequestedFile;
          SSW_Send_File := FT_SUB_FindFirst;
        else
          sState := FT_Error;
          sErrorNr := -11;
          SendError(Status:=sSubState);
        end_if;
      else
        sState := FT_Error;
        sErrorNr := -10;
        SendError(Status:=sSubState);
      end_if;
    
//******************************************************************************************************
    // Anwort wenn die Filegröße FileTransfer_MAX_TCP_PACKAGE_LENGTH nicht übersteigt.
    FileTransfer_GetFile_RSP :
      if size > 0 then
        // Status richtigstellen.
        sState := FT_ReciveFile;
        // Speicher für File reservieren
        if cGrafix.MemoryV1(MemPtr0:=#pFileDataRecive, size0:=size, mark0:=FILETRANSFER_MEM_MARK ) <> 0 then
          // Daten auf neuen Speicher umkopieren
          cSigCLib.MemCpy(dst0:=pFileDataRecive, src0:=pdata, len0:=size);
          // Filegröße zwischenspeichern für nächsten schritt.
          DestFileLength := size;
          // Background abarbeitung weiterschalten.
          sState := FT_SaveRecivedFile;
          SSW_Save_Recived :=FT_SUB_CreateDir;
          // Rückgabe -> OK Commando angenommen
          retcode := TRUE;
        else
          sState := FT_Error;
          sErrorNr := -2;
          SendError(Status:=sSubState);
        end_if;
      else
        sState := FT_Error;
        sErrorNr := -1;
        SendError(Status:=sSubState);
      end_if;
      
//******************************************************************************************************
    // Anwort wenn die Filegröße FileTransfer_MAX_TCP_PACKAGE_LENGTH übersteigt. ( Startsignal )  
    FILETRANSFER_GETFILE_RSP_START : 
      if size = sizeof(FileLength) then
        // prüfen ob die Filelänge größer als 0 ist.
        if (pdata$^udint)^ > 0 then
          // Speicher für das gesamte File reservieren.
          if cGrafix.MemoryV1(MemPtr0:=#pFileDataRecive, size0:=(pdata$^udint)^, mark0:=FILETRANSFER_MEM_MARK ) <> 0 then
            // Filegröße zwischenspeichern für nächsten schritt.
            DestFileLength := (pdata$^udint)^;
            // Rückgabe -> OK Commando angenommen
            retcode := TRUE;
            // Schreibzeiger auf den Anfang des Speicherblocks
            pWritePointer := pFileDataRecive;
            // Status aktualisieren.
            sState := FT_ReciveFile;
          else
            sState := FT_Error;
            sErrorNr := -5;
            SendError(Status:=sSubState);
          end_if;
        else
          sState := FT_Error;
          sErrorNr := -4;
          SendError(Status:=sSubState);
        end_if;
      else
        sState := FT_Error;
        sErrorNr := -3;
        SendError(Status:=sSubState);
      end_if;
    
//******************************************************************************************************
    // Anwort wenn die Filegröße FileTransfer_MAX_TCP_PACKAGE_LENGTH übersteigt. ( Teil des Files )  
    FILETRANSFER_GETFILE_RSP_Part :
      if size = FileTransfer_MAX_TCP_PACKAGE_LENGTH then
        // Empfangenen Teil des Files umkopieren
        cSigCLib.MemCpy(dst0:=pWritePointer, src0:=pdata, len0:=size);
        // Schreibzeiger weiterschalten.
        pWritePointer += FileTransfer_MAX_TCP_PACKAGE_LENGTH;
        // Rückgabe -> OK Commando angenommen
        retcode := TRUE;
      else
        sState := FT_Error;
        cGrafix.MemoryV1(MemPtr0:=#pFileDataRecive, size0:=(pdata$^udint)^, mark0:=FILETRANSFER_MEM_MARK );
        pFileDataRecive := NIL;
        sErrorNr := -6;
        SendError(Status:=sSubState);
      end_if;
 
 //******************************************************************************************************
    // Anwort wenn die Filegröße FileTransfer_MAX_TCP_PACKAGE_LENGTH übersteigt. ( letzte Teil des Files )  
    FILETRANSFER_GETFILE_RSP_END :
      if size > 0 then
        // letzten Fileblock speichern
        cSigCLib.MemCpy(dst0:=pWritePointer, src0:=pdata, len0:=size);
        // Schreibzeiger setzten
        pWritePointer += size;
        // Rückgabe -> OK Commando angenommen
        retcode := TRUE;
        // Weiter mit dem nächsten Schritt im Background.
        sState := FT_SaveRecivedFile;
        SSW_Save_Recived := FT_SUB_CreateDir;
      else
        sState := FT_Error;
        cGrafix.MemoryV1(MemPtr0:=#pFileDataRecive, size0:=(pdata$^udint)^, mark0:=FILETRANSFER_MEM_MARK );
        pFileDataRecive := NIL;
        sErrorNr := -7;
        SendError(Status:=sSubState);
      end_if;

//******************************************************************************************************
    // Es wurde ein Folder angefordert zum schicken.
    FileTransfer_GetFolderContent :
      // prüfen ob eine andere Operation bereits läuft.
      if CheckStartOperation() = TRUE then
        // länge des Strings prüfen.
        if size < FileTransfer_MAX_STRING_LEN then
          // String umkopieren für Background
          cSigCLib.StrCpy(dst0:=#SourceDPContent[0], src0:=pdata);
          // Rückgabe -> OK Commando angenommen
          retcode := TRUE;
          // Aktion im Background Starten.
          sState := FT_SendRequestedFolderContent;
          SSW_Send_FolderContent := FT_SUB_GetFolderContent;
        else
          sState := FT_Error;
          sErrorNr := -12;
          SendError(Status:=sSubState);
        end_if;
      else
        sState := FT_Error;
        sErrorNr := -13;
        SendError(Status:=sSubState);
      end_if;

//******************************************************************************************************
    // Anwort ( Inhaltsverzeichniss )
    FileTransfer_GetFolderContent_RSP :
      // Empfangenen Inhalt prüfen
      if (size > 0) & (size <= sizeof(_FT_FolderContent)) then
        // Status aktualisieren
        sState := FT_ReciveFolderContent;
        // alte Daten löschen
        _memset(dest:=#FolderContent, usByte:=0, cntr:=sizeof(_FT_FolderContent));
        // Daten für Background umkopieren.
        cSigCLib.MemCpy(dst0:=#FolderContent , src0:=pdata, len0:=size);
        // Status aktualisieren
        sState := FT_FolderContextReady;
        // Rückgabe -> OK Commando angenommen
        retcode := TRUE;
      else
        sState := FT_Error;
        sErrorNr := -1;
        SendError(Status:=sSubState);
      end_if;

//******************************************************************************************************
    // Errormeldung von der Gegenstelle
    FileTransfer_Error:
      // Empfangenen Inhalt prüfen
      if (size = sizeof(_FT_SubState)) & (pdata <> NIL ) then
        // Status aktualisieren
        sState := FT_Error;
        // Sub Status aktualisieren
        sSubState := (pdata$^_FT_SubState)^;
        // Rückgabe -> OK Commando angenommen
        retcode := TRUE;
      end_if;
       
  end_case;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL FileTransferHandle::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
//*********************************************************************************************************  
//************************  Abarbeitung der Commandos    **************************************************
//*********************************************************************************************************
  case sState of

//*********************************************************************************************************  
    // Ready for new Command
  	FT_NoAction:
      sSubState := FT_SUB_NoAction ;
      
//*********************************************************************************************************
    // Error -> sErrorNr
  	FT_Error:

//*********************************************************************************************************    
    // Auftrag wurde gesendet , warte auf Antwort.
  	FT_WaitForResponseGetFile:

      if ops.tAbsolute - udTimeMarkTimeout >= FileTransfer_ReceiveTimeout then
        SendError(Status:=sSubState);
        sState := FT_Error;
      end_if;


//*********************************************************************************************************    
    // Empfange File Daten
    FT_ReciveFile:

//*********************************************************************************************************    
    // File wurde Empfangen , Save 
  	FT_SaveRecivedFile:
      Save_Recived_File();
      sSubState := SSW_Save_Recived;
      
//*********************************************************************************************************    
    // File auslesen und schicken.
    FT_SendRequestedFile :
      Send_Requested_File();
      sSubState := SSW_Send_File ;

//*********************************************************************************************************
    // Operation erfolgreich durchgeführt.
  	FT_OperationReady:
    
//*********************************************************************************************************
    // Auftrag wurde gesendet , warte auf Antwort.
  	FT_WaitForResponseGetFolderContent:

      if ops.tAbsolute - udTimeMarkTimeout >= FileTransfer_ReceiveTimeout then
        SendError(Status:=sSubState);
        sState := FT_Error;
      end_if;


//*********************************************************************************************************
    // Empfange FolderContent Daten
    FT_ReciveFolderContent:

//*********************************************************************************************************    
    // Folder auslesen und Inhalt schicken.
    FT_SendRequestedFolderContent :
      Send_Requested_FolderContent();
      sSubState := SSW_Send_FolderContent ;
  
  end_case;

	state := READY;

END_FUNCTION


FUNCTION FileTransferHandle::Send_Requested_File
VAR
	FunktErg : dint;
  locDDE_INFO : _DDE_INFO;
  tmpName : array [0..FileTransfer_MAX_STRING_LEN] of char;
END_VAR

//*********************************************************************************************************
//**********************Angefordertes File schicken    ****************************************************
//*********************************************************************************************************
  case SSW_Send_File of

//*********************************************************************************************************  
    FT_SUB_NoAction :
    
//*********************************************************************************************************    
    FT_SUB_FindFirst:  
        // Prüfen ob File vorhanden starten                             
        FindHandle :=  cFileSys.FindFirstEx_A(Async:=0, 
                                              namepattern:=#SourceDPNE[0], 
                                              attr:=0,
                                              attrmask:=0, 
                                              fileinfo:=#locDDE_INFO, 
                                              filename:=#tmpName[0], 
                                              maxlength:=FileTransfer_MAX_STRING_LEN);
        
        if FindHandle >= 0 then
          SSW_Send_File := FT_SUB_CloseFindFirst;
        else
          // File not Found
          SSW_Send_File := FT_SUB_Error_FindFile;
          sState := FT_Error;
          // Error zur Gegenstelle übertragen
          SendError(Status:=FT_SUB_Error_FindFile);          
        end_if;
        
        
//*********************************************************************************************************    
    FT_SUB_CloseFindFirst: 
        // Prüfen ob File vorhanden ,Warten bis abgeschlossen
        CloseHandle := cFileSys.FindClose_A(Async:=1, handle:=FindHandle);
        SSW_Send_File := FT_SUB_WaitFindClose;
        
//*********************************************************************************************************    
    FT_SUB_WaitFindClose:
        // Warten bis das schließen abgeschlossen ist.
        if cFileSys.GetAsyncState(ID:=CloseHandle$udint, Erg:=#FunktErg) = 0 then
          SSW_Send_File :=FT_SUB_OpenFile;
        end_if;
        
//*********************************************************************************************************        
    FT_SUB_OpenFile: 
        // File zum auslesen öffnen , Start
        OpenHandle := cFileSys.FileOpen_A(Async:=1, filename:=#SourceDPNE[0], attributes:=ATT_OPEN_SHARED (*ATTR_READ_ONLY*));
        SSW_Send_File :=FT_SUB_WaitOpenFile;
        
//*********************************************************************************************************    
    FT_SUB_WaitOpenFile: 
        // Warten bis aktion abgeschlossen ist.
        if cFileSys.GetAsyncState(ID:=OpenHandle$udint, Erg:=#FileHandle) = 0 then
          // Ergebiss der Aktion überprüfen
          if FileHandle >= 0 then
            // Erfolgreich geöffnet.
            SSW_Send_File := FT_SUB_GetFileLength;  
          else
            // konnte nicht geöffnet werden.
            SSW_Send_File := FT_SUB_Error_FileOpen;
            sState := FT_Error;
            // Error zur Gegenstelle übertragen
            SendError(Status:=FT_SUB_Error_FileOpen);
          end_if;
        end_if;
        
//*********************************************************************************************************   
    FT_SUB_GetFileLength: 
        // länge des Files ermitteln , start
        LengthHandle := cFileSys.FileLength_A(Async:=1, handle:=FileHandle);
        SSW_Send_File := FT_SUB_WaitGetFileLength;

//*********************************************************************************************************        
    FT_SUB_WaitGetFileLength: 
        // Warten bis aktion abgeschlossen ist.
        if cFileSys.GetAsyncState(ID:=LengthHandle$udint, Erg:=#FileLength) = 0 then
          // Ergebiss der Aktion überprüfen
          if FileLength > 0 then
             // OK
             SSW_Send_File := FT_SUB_AllocMemory;  
          else
            // Length Error.
            cFileSys.FileClose_A(Async:=1, handle:=FileHandle);
            SSW_Send_File := FT_SUB_Error_FileLength;
            sState := FT_Error;
            // Error zur Gegenstelle übertragen
            SendError(Status:=FT_SUB_Error_FileLength);
          end_if;
        end_if;

//*********************************************************************************************************        
    FT_SUB_AllocMemory: 
        // Speicher für Ihnalt des Files reservieren.
        if cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=FileLength$udint, mark0:=FileTransfer_MEM_MARK) <> 0 then
          // Speicher bekommen
          SSW_Send_File := FT_SUB_ReadFile;
        else
          // kein Speicher Frei.
          SSW_Send_File := FT_SUB_Error_AllocMemory;
          sState := FT_Error;
          // File wieder schließen
          cFileSys.FileClose_A(Async:=1, handle:=FileHandle);
          // Error zur Gegenstelle übertragen
          SendError(Status:=FT_SUB_Error_AllocMemory);
        end_if;

//*********************************************************************************************************        
    FT_SUB_ReadFile: 
        // Inhalt des Files in den Speicher lesen. start
        ReadHandle :=  cFileSys.FileRead_AV1(Async:=1, handle:=FileHandle, buffer:=pFileDataSend, length:=FileLength$udint);
        SSW_Send_File := FT_SUB_WaitReadFile;
        
//*********************************************************************************************************        
    FT_SUB_WaitReadFile: 
        // Warten bis aktion abgeschlossen ist.
        if cFileSys.GetAsyncState(ID:=readHandle$udint, Erg:=#ReadLength) = 0 then
          // Ergebiss der Aktion überprüfen
          if ReadLength = FileLength then
            // File wurde komplett ausgelesen.
            SSW_Send_File := FT_SUB_StartSendingFile;  
          else
            // Length Error.
            SSW_Send_File := FT_SUB_Error_ReadFile;
            sState := FT_Error;
            // Speicher freigeben.
            cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
            pFileDataSend := NIL;
            // Error zur Gegenstelle übertragen
            SendError(Status:=FT_SUB_Error_ReadFile);
          end_if;
          // File schließen
          cFileSys.FileClose_A(Async:=1, handle:=FileHandle);
        end_if;    
        
//*********************************************************************************************************    
   FT_SUB_StartSendingFile :
        // Länge des Files überprüfen
        if FileLength > FileTransfer_MAX_TCP_PACKAGE_LENGTH then  // File muß aufgeteilt werden.
          // Filelänge an Gegenstelle schicken.
          JobID := cToCom.SendData(pData:=#FileLength, length:=sizeof(FileLength), timeout:=0, OptCMD:=FILETRANSFER_GETFILE_RSP_Start);
          // Prüfen ob Job angenommen wurde.
          if JobID >= 0 then
             udTimeMarkTimeout := ops.tAbsolute;
             SSW_Send_File := FT_SUB_WaitResponseFileSize; 
             // Merker Anzahl gesendete datan zurücksetzen
             DataSended :=0;
             // Lesezeiger setzen
             pStartPointer := pFileDataSend;
          else
            // konnte nicht gesendet werden.
            SSW_Send_File := FT_SUB_ErrorJobID;
            /// speicher freigeben.
            cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
            pFileDataSend := NIL;
            sState := FT_Error;
            // Error zur Gegenstelle übertragen
            SendError(Status:=FT_SUB_ErrorJobID);
          end_if;
        else  // File kann als ganzes gesendet werden.
          // Inhalt des Files an Gegenstelle schicken.
          JobID := cToCom.SendData(pData:=pFileDataSend, length:=FileLength$udint, timeout:=0, OptCMD:=FILETRANSFER_GETFILE_RSP);
          // Prüfen ob Job angenommen wurde.
          if JobID >= 0 then
            udTimeMarkTimeout := ops.tAbsolute;
            SSW_Send_File := FT_SUB_WaitResponseSendedFile ; 
          else
            // konnte nicht gesendet werden.
            SSW_Send_File := FT_SUB_ErrorJobID;
            // Speicher freigeben
            cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
            pFileDataSend := NIL;
            sState := FT_Error;
            // Error zur Gegenstelle übertragen
            SendError(Status:=FT_SUB_ErrorJobID);
          end_if;
        end_if;

//*********************************************************************************************************        
   FT_SUB_WaitResponseSendedFile: 
        // Auf Antwort der Gegenstelle warten.
        
        if ops.tAbsolute - udTimeMarkTimeout >= FileTransfer_ReceiveTimeout then
           
           SSW_Send_File := FT_SUB_ErrorCallback;
           // Speicher freigeben.
           cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
           pFileDataSend := NIL;
           sState := FT_Error;
           // Error zur Gegenstelle übertragen
           SendError(Status:=FT_SUB_ErrorCallback);        
        
        else        
          // Daten wurden empfangen
          if JobID = sCallbackOK then 
            SSW_Send_File := FT_SUB_FreeMemory; 
          end_if;
          
          // Empfänger hatte ein Problem
          if JobID = sCallbackError then 
             SSW_Send_File := FT_SUB_ErrorCallback;
             // Speicher freigeben.
             cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
             pFileDataSend := NIL;
             sState := FT_Error;
             // Error zur Gegenstelle übertragen
             SendError(Status:=FT_SUB_ErrorCallback);
          end_if;
          
        end_if;  

//*********************************************************************************************************        
   FT_SUB_WaitResponseFileSize: 
        // Auf Antwort der Gegenstelle warten.
        
        if ops.tAbsolute - udTimeMarkTimeout >= FileTransfer_ReceiveTimeout then
          
          SSW_Send_File := FT_SUB_ErrorCallback;
          // Speicher freigeben.
          cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
          pFileDataSend := NIL;
          sState := FT_Error;
          // Error zur Gegenstelle übertragen
          SendError(Status:=FT_SUB_ErrorCallback);
          
        else
        
          // Daten wurden empfangen
          if JobID = sCallbackOK then
            SSW_Send_File := FT_SUB_SendingFilePart;
          end_if;
          
           // Empfänger hatte ein Problem
          if JobID = sCallbackError then
            SSW_Send_File := FT_SUB_ErrorCallback;
            // Speicher freigeben.
            cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
            pFileDataSend := NIL;
            sState := FT_Error;
            // Error zur Gegenstelle übertragen
            SendError(Status:=FT_SUB_ErrorCallback);
          end_if;
          
        end_if;
        

//*********************************************************************************************************   
   FT_SUB_SendingFilePart: 
        // solange schickenn , bis alle Daten geschickt wurden.
        if DataSended < FileLength then
          // größe der Restdaten prüfen.
          if ((FileLength - DataSended) > FileTransfer_MAX_TCP_PACKAGE_LENGTH ) then
            // Teil des Files an Gegenstelle schicken.
            JobID := cToCom.SendData(pData:=pStartPointer, length:=FileTransfer_MAX_TCP_PACKAGE_LENGTH, timeout:=0, OptCMD:=FILETRANSFER_GETFILE_RSP_Part);
            // Prüfen ob Job angenommen wurde.
            if JobID >= 0 then 
              udTimeMarkTimeout := ops.tAbsolute;
              SSW_Send_File := FT_SUB_WaitResponseFilePart;
              // Lesezeiger weiterschalten
              pStartPointer += FileTransfer_MAX_TCP_PACKAGE_LENGTH;
              // Anzahl gesendete Daten erhöhen
              DataSended += FileTransfer_MAX_TCP_PACKAGE_LENGTH;
            else // konnte nicht gesendet werden.
              SSW_Send_File := FT_SUB_ErrorJobID;
              // Speichern freigeben
              cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
              pFileDataSend := NIL;
              sState := FT_Error;
              // Error zur Gegenstelle übertragen
              SendError(Status:=FT_SUB_ErrorJobID);
            end_if;
          else // letzten Teil des Files schicken.
            // Teil des Files an Gegenstelle schicken.
            JobID := cToCom.SendData(pData:=pStartPointer, length:=to_udint((FileLength - DataSended)), timeout:=0, OptCMD:=FILETRANSFER_GETFILE_RSP_End);
            // Prüfen ob Job angenommen wurde.
            if JobID >= 0 then
              udTimeMarkTimeout := ops.tAbsolute;
              SSW_Send_File := FT_SUB_WaitResponseFilePart;
              // Lesezeiger weiterschalten
              pStartPointer += (FileLength - DataSended);
              // Anzahl gesendete Daten erhöhen
              DataSended += (FileLength - DataSended);
            else // konnte nicht gesendet werden.
              SSW_Send_File := FT_SUB_ErrorJobID;
              // Speichern freigeben
              cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
              pFileDataSend := NIL;
              sState := FT_Error;
              // Error zur Gegenstelle übertragen
              SendError(Status:=FT_SUB_ErrorJobID);
            end_if;
          end_if;
        else
          // alles gesendet. Fertig.
          SSW_Send_File := FT_SUB_FreeMemory; 
        end_if;
 
 //*********************************************************************************************************
   FT_SUB_WaitResponseFilePart:
        // Auf Antwort der Gegenstelle warten.

        if ops.tAbsolute - udTimeMarkTimeout >= FileTransfer_ReceiveTimeout then
          
          SSW_Send_File := FT_SUB_ErrorCallback;
          // Speicher freigeben.
          cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
          pFileDataSend := NIL;
          sState := FT_Error;
          // Error zur Gegenstelle übertragen
          SendError(Status:=FT_SUB_ErrorCallback);          
        
        else
        
          // Daten wurden empfangen
          if JobID = sCallbackOK then
            SSW_Send_File := FT_SUB_SendingFilePart;
          end_if;
          
           // Empfänger hatte ein Problem
          if JobID = sCallbackError then
            SSW_Send_File := FT_SUB_ErrorCallback;
            // Speicher freigeben.
            cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
            pFileDataSend := NIL;
            sState := FT_Error;
            // Error zur Gegenstelle übertragen
            SendError(Status:=FT_SUB_ErrorCallback);
          end_if; 
        
        end_if;

//*********************************************************************************************************   
   FT_SUB_FreeMemory: 
        // Speicher freigeben.
        cGrafix.MemoryV1(MemPtr0:=#pFileDataSend, size0:=0, mark0:=FILETRANSFER_MEM_MARK);
        // Aktion abgeschlossen.
        SSW_Send_File :=FT_SUB_OperationReady;
        pFileDataSend := NIL;
        sState :=FT_OperationReady;

//*********************************************************************************************************   
   FT_SUB_OperationReady:
   
  end_case;

END_FUNCTION

FUNCTION FileTransferHandle::Save_Recived_File
VAR
	FunktErg : dint;
END_VAR

//********************************************************************************************************
//********************   Empfangenes File abspeichern    *************************************************
//********************************************************************************************************
  case SSW_Save_Recived of

//********************************************************************************************************  
    FT_SUB_NoAction:

//********************************************************************************************************    
    FT_SUB_CreateDir: 
        // Start Create Directory
        cSigCLib.StrCpy(dst0:=#CreateDirPath[0], src0:=#DestDrivePath[0]);
        PrepairPathDelBS(pPath:=#CreateDirPath[0]);
        CreateDirHandle := cFileSys.CreateDirectory_A(Async:=1, dirname:=#CreateDirPath[0]);
        SSW_Save_Recived := FT_SUB_WaitCreateDir;

//********************************************************************************************************
    FT_SUB_WaitCreateDir:
        // Warten bis aktion abgeschlossen ist.
        if cFileSys.GetAsyncState(ID:=CreateDirHandle$udint, Erg:=#FunktErg) = 0 then
          // Ergebniss der Aktion überprüfen
          if FunktErg = 0 | FunktErg = -36 then  //-36 RTF_FILE_EXISTS
             SSW_Save_Recived := FT_SUB_CreateFile;  
          else
            // Fehler Create Directory
            SSW_Save_Recived := FT_SUB_Error_CreateDir;
            sState := FT_Error;
            // speicher Freigeben
            cGrafix.MemoryV1(MemPtr0:=#pFileDataRecive, size0:=0, mark0:=FILETRANSFER_MEM_MARK );
            pFileDataRecive := NIL;
          end_if;
        end_if;

//********************************************************************************************************    
   FT_SUB_CreateFile: 
        // File öffnen zum schreiben.  
        cSigCLib.StrCpy(dst0:=#tmpName[0], src0:=#DestDrivePath[0]);
        cSigCLib.StrCat(ps1:=#tmpName[0], ps2:=#DestFileName[0]);
        OpenHandle := cFileSys.FileOpen_A(Async:=1, filename:=#tmpName[0], attributes:=ATT_CREATE_ALWAYS );
        SSW_Save_Recived := FT_SUB_WaitCreateFile;

//********************************************************************************************************    
   FT_SUB_WaitCreateFile:
        // Warten bis aktion abgeschlossen ist.
        if cFileSys.GetAsyncState(ID:=OpenHandle$udint, Erg:=#FileHandle) = 0 then
          // Ergebniss der Aktion überprüfen
          if FileHandle >= 0 then
              SSW_Save_Recived := FT_SUB_WriteFile;  
          else
            // File connte nicht angelegt werden.
            SSW_Save_Recived := FT_SUB_Error_CreateFile;
            sState := FT_Error;
            // Speicher freigeben.
            cGrafix.MemoryV1(MemPtr0:=#pFileDataRecive, size0:=0, mark0:=FILETRANSFER_MEM_MARK );
            pFileDataRecive := NIL;
          end_if;
        end_if;

//********************************************************************************************************    
    FT_SUB_WriteFile: 
        // Inhalt ins File schreiben.
        WriteHandle := cFileSys.FileWrite_AV1(Async:=1, handle:=FileHandle, buffer:=pFileDataRecive, length:=DestFileLength);
        SSW_Save_Recived := FT_SUB_WaitWriteFile;

//********************************************************************************************************          
    FT_SUB_WaitWriteFile: 
        // Warten bis aktion abgeschlossen ist.
        if cFileSys.GetAsyncState(ID:=WriteHandle$udint, Erg:=#WriteLength) = 0 then
          // Ergebniss der Aktion überprüfen
          if DestFileLength$dint = WriteLength then
             SSW_Save_Recived := FT_SUB_WaitCloseFile;  
          else
            // Fehler beim Schreiben.
            SSW_Save_Recived := FT_SUB_Error_WriteFile;
            sState := FT_Error;
            // Speicher freigeben.
            cGrafix.MemoryV1(MemPtr0:=#pFileDataRecive, size0:=0, mark0:=FILETRANSFER_MEM_MARK );
            pFileDataRecive := NIL;
          end_if;
          // File schließen.
          CloseHandle := cFileSys.FileClose_A(Async:=1, handle:=FileHandle);
        end_if;

//********************************************************************************************************        
    FT_SUB_WaitCloseFile: 
        // Warten bis aktion abgeschlossen ist.
        if cFileSys.GetAsyncState(ID:=CloseHandle$udint, Erg:=#FunktErg) = 0 then
          // Ergebniss der Aktion überprüfen
          if FunktErg = 0 then
             SSW_Save_Recived := FT_SUB_FreeMemory;  
          else
            // Fehler 
            SSW_Save_Recived := FT_SUB_Error_CloseFile;
            sState := FT_Error;
            // Speicher freigeben.
            cGrafix.MemoryV1(MemPtr0:=#pFileDataRecive, size0:=0, mark0:=FILETRANSFER_MEM_MARK );
            pFileDataRecive := NIL;
          end_if;
        end_if;

//********************************************************************************************************    
    FT_SUB_FreeMemory:
        // File wurde gespeichert. Speicher freigeben.
        cGrafix.MemoryV1(MemPtr0:=#pFileDataRecive, size0:=0, mark0:=FileTransfer_MEM_MARK);
        pFileDataRecive := NIL;
        SSW_Save_Recived := FT_SUB_OperationReady;
        sState :=FT_OperationReady ;

//********************************************************************************************************        
    FT_SUB_OperationReady : 
    
  end_case;
  
END_FUNCTION

FUNCTION FileTransferHandle::CheckStartOperation
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
//*******************************************************************************************************
//*********************   je nach Status darf gestartet werden oder nicht *******************************
//*******************************************************************************************************
  case sState of
//*******************************************************************************************************
  	FT_NoAction:                retcode := TRUE;
//*******************************************************************************************************
  	FT_Error:                   retcode := TRUE;
//*******************************************************************************************************
  	FT_OperationReady:          retcode := TRUE;
  else
    retcode := FALSE;
  end_case;

END_FUNCTION

FUNCTION GLOBAL FileTransferHandle::GetContentList
	VAR_INPUT
		pSourceDP 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpDP : Array [0..(FILETRANSFER_MAX_STRING_LEN-1)] of char;
  END_VAR
  
  // Rückgagewert -> andere Aktion läuft bereits
  retcode := 0;    
  if CheckStartOperation() = TRUE then
    // Rückgagewert -> Pointer inkorrekt.
    retcode := -1;
    if pSourceDP <> NIL then
      // String umkopieren für bearbeitung im Background
      cSigCLib.StrCpy(dst0:=#tmpDP[0], src0:=pSourceDP);
      // Rückgagewert -> Job konnte nicht gestartet werden.
      retcode := -2;
      // Auftrag an Gegenstelle schicken.
      if cToCom.SendData(pData:=#tmpDP[0], length:= cSigCLib.StrLen(str:=#tmpDP[0])+1 , timeout:=0, OptCMD:=FileTransfer_GetFolderContent) >=0 then
        
        udTimeMarkTimeout := ops.tAbsolute;
        
        // Rückgagewert -> Aktion wurde gestartet.
        retcode := 1;
        // Im Background auf die Antwort warten.
        sState := FT_WaitForResponseGetFolderContent;
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION FileTransferHandle::Send_Requested_FolderContent

//*******************************************************************************************************
//*********************   Inhalt des angeforderten Direktory auslesen und schicken    ******************
//*******************************************************************************************************
  case SSW_Send_FolderContent of

//*******************************************************************************************************  
    FT_SUB_NoAction :

//*******************************************************************************************************    
    FT_SUB_GetFolderContent:
      // letztes Ergebniss verwerfen.
      _memset(dest:=#FolderContent, usByte:=0, cntr:=sizeof(FolderContent));
      // Verzeichnissstruktur auslesen.
      
      case GetFileContentRecursive(#SourceDPContent[0],NIL) of
      
        1 : // kein Fehler
            SSW_Send_FolderContent := FT_SUB_SendFolderContent;
            
        0 : // Ordner ohne Inhalt oder Ordner nicht forhanden.
            SSW_Send_FolderContent := FT_SUB_Error_GetFolder_EmptyFolder;
            sState := FT_Error;
            // Error zur Gegenstelle übertragen
            SendError(Status:=FT_SUB_Error_GetFolder_EmptyFolder);
        
       -1 : // Maximale Anzahl der Elemente ist erreicht.
            SSW_Send_FolderContent := FT_SUB_Error_GetFolder_ToMuchEntries;
            sState := FT_Error;
            // Error zur Gegenstelle übertragen
            SendError(Status:=FT_SUB_Error_GetFolder_ToMuchEntries);
      end_case;

//*******************************************************************************************************    
    FT_SUB_SendFolderContent:
      // Inhalt des Verzeichniss zur Gegenstelle schicken.
      JobID := cToCom.SendData(pData:=#FolderContent, length:=(sizeof(FolderContent.Nr) + FolderContent.Nr*sizeof(_FT_FolderContentEntrie)), timeout:=0, OptCMD:=FileTransfer_GetFolderContent_RSP);
      // Prüfen of Job angenommen wurde.
      if JobID >= 0 then
        // OK
        udTimeMarkTimeout := ops.tAbsolute;
        SSW_Send_FolderContent := FT_SUB_WaitResponseSendedFolderContent ; 
      else
        // Fehler beim Schicken.
        SSW_Send_FolderContent := FT_SUB_ErrorJobID;
        sState := FT_Error;
        // Error zur Gegenstelle übertragen
        SendError(Status:=FT_SUB_ErrorJobID);
      end_if;

//*******************************************************************************************************        
   FT_SUB_WaitResponseSendedFolderContent: 
     // Auf Antwort der Gegenstelle warten.
     
     if ops.tAbsolute - udTimeMarkTimeout >= FileTransfer_ReceiveTimeout then
       
       SSW_Send_FolderContent := FT_SUB_ErrorCallback;
       sState := FT_Error;
       // Error zur Gegenstelle übertragen
       SendError(Status:=FT_SUB_ErrorCallback);     
     
     else
      
       // Daten wurden empfangen     
       if JobID = sCallbackOK then
         SSW_Send_FolderContent := FT_SUB_OperationReady;
         sState :=FT_OperationReady;
       end_if;
       
       // Gegenstelle hatte ein Problem
       if JobID = sCallbackError then
         SSW_Send_FolderContent := FT_SUB_ErrorCallback;
         sState := FT_Error;
         // Error zur Gegenstelle übertragen
         SendError(Status:=FT_SUB_ErrorCallback);
       end_if;

     end_if;

//*******************************************************************************************************        
   FT_SUB_OperationReady:     
        
  end_case;

END_FUNCTION

FUNCTION FileTransferHandle::AddContent
	VAR_INPUT
		pContentString 	: ^CHAR;
		Attrib 	: _FT_Attrib;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  // Rückgabewert -> Fehler
  retcode := FALSE;
  // nur eintragen , wenn noch Platz und ein gültiger Eintrag
  if (pContentString <> NIL) & (FolderContent.Nr < FileTransfer_MAX_FOLDER_ENTRIES) then
    // handelt es sich um ein File oder einen Ordner.
    FolderContent.Entrie[FolderContent.Nr].Attrib := Attrib;
    // String eintragen
    cSigCLib.StrCpy(dst0:=#FolderContent.Entrie[FolderContent.Nr].ContentString[0], src0:=pContentString);
    // Anzahl der Einträge erhöhen.
    FolderContent.Nr +=1;
    // Rückgabewert -> eingetragen
    retcode := TRUE;
  end_if;
  
END_FUNCTION

FUNCTION FileTransferHandle::GetFileContentRecursive
	VAR_INPUT
		pSearchPath 	: ^CHAR;
		pNextPath 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    locDDE_INFO : _DDE_INFO;
    SearchString : _FT_String;
    NextString : _FT_String;
    tmpName : _FT_String;
    tmpFindHandle : dint;
    FoundSomething : dint;
  END_VAR
  
  // Rückgabewert -> kein File gefunden.
  retcode := 0;
  // Wo soll gesucht werden
  cSigCLib.StrCpy(dst0:=#SearchString[0], src0:=pSearchPath);
  // Pfad der letzten Suche anhängen
  if pNextPath <> NIL then
    cSigCLib.StrCat(ps1:=#SearchString[0], ps2:=pNextPath);
  end_if;
  // nach allen Files suchen.
  cSigCLib.StrCat(ps1:=#SearchString[0], ps2:="*.*");
  // Suche starten
  tmpFindHandle :=  cFileSys.FindFirstEx( namepattern:=#SearchString[0], 
                                          attr0:=0,
                                          attrmask:=0, 
                                          fileinfo:=#locDDE_INFO, 
                                          filename:=#tmpName[0], 
                                          maxlength:=FileTransfer_MAX_STRING_LEN);
    
                                          
                                          
  // Wurde etwas gefunden
  if tmpFindHandle >= 0 then
    FoundSomething := 1;
    // solange suchen , bis nichts mehr gefunden wird.
    while FoundSomething >=0 do
      
      // Wenn ein Verzeichniss gefunden wurde
      if locDDE_INFO.Attributes = ATTR_DIR then
        // Die Verzeichnisse "." und ".." sind vom System -> auslassen
        if (cSigCLib.StrCmp(ps1:=#tmpName[0], ps2:=".") <> 0) & (cSigCLib.StrCmp(ps1:=#tmpName[0], ps2:="..") <> 0 ) Then
          // Pfad der letzten suche anhängen
          if pNextPath <> NIL then
            // neuen Verzeichnissstring erstellen.
            cSigCLib.StrCpy(dst0:=#NextString[0], src0:=pNextPath);
            cSigCLib.StrCat(ps1:=#NextString[0], ps2:=#tmpName[0]);
            cSigCLib.StrCat(ps1:=#NextString[0], ps2:="\");
            // gefundenen Ordner eintragen.
            if AddContent(pContentString:=#NextString[0], Attrib:=FT_Folder) = TRUE then
              // im gefundenen Ordner weitersuchen.
              retcode := GetFileContentRecursive(pSearchPath:=pSearchPath, pNextPath:=#NextString[0]);
              if retcode =-1 then
                Exit;
              end_if;
            else
              retcode := -1;
              Exit;
            end_if;
          else
            // neuen Verzeichnissstring erstellen.
            cSigCLib.StrCpy(dst0:=#NextString[0], src0:=#tmpName[0]);
            cSigCLib.StrCat(ps1:=#NextString[0], ps2:="\");
            // gefundenen Ordner eintragen.
            if AddContent(pContentString:=#NextString[0], Attrib:=FT_Folder) = TRUE then
              // im gefundenen Ordner weitersuchen.
              retcode := GetFileContentRecursive(pSearchPath:=pSearchPath, pNextPath:=#NextString[0]);
              if retcode =-1 then
                Exit;
              end_if;
            else
              retcode := -1;
              Exit;
            end_if;
          end_if;
        else
          // Systemverzeichnisse , nix tun
          // Rückgabewert -> Fehler
          retcode := TRUE;
        end_if;
      // Es wurde ein file gefunden.
      else
        if pNextPath <> NIL then
          // FileString zusammenbauen.
          cSigCLib.StrCpy(dst0:=#NextString[0], src0:=pNextPath);
          cSigCLib.StrCat(ps1:=#NextString[0], ps2:=#tmpName[0]);
          // gefundenes File eintragen. 
          if AddContent(pContentString:=#NextString[0], Attrib:=FT_File) = TRUE then
            // Rückgabewert -> kein Fehler
            retcode := 1;
          else
            // Rückgabewert -> Maximale Einträge sind erreicht.
            retcode := -1;
            exit;
          end_if;
        else
          // FileString eintragen. 
          cSigCLib.StrCpy(dst0:=#NextString[0], src0:=#tmpName[0]);
          // gefundenes File eintragen. 
          if AddContent(pContentString:=#NextString[0], Attrib:=FT_File) = TRUE then
            // Rückgabewert -> kein Fehler
            retcode := 1;
          else
            // Rückgabewert -> Maximale Einträge sind erreicht.
            retcode := -1;
            exit;
          end_if;
        end_if;
        
      end_if;
      
      // nächsten Eintrag suchen.
      FoundSomething := cFileSys.FindNextEx(fhandle:=tmpFindHandle, fileinfo:=#locDDE_INFO, filename:=#tmpName[0], maxlength:=FileTransfer_MAX_STRING_LEN);
    
    end_while;
    
    // Suche abschließen
    cFileSys.FindClose(handle:=tmpFindHandle);
  end_if;

END_FUNCTION

FUNCTION GLOBAL FileTransferHandle::GetRecivedContentList
	VAR_INPUT
		pFolderContent 	: ^_FT_FolderContent;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  // Rückgabewert -> Fehler
  retcode := FALSE;
  if pFolderContent <> NIL then
    // Daten umkopieren
    _memcpy(ptr1:=pFolderContent, ptr2:=#FolderContent , cntr:=(sizeof(FolderContent.nr)+ FolderContent.Nr*sizeof(_FT_FolderContentEntrie) ) );
    // Rückgabewert -> OK
    retcode := TRUE;
    // Mitteilung das die Daten abgeholt wurden.
    sState := FT_OperationReady;
  end_if;

END_FUNCTION

FUNCTION GLOBAL FileTransferHandle::PrepairPathDelBS
	VAR_INPUT
		pPath 	: ^CHAR;
	END_VAR
  VAR
  	tmpLength : udint;
  END_VAR

  // länge des Strings ermitteln
  tmpLength :=  cSigCLib.StrLen(str:=pPath);
  // nur wenn ein String vorhanden ist.
  if tmpLength > 0 then
    // Wenn das letzte Zeichen ein \ ist , wird dieser gelöscht.
    if (pPath+tmpLength-1)^ = '\' then
      (pPath+tmpLength-1)^ :=0;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL FileTransferHandle::PrepairPathAddBS
	VAR_INPUT
		pPath 	: ^CHAR;
	END_VAR
  VAR
  	tmpLength : udint;
  END_VAR

  // länge des Strings ermitteln
  tmpLength :=  cSigCLib.StrLen(str:=pPath);
  // nur wenn ein String vorhanden ist.
  if tmpLength > 0 then
    // Wenn das letzte Zeichen kein \ ist , wird das Zeichen angehängt.
    if (pPath+tmpLength-1)^ <> '\' then
      cSigCLib.StrCat(ps1:=pPath, ps2:="\");
    end_if;
  end_if;

END_FUNCTION

FUNCTION FileTransferHandle::SendError
	VAR_INPUT
		Status 	: _FT_SubState;
	END_VAR
  
  // Fehler and die Gegenstelle weiterleiten.
  cToCom.SendData(pData:=#Status, length:=sizeof(_FT_SubState), timeout:=0, OptCMD:=FileTransfer_Error);

END_FUNCTION
