//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "DateAndTime"
	Revision           = "1.1"
	GUID               = "{4CA7EADC-FC88-4A44-8B72-562F729BEE74}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(720,900)">
	<Channels>
		<Server Name="Day" GUID="{67FC0A11-44B6-4026-B1C2-EAEA539B5E73}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Hour" GUID="{8A9D69D6-0A80-4BF7-904E-8672F43A5A15}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HourAndMin" GUID="{E31DE4A6-6A5B-4FF0-90C7-5B13120425D5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Minute" GUID="{374656F2-39E3-4683-A88C-403C76F45457}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Month" GUID="{F441FD7C-7F46-4C54-8349-A348DA645123}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Second" GUID="{6534607C-E4FB-49B8-8DFC-3ADD6C35527B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Server" GUID="{76C90443-EDF6-4178-8B7E-E07781A5462C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="SuMarch" GUID="{C81C8BDA-8B0E-4167-84D8-BDEAA8D3D3A2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="SuOct" GUID="{5E29B714-D2E0-4A88-B5DE-CF29141CCBB5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server
			Name           = "SysDate"
			Initialize     = "false"
			Visualized     = "true"
			WriteProtected = "true">
		</Server>
		<Server
			Name           = "SysTime"
			Initialize     = "false"
			Visualized     = "true"
			WriteProtected = "true">
		</Server>
		<Server Name="WTime" GUID="{99C39422-D727-4863-8C63-B4A205CFF0E4}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Year" GUID="{206705B2-F422-4DD9-B366-35C8BD2028B9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
	</Channels>
	<Network Name="DateAndTime">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name           = "_base"
				GUID           = "{2EA612B5-C0EF-489A-B459-3C3AA38DBE30}"
				Class          = "_SysDateTime"
				Position       = "(270,150)"
				Visualized     = "true"
				BackgroundTime = "10 ms">
				<Channels>
					<Server Name="DayOfWeek"/>
					<Server Name="SysDate"/>
					<Server Name="SysTime"/>
					<Client Name="DoSummerTime"/>
					<Client Name="System"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.SysDate" Destination="_base.SysDate" Vertices="(998,210),(826,240),"/>
			<Connection Source="this.SysTime" Destination="_base.SysTime" Vertices="(998,270),(826,300),"/>
			<Connection Source="this.DayOfWeek" Destination="_base.DayOfWeek" Vertices="(998,330),(826,360),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _SysDateTime

DateAndTime : CLASS
: _SysDateTime
  //Servers:
	Year 	: SvrCh_DINT;
	Month 	: SvrCh_DINT;
	Day 	: SvrCh_DINT;
	Hour 	: SvrCh_DINT;
	Minute 	: SvrCh_DINT;
	Second 	: SvrCh_DINT;
	HourAndMin 	: SvrCh_DINT;
	WTime 	: SvrCh_DINT;
	Server 	: SvrCh_DINT;
	SuMarch 	: SvrCh_DINT;
	SuOct 	: SvrCh_DINT;
  //Clients:
  //Variables:
		SysTimeAndDate 	: DatumEnTijd;
		f 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION UpdateTime;
	
	FUNCTION UpdateDate;
	
	FUNCTION Algoritmen;
	
	FUNCTION UpdateWithBG;
	
	FUNCTION VIRTUAL GLOBAL Year::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Month::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Day::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Hour::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Minute::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Second::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL WTime::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DateAndTime::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_DATEANDTIME
1$UINT, 1$UINT, (SIZEOF(::DateAndTime))$UINT, 
11$UINT, 0$UINT, 0$UINT, 
TO_UDINT(817179225), "DateAndTime", //Class
TO_UDINT(3931827689), "_SysDateTime", 0$UINT, 6$UINT, //Baseclass
//Servers:
(::DateAndTime.Year.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2367135363), "Year", 
(::DateAndTime.Month.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2044908214), "Month", 
(::DateAndTime.Day.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1929866010), "Day", 
(::DateAndTime.Hour.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1183579386), "Hour", 
(::DateAndTime.Minute.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2654628915), "Minute", 
(::DateAndTime.Second.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1189598959), "Second", 
(::DateAndTime.HourAndMin.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(963416075), "HourAndMin", 
(::DateAndTime.WTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(877940267), "WTime", 
(::DateAndTime.Server.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2861896304), "Server", 
(::DateAndTime.SuMarch.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2628925706), "SuMarch", 
(::DateAndTime.SuOct.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2312568384), "SuOct", 
//Clients:
END_FUNCTION


#define USER_CNT_DateAndTime 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DateAndTime] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DateAndTime::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _SysDateTime::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _SysDateTime::SysDate.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _SysDateTime::SysDate.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_DateAndTime;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	_SysDateTime::SysDate.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _SysDateTime::SysDate.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Year.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Year::Write() );
	IF Year.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Month.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Month::Write() );
	IF Month.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Day.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Day::Write() );
	IF Day.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Hour.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Hour::Write() );
	IF Hour.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Minute.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Minute::Write() );
	IF Minute.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Second.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Second::Write() );
	IF Second.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	WTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #WTime::Write() );
	IF WTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//*********************Inserted from .\DateAndTime\DateAndTime_00_00.st*********************

FUNCTION VIRTUAL GLOBAL DateAndTime::Background
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR
VAR
  tme : SYSTIME;  
  dte : SYSDATE;
  tmp  : UDINT;  
END_VAR

  // YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW
  // HHHHHHHHNNNNNNNNSSSSSSSSxxxxxxxx
  
  // y .... year
  // m .... month
  // d .... day
  // w .... day of week
  // h .... hour
  // n .... minutes
  // s .... second
  // x .... initialized with 0


  System.GetSysTime(#tme); 
  System.GetSysDate(#dte);
//  WTime := WinterTime.Read();

  tmp       := tme.wHour and 16#FF; 
  Hour		  := tmp$dint;
  tmp       := (tmp shl 8) or (tme.wMinute and 16#FF); 
  Minute	  := (tme.wMinute and 16#FF);
  tmp       := (tmp shl 8) or (tme.wSecond and 16#FF);
  second    := (tme.wSecond and 16#FF);
  SysTime   := (tmp shl 8); 

  tmp       := dte.wYear; 
  Year 		  := tmp$dint;
  tmp       := (tmp shl 4) or dte.wMonth; 
  Month		  := dte.wMonth; 
  tmp       := (tmp shl 8) or dte.wDay;
  Day		    := dte.wDay;
  tmp       := (tmp shl 4) or dte.wDayOfWeek; 

  SysDate   := tmp;

  DayOfWeek := dte.wDayOfWeek;
  state     := 0;  

  SysTimeAndDate.Year		:= to_uint Year;
	SysTimeAndDate.Month	:= to_usint Month;
	SysTimeAndDate.Day		:= to_usint Day;
	SysTimeAndDate.Hour		:= to_usint Hour;
	SysTimeAndDate.Minute	:= to_usint Minute;
	SysTimeAndDate.Second	:= to_usint Second;

  Algoritmen();
	HourAndMin := (Hour*100) + Minute;

(*  now in sigmatek class _sysDateTime 11febr2008
  // ga naar wintertijd (laatste zondag van Oktober om 03.00)
	if Month = 10 & Day >= SuOct & Hour >= 3 & WTime = 0 then
    Hour -= 1;
    UpdateTime();
		WTime := 1;
		WinterTime.Write(WTime);
	else
		if Month > 10 | Month < 3 then // wintertijd
			if  WTime = 0 then
				Hour -= 1;
        UpdateTime();
        WTime := 1;
				WinterTime.Write(WTime);
			end_if;
		end_if;
	end_if;

// ga naar zomertijd (laatste zondag van Maart)
	if Month = 3 & Day >= SuMarch & WTime = 1 then
    Hour += 1;    
    UpdateTime();
		WTime := 0;
		WinterTime.Write(WTime);
	else
		if Month > 3 & Month < 10 then // zomertijd
			if  WTime = 1 then
        Hour += 1;
        UpdateTime();			
        WTime := 0;
				WinterTime.Write(WTime);
			end_if;
		end_if;
	end_if;
*)

END_FUNCTION //VIRTUAL GLOBAL DateAndTime::Background

FUNCTION VIRTUAL GLOBAL DateAndTime::Year::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Year := input;
  UpdateDate();
  result := 0;  
 
END_FUNCTION //VIRTUAL GLOBAL DateAndTime::Jaar::Write

FUNCTION VIRTUAL GLOBAL DateAndTime::Month::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Month := input;
  UpdateDate();
 	result := Month;
END_FUNCTION //VIRTUAL GLOBAL DateAndTime::Maand::Write

FUNCTION VIRTUAL GLOBAL DateAndTime::Day::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Day := input;
  UpdateDate();
 	result := Day;
  
END_FUNCTION //VIRTUAL GLOBAL DateAndTime::Dag::Write

FUNCTION VIRTUAL GLOBAL DateAndTime::Hour::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Hour := input;
  UpdateTime();
  result := 0; 


END_FUNCTION //VIRTUAL GLOBAL DateAndTime::Uur::Write

FUNCTION VIRTUAL GLOBAL DateAndTime::Minute::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Minute := input;
  UpdateTime();
 	result := Minute;
END_FUNCTION //VIRTUAL GLOBAL DateAndTime::Minuten::Write

FUNCTION VIRTUAL GLOBAL DateAndTime::Second::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Second := input;
  UpdateTime();
 	result := Second;
  
END_FUNCTION //VIRTUAL GLOBAL DateAndTime::Seconden::Write



FUNCTION VIRTUAL GLOBAL DateAndTime::WTime::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	WTime := input;
 	result := WTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DateAndTime::Init
(*
Begin zomertijd (vanaf 1981):

    Zondag [31 - (f + 5) mod 7] maart (om 1h U.T.C.)

Einde zomertijd (van 1981 t/m 1995):

    Zondag [30 - (f + 6) mod 7] september (om 1h U.T.C.)

Einde zomertijd (vanaf 1996):

    Zondag [31 - (f + 2) mod 7] oktober (om 1h U.T.C.)

met: f = (floor((5 × jaar)/4) - floor (jaar/100) + floor(jaar/400)) mod 7

De functie floor(x) - ook bekend als de entier functie - is gedefinieerd als het grootste gehele getal kleiner of gelijk aan de inputwaarde. Dus floor(2.99) = 2, floor(1.01) = 1, floor(0) = 0, floor(–1.01) = –2, etc.

De modulo functie (a mod b) is gedefinieerd als de (positieve) rest van de deling van het getal a door het getal b. Dus 5 mod 7 = 5, 13 mod 7 = 6, –3 mod 7 = 4, etc.

De bovenstaande algoritmen gelden zolang de huidige zomertijdregeling van kracht blijft.

*)


  _SysDateTime::Init();

END_FUNCTION


FUNCTION DateAndTime::UpdateTime
VAR
 t : SYSTIME; 
END_VAR

  t.wHour   := TO_UINT Hour;  
  t.wMinute := TO_UINT Minute; 
  t.wSecond := TO_UINT Second; 
  System.SetSysTime(#t); 
//  Background(0); 

END_FUNCTION


FUNCTION DateAndTime::UpdateDate
VAR
 t : SYSDATE; 
END_VAR

  t.wDay       := TO_USINT(Day);
  t.wMonth     := TO_USINT(Month); 
  t.wYear      := TO_UINT(Year);  
  t.wDayOfWeek := GetDayOfWeek(t.wDay, t.wMonth, t.wYear); 

  System.SetSysDate(#t); 
  Background(0);


END_FUNCTION


FUNCTION DateAndTime::Algoritmen

  f:= (((5 * Year)/4) -  (Year/100) + ((Year/400)) mod 7);

  // calculate the last sunday of the Month
  SuMarch := (31 - ((f+5) mod 7));
  SuOct   := (31 - ((f+2) mod 7));

END_FUNCTION


FUNCTION DateAndTime::UpdateWithBG
VAR
 t : SYSTIME; 
END_VAR

  t.wHour   := TO_UINT Hour;  
  t.wMinute := TO_UINT Minute; 
  t.wSecond := TO_UINT Second; 
  System.SetSysTime(#t); 
  Background(0); 



END_FUNCTION
