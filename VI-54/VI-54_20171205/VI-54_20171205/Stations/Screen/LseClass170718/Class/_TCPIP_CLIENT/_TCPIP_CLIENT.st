//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

  #define MB_CL_SEND_DATA_OK      0
  #define MB_CL_NOT_READY         -1
  #define MB_CL_WAIT_4_RESPONSE   -2
  #define MB_CL_SEND_DATA_FAILED  -3
  
//  #define MAX_CONNECTIONS         16
  
  #define TCPCLT_ERROR_NO            0
  #define TCPCLT_ERROR_INVALID_SOCK  -1
  #define TCPCLT_ERROR_CONNECTION    -2
  #define TCPCLT_ERROR_TIMEOUT       -3

  #define TCP_CLT_SEND_OK               0
  #define TCP_CLT_INVALID_HANDLE        -1
  #define TCP_CLT_NOT_CONNECTED         -2
  #define TCP_CLT_SEND_FAILED           -3
  #define TCP_CLT_SEND_BUFFER_FULL      -4
  #define TCP_CLT_DATA_TO_BIG_FOR_DIRECT_SENDING   -5
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_TCPIP_CLIENT"
	Revision           = "1.6"
	GUID               = "{737E7644-8481-4C04-B98F-BF7D954F6CDD}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	DefBackground      = "always"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(568,120)"
	Comment            = "TCP/IP Client for TCP/IP Communication.&#13;&#10;&#13;&#10;It is recommended to use one object per connection.">
	<Channels>
		<Server Name="Control" GUID="{4A378BA5-C1B5-4DC4-BA64-B864666189FE}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Object Channel&#13;&#10;-) use the channel to call global functions from external&#13;&#10;-) this server shows the TCP client state"/>
		<Client Name="cMaxConnections" Required="true" Internal="false" DefValue="0" Comment="Maximal number of connections. Maximal possible connections are 16.&#13;&#10;&#13;&#10;0 = 16 connections, because of compatibility to older versions."/>
		<Client Name="co_MultiTask" Required="false" Internal="false" Comment="Object Channel to _StdLib"/>
		<Client Name="co_StdLib" Required="false" Internal="false" Comment="Object Channel to _StdLib"/>
		<Client Name="cPort" Required="true" Internal="false" DefValue="502" Comment="port number ... must be connected or initialized"/>
		<Client Name="cSizeOfTXBuffer" Required="false" Internal="false" Comment="size of TX buffer [byte]&#13;&#10;if 0 there will be 1024 Byte allocated"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_tcp_user.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="SIGMATEK" Author="SCHMAT"/>
		<Dokumentation Revision="1.6" Date="2016-04-29" Author="HubChr" Company="SIGMATEK" Description="Improved Semaphore Handling"/>
		<Dokumentation Revision="1.5" Date="2015-07-07" Author="hoechr1" Company="SIGMATEK" Description="Methods AddConnection, DelConnection are now threadsave. (SA31299)&#13;&#10;Added support for sending more than 1452 bytes.&#13;&#10;Changed the connection buffer from dynamic to static memory management.&#13;&#10;Added client cMaxConnections for set the number of connections that should be initialized."/>
		<Dokumentation Revision="1.4" Date="2012-05-30" Author="spimar" Company="SIGMATEK" Description="Corrected a comment;"/>
		<Dokumentation Revision="1.3" Date="2012-03-20" Author="spimar&#13;&#10;schmat" Company="SIGMATEK" Description="Now the size of 1kb is allocated if there is no init value set on the client;&#13;&#10;The data buffer is now only cleared (free) if the pointer is valid;&#13;&#10;Now the right pointer is set at closesocket();"/>
		<Dokumentation Revision="1.2" Date="2012-02-03" Author="wentob" Company="SIGMATEK" Description="Reconection timeout to prevent sync-flood. BETA!"/>
		<Dokumentation Revision="1.1" Date="2011-12-13" Author="spimar" Company="SIGMATEK" Description="The global methods are now virtual;"/>
		<Dokumentation Revision="1.0" Date="7.10.2010" Author="SCHMAT" Company="SIGMATEK" Description="TCP/IP Client for TCP/IP Communication"/>
	</RevDoku>
</Class>
*)
_TCPIP_CLIENT : CLASS
	TYPE
#pragma pack(push, 1)
	  _BUFFER_HEADER : STRUCT
	    DataSize : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _TX_RINGBUFFER : STRUCT  //! <Type Comment="struct to handle a ringbuffer" Name="_TX_RINGBUFFER"/>
	    udSize : UDINT;
	    udUsed : UDINT;
	    pMem : ^void;
	    pRead : ^void;
	    pWrite : ^void;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _CONNECTION : STRUCT
	    bInUse : BOOL;
	    szIPAddress : ARRAY [0..0x10] OF CHAR;
	    bConnected : BOOL;
	    dSocket : DINT;
	    FSM_TCP : _FSM_TCP_USER;
	    udTimeout : UDINT;
	    udTimeStamp : UDINT;
	    pCallbackThis : ^void;
	    pCallbackMeth : ^void;
	    RingbufferForSending : _TX_RINGBUFFER;
	    pSendReceiveBuffer : ^CHAR;
	    pSendReceiveBufferHelp : ^CHAR;
	    BufferHeader : _BUFFER_HEADER;
	  END_STRUCT;
#pragma pack(pop)
	  _FSM_CLT_STATE :
	  (
	    _STATE_INIT,
	    _STATE_WORK
	  )$UDINT;
#pragma pack(push, 1)
	  _TCP_CLT_CONNECTS : STRUCT
	    dActConn : DINT;
	    pConnections : ^_CONNECTION;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Control 	: SvrChCmd__FSM_TCP_USER;
  //Clients:
	cPort 	: CltCh_DINT;
	cSizeOfTXBuffer 	: CltCh_UDINT;
	cMaxConnections 	: CltCh_DINT;
	co_StdLib 	: CltChCmd__StdLib;
	co_MultiTask 	: CltChCmd__MultiTask;
  //Variables:
		pActConnection 	: ^_CONNECTION;			//! <Variable Comment="includes all Informations to the act Connection" Name="pActConnection"/>
		FSMClient 	: _FSM_CLT_STATE;			//! <Variable Comment="SSW for Connection" Name="FSMClient"/>
		udSendError 	: UDINT;			//! <Variable Comment="Counter if sending Data failed" Name="udSendError"/>
		SemaHandle1 	: MT_SEMAHANDLE;			//! <Variable Comment="Handle of the mutex semaphore" Name="SemaHandle1"/>
		pConnectionBuffer 	: ^_CONNECTION;			//! <Variable Comment="Buffer for the informations of all conenctions" Name="pConnectionBuffer"/>
		udCountActualCon 	: UDINT;			//! <Variable Comment="Number of the connection which is used in the actual CyclicCall" Name="udCountActualCon"/>
		dActConnections 	: DINT;			//! <Variable Comment="Value of actual connected servers" Name="dActConnections"/>
		LocalConnectionCycle 	: _CONNECTION;			//! <Variable Comment="Local bufferfor the actual connection." Name="LocalConnectionCycle"/>
		LocalConnectionSending 	: _CONNECTION;			//! <Variable Comment="Local buffer for sending informations and data." Name="LocalConnectionSending"/>
  //Functions:
				//! <Function Comment="-) initialize TCP USER pointer to use OS TCP FUNCTIONS&#13;&#10;-) read port number&#13;&#10;-) Allocate Memory for Buffers" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Call this Function to add a Object for sending/receiving Data to a TCP/IP Server" Name="AddConnection"/>
	FUNCTION VIRTUAL GLOBAL AddConnection
		VAR_INPUT
			pIPAddress 	: ^CHAR;			//! <Variable Comment="Pointer to IP-Address&#13;&#10;Needs to be a dotted string!&#13;&#10;&#13;&#10;e.g. &quot;192.168.2.1&quot;" Name="AddConnection.pIPAddress"/>
			pCallbackThis 	: ^void;			//! <Variable Comment="This Pointer to Object which should be called" Name="AddConnection.pCallbackThis"/>
			pCallbackMeth 	: ^void;			//! <Variable Comment="Pointer to Method which should be called" Name="AddConnection.pCallbackMeth"/>
			udTimeout 	: UDINT;			//! <Variable Comment="in [ms]&#13;&#10;Timeout to close Connection when no Data is received or sended&#13;&#10;0 ... No Timeout activated (connection will not be closed)" Name="AddConnection.udTimeout"/>
		END_VAR
		VAR_OUTPUT
			dHandle 	: DINT;			//! <Variable Comment="Save this Handle to call the &quot;IsConnected&quot; and &quot;SendData&quot; Function&#13;&#10;&#13;&#10;0...Error&#13;&#10;&gt;0...OK" Name="AddConnection.dHandle"/>
		END_VAR;
				//! <Function Comment="Handles the Connection and Data receiving and sending" Name="CyclicCall"/>
	FUNCTION VIRTUAL GLOBAL CyclicCall;
				//! <Function Comment="this function writes data into the TX buffer&#13;&#10;&#13;&#10;the first 4 Bytes are always the size of the following Data" Name="RingbufferWrite"/>
	FUNCTION RingbufferWrite
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="this function reads data from the TX buffer" Name="RingbufferRead"/>
	FUNCTION RingbufferRead
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="Delete one Entry in SendBuffer" Name="FLUSHRingbuffer"/>
	FUNCTION VIRTUAL GLOBAL FLUSHRingbuffer
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="Handle what you get after calling &quot;AddConnection&quot;" Name="FLUSHRingbuffer.dHandle"/>
		END_VAR;
				//! <Function Comment="Function to send data over TCP/IP&#13;&#10;" Name="SendData"/>
	FUNCTION VIRTUAL GLOBAL SendData
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="Pointer to Data" Name="SendData.pData"/>
			udSize 	: UDINT;			//! <Variable Comment="Size of Data" Name="SendData.udSize"/>
			dHandle 	: DINT;			//! <Variable Comment="Handle what you get after calling &quot;AddConnection&quot;" Name="SendData.dHandle"/>
			bDirect 	: BOOL;			//! <Variable Comment="0 ... Write it to Send Buffer and send it in next Cyclus&#13;&#10;1 ... Send it imidiatly" Name="SendData.bDirect"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="0 ... TCP_CLT_SEND_OK         &#13;&#10;-1... TCP_CLT_INVALID_HANDLE  &#13;&#10;-2... TCP_CLT_NOT_CONNECTED   &#13;&#10;-3... TCP_CLT_SEND_FAILED     &#13;&#10;-4... TCP_CLT_SEND_BUFFER_FULL&#13;&#10;-5... TCP_CLT_DATA_TO_BIG     &#13;&#10;" Name="SendData.dRetcode"/>
		END_VAR;
	
	FUNCTION Callback
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR;
				//! <Function Comment="initialize connection structure" Name="INITConnection"/>
	FUNCTION INITConnection
		VAR_INPUT
			pConnection 	: ^_CONNECTION;
		END_VAR;
				//! <Function Comment="Call this Function to check if Connection is OK and the Handle will be saved" Name="IsConnected"/>
	FUNCTION VIRTUAL GLOBAL IsConnected
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="Handle from &quot;AddConnection&quot;" Name="IsConnected.dHandle"/>
		END_VAR
		VAR_OUTPUT
			bRetcode 	: BOOL;			//! <Variable Comment="1 ... connected&#13;&#10;0 ... not connected" Name="IsConnected.bRetcode"/>
		END_VAR;
				//! <Function Comment="Delet (shutdown) one Connection" Name="DelConnection"/>
	FUNCTION VIRTUAL GLOBAL DelConnection
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="Handle from &quot;AddConnection&quot;" Name="DelConnection.dHandle"/>
		END_VAR;
				//! <Function Comment="checks the Handle for validity" Name="CheckHandleValid"/>
	FUNCTION CheckHandleValid
		VAR_INPUT
			dHandle 	: DINT;
		END_VAR
		VAR_OUTPUT
			bRetcode 	: BOOL;
		END_VAR;
				//! <Function Comment="send Data via OS-Function" Name="SendTCP"/>
	FUNCTION SendTCP
		VAR_INPUT
			pConnection 	: ^_CONNECTION;
			pData 	: ^CHAR;
			udSize 	: UDINT;
			udTimeout 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _TCPIP_CLIENT::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__TCPIP_CLIENT
1$UINT, 6$UINT, (SIZEOF(::_TCPIP_CLIENT))$UINT, 
1$UINT, 5$UINT, 0$UINT, 
TO_UDINT(2629403047), "_TCPIP_CLIENT", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_TCPIP_CLIENT.Control.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3533623889), "Control", 
//Clients:
(::_TCPIP_CLIENT.cPort.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2368846560), "cPort", 
(::_TCPIP_CLIENT.cSizeOfTXBuffer.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1870367421), "cSizeOfTXBuffer", 
(::_TCPIP_CLIENT.cMaxConnections.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4178062980), "cMaxConnections", 
(::_TCPIP_CLIENT.co_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3072335391), "co_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_TCPIP_CLIENT.co_MultiTask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(123997224), "co_MultiTask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT__TCPIP_CLIENT 6

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__TCPIP_CLIENT] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _TCPIP_CLIENT::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__TCPIP_CLIENT, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #AddConnection();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #CyclicCall();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #FLUSHRingbuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #SendData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #IsConnected();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #DelConnection();

#pragma warning (default : 74)
	Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


// ****************************************************************************
// * T C P / I P   C l i e n t                 		               	            *
// ****************************************************************************
// *							                                                            *
// *	Created: Sigmatek 10/2010 by SCHMAT                                     *
// *	Version: V1.00              					                                  *
// *                                                    					            *
// *	Changes: 						                                                    *
// *								                                                          *
// ****************************************************************************

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// To connect to a TCP/IP Server you have to call the "AddConnection" Function and then the "IsConnected" Function
// To send Data call the "SendData" Function

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

VAR_PRIVATE
  lsl_tcp_user : ^LSL_TCP_USER;
END_VAR

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::Init
VAR
	pConnectionBufferHelp : ^_CONNECTION;
  i                     : UDINT;
  udLen                 : UDINT;
  aObjectName           : ARRAY [0..299] OF CHAR;
END_VAR

  if (_firstscan) then 
    
    cMaxConnections := cMaxConnections.Read();
    
    if cMaxConnections <= 0 then
      cMaxConnections := 16;
    elsif cMaxConnections > 16 then
      cMaxConnections := 16;
    end_if;
    
    if OS_CILGET("TCP_USER", #lsl_tcp_user) then 
      lsl_tcp_user := NIL;
    end_if;
    
    udLen := _GetObjName(pThis:=this, pName:=#aObjectName[0]);
    
    if udLen > 0 then
      SemaHandle1 := co_MultiTask.CREATESEMAPHORE(type0:=MTSEMATYPE_MUTEX, init0:=1, flags0:=0, name0:=#aObjectName[0]);
      
      if (SemaHandle1 = NIL) then
        TRACE("Creating Mutex failed");
        Control := _STATE_ERROR_CREATING_MUTEX;
        return;
      end_if;
    else
      TRACE("Creating Mutex failed, get object name failed");
      Control := _STATE_ERROR_CREATING_MUTEX;
      return;
    end_if;

    cPort := cPort.Read(); //### read port number
    cSizeOfTXBuffer := cSizeOfTXBuffer.Read(); //### read size of TX buffer

    if (cSizeOfTXBuffer = 0) then
      cSizeOfTXBuffer := 1024;
    end_if;
    
    //###################################################################################
    //### allocate memory for connection structure
    //###################################################################################
    pConnectionBuffer$^void := co_StdLib.Malloc(size:=(sizeof(_CONNECTION) * cMaxConnections$UDINT));
    
    if (pConnectionBuffer = NIL) then
      TRACE("Allocating memory failed");
      Control := _STATE_ERROR_ALLOCATING_MEMORY;
      return;
    end_if;

    //###################################################################################
    //### allocate memory for send buffer (RINGBUFFER)
    //###################################################################################
    pConnectionBufferHelp := pConnectionBuffer;
      
    for i := 0 to (cMaxConnections$UDINT - 1) do
      pConnectionBufferHelp^.RingbufferForSending.pMem$^void  := co_StdLib.Malloc(size := cSizeOfTXBuffer);
      
        
      if (pConnectionBufferHelp^.RingbufferForSending.pMem = NIL) then
        co_StdLib.Free(mptr := pConnectionBuffer + (sizeof(_CONNECTION) * i));
        TRACE("Initalize send buffer failed");
        Control := _STATE_ERROR_ALLOCATING_MEMORY;
        return;
      else
        //###################################################################################
        //### initialize send buffer (RINGBUFFER)
        //###################################################################################
        pConnectionBufferHelp^.RingbufferForSending.udSize := to_UDINT(cSizeOfTXBuffer);
        pConnectionBufferHelp^.RingbufferForSending.udUsed := 0;
        pConnectionBufferHelp^.RingbufferForSending.pRead := pConnectionBufferHelp^.RingbufferForSending.pMem;
        pConnectionBufferHelp^.RingbufferForSending.pWrite := pConnectionBufferHelp^.RingbufferForSending.pMem;
        pConnectionBufferHelp^.pSendReceiveBuffer$^void := co_StdLib.Malloc(size:=cSizeOfTXBuffer);
        
        if pConnectionBufferHelp^.pSendReceiveBuffer = NIL then
          TRACE("Allocating memory failed");
          Control := _STATE_ERROR_ALLOCATING_MEMORY;
          return;
        end_if;
      end_if;
      //##################################################################################
      //### initialize connection structure
      //##################################################################################
      INITConnection(pConnection:=pConnectionBufferHelp);
        
      pConnectionBufferHelp += sizeof(_CONNECTION);
    end_for;
    
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::INITConnection
	VAR_INPUT
		pConnection 	: ^_CONNECTION;
	END_VAR

  //##################################################################################
  //### initialize connection structure
  //##################################################################################

  pConnection^.bConnected := false;
  pConnection^.bInUse := false;
  pConnection^.dSocket := 0;
  _memset(dest := #pConnection^.szIPAddress[0], usByte := 0x00, cntr := 0x10);
  pConnection^.pCallbackMeth := NIL;
  pConnection^.pCallbackThis := NIL;
  pConnection^.udTimeStamp := 0;
  pConnection^.RingbufferForSending.udUsed := 0;
  pConnection^.RingbufferForSending.pRead := pConnection^.RingbufferForSending.pMem;
  pConnection^.RingbufferForSending.pWrite := pConnection^.RingbufferForSending.pMem;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::AddConnection
	VAR_INPUT
		pIPAddress 	: ^CHAR;
		pCallbackThis 	: ^void;
		pCallbackMeth 	: ^void;
		udTimeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dHandle 	: DINT;
	END_VAR
VAR
  pConnection   : ^_CONNECTION;
  retval        : DINT;
  i             : DINT;
END_VAR
  
  dHandle := 0;

  if (pIPAddress = NIL) | (pConnectionBuffer = NIL) | (Control = _STATE_ERROR_CREATING_MUTEX) | (Control = _STATE_ERROR_ALLOCATING_MEMORY) then
    return;
  end_if;

  retval := co_MultiTask.WAIT(handle0:=SemaHandle1);
  
  if (dActConnections < cMaxConnections) then

    for i := 1 to (cMaxConnections) do
      pConnection := pConnectionBuffer + (sizeof(_CONNECTION) * (i - 1));
      if pConnection^.bInUse <> true then
        exit;
      end_if;
    end_for;

    //###################################################################################
    //### initialize connection structure
    //###################################################################################

    pConnection^.udTimeout := udTimeout;
    _strcpy(dest := #pConnection^.szIPAddress[0], src  := pIPAddress);
    pConnection^.pCallbackThis := pCallbackThis;
    pConnection^.pCallbackMeth := pCallbackMeth;
    pConnection^.bInUse := true;
    pConnection^.FSM_TCP := _STATE_IDLE;
    
    dHandle := pConnection$DINT;
    
    dActConnections += 1;
  end_if;
    
  retval := co_MultiTask.SIGNAL(handle0:=SemaHandle1);
  
  
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::DelConnection
	VAR_INPUT
		dHandle 	: DINT;
	END_VAR
VAR
  retval        : DINT;
END_VAR

  if (CheckHandleValid(dHandle := dHandle) = false) then //### invalid handle
    return;
  end_if;
  
  retval := co_MultiTask.WAIT(handle0:=SemaHandle1);
  
  //###################################################################################
  //### close socket of the connection
  //###################################################################################
  OS_TCP_USER_CLOSESOCKET(dHandle$^_CONNECTION^.dSocket, 0);
  
  //###################################################################################
  //### reset connection structure
  //###################################################################################
  INITConnection(pConnection:=dHandle$^_CONNECTION);
  
  dActConnections -= 1;
  
  if dActConnections <= 0 then
    dActConnections := 0;
    pActConnection := NIL;
    FSMClient := _STATE_INIT;
  end_if;

  retval := co_MultiTask.SIGNAL(handle0:=SemaHandle1);
    
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::CyclicCall
VAR
  dRet          : DINT;
  dBytes        : DINT;
  retval        : DINT;
  pTmpThis      : ^void;
  i             : DINT;
END_VAR

  case FSMClient of

    //*******************************************************************************************************************************
    _STATE_INIT: //### initialization state
    //*******************************************************************************************************************************

      if (lsl_tcp_user <> NIL) then
        if (dActConnections) then  
          pActConnection := pConnectionBuffer;
          udCountActualCon := 1;
          FSMClient := _STATE_WORK;
        else
          pActConnection := NIL;
        end_if;
      end_if;

    //*******************************************************************************************************************************
    _STATE_WORK: //### work state
    //*******************************************************************************************************************************

      //############################################################################################
      //##                                                                                        ##
      //##    this finite state machine is used for the main TCP/IP connection:                   ##
      //##                                                                                        ##
      //##    -> allocate sockets                                                                 ##
      //##    -> build a connection to a specified socket                                         ##
      //##    -> receive data from server                                                         ##
      //##    -> disable receives and sends on socket                                             ##
      //##    -> close socket                                                                     ##
      //##                                                                                        ##
      //############################################################################################
      
      co_MultiTask.WAIT(handle0:=SemaHandle1); // HubChr v1.6
      if pActConnection <> NIL then
      
        // copy connection data to local structure
        _memcpy(ptr1:=#LocalConnectionCycle, ptr2:=pActConnection, cntr:=sizeof(_CONNECTION));
        
        retval := co_MultiTask.SIGNAL(handle0:=SemaHandle1);
        
        Control := LocalConnectionCycle.FSM_TCP;
        
        case LocalConnectionCycle.FSM_TCP of

          //****************************************************************************
          _STATE_IDLE: // idle state
          //****************************************************************************

            if (LocalConnectionCycle.bConnected = false) (*& (ops.tAbsolute - pActConnection^.udTimeStamp) > pActConnection^.udTimeout *)then
              LocalConnectionCycle.FSM_TCP := _STATE_MAIN_SOCK;
            end_if;


          //****************************************************************************
          _STATE_MAIN_SOCK: // allocate socket
          //****************************************************************************

            LocalConnectionCycle.dSocket := OS_TCP_USER_SOCKET();

            if (LocalConnectionCycle.dSocket < 0) then
              LocalConnectionCycle.FSM_TCP := _STATE_ERROR;
            else
              LocalConnectionCycle.FSM_TCP := _STATE_CONNECT;
            end_if;


          //****************************************************************************
          _STATE_CONNECT: // connect
          //****************************************************************************

            if (_strlen(#LocalConnectionCycle.szIPAddress[0])) & ((ops.tAbsolute - LocalConnectionCycle.udTimeStamp) > LocalConnectionCycle.udTimeout) then 
              dRet := OS_TCP_USER_CONNECT(LocalConnectionCycle.dSocket,
                                          0,
                                          #LocalConnectionCycle.szIPAddress[0],
                                          TO_UDINT(cPort),
                                          0);
                                          
              LocalConnectionCycle.udTimeStamp := 0;

              if (dRet < 0) then
                if (dRet <> TCP_NOT_READY) then
                  LocalConnectionCycle.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;                          // set FSM to close main socket
                  LocalConnectionCycle.udTimeStamp := ops.tAbsolute;
                end_if;
              elsif (dRet = 0) then
                LocalConnectionCycle.FSM_TCP := _STATE_RECV;
                LocalConnectionCycle.bConnected := true;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_RECV: // receive state
          //****************************************************************************

            dBytes := OS_TCP_USER_NREAD_AVAILABLE(LocalConnectionCycle.dSocket);

            if (dBytes <= 0) then
              if (dBytes <> TCP_NOT_READY) then
                LocalConnectionCycle.FSM_TCP := _STATE_SHUTDOWN;
              else
                if (LocalConnectionCycle.udTimeout) & (LocalConnectionCycle.udTimeStamp) then
                  if ((ops.tAbsolute - LocalConnectionCycle.udTimeStamp) > LocalConnectionCycle.udTimeout) then
                    LocalConnectionCycle.udTimeStamp := 0;
                    LocalConnectionCycle.FSM_TCP := _STATE_SHUTDOWN;
                  end_if;
                end_if;
              end_if;
            else

              if (dBytes$UDINT > cSizeOfTXBuffer) then
                dBytes$UDINT := cSizeOfTXBuffer;
              end_if;
            
              dRet := OS_TCP_USER_RECV(LocalConnectionCycle.dSocket,
                                       LocalConnectionCycle.pSendReceiveBuffer,
                                       to_UDINT(dBytes),
                                       0,
                                       0);
              
              if (dRet = dBytes) then
                pTmpThis := this;
                this$^void := LocalConnectionCycle.pCallbackThis;
                #pragma warning(disable: 137);
                pTmpThis^$_TCPIP_CLIENT.LocalConnectionCycle.pCallbackMeth$Callback(pData := #pTmpThis^$_TCPIP_CLIENT.LocalConnectionCycle.pSendReceiveBuffer^,
                                                                              udSize := dBytes$UDINT);

                #pragma warning(default: 137);
                this$^void := pTmpThis;
                LocalConnectionCycle.udTimeStamp := 0;
              else
                LocalConnectionCycle.FSM_TCP := _STATE_SHUTDOWN;
              end_if;
            end_if;
            
            if (LocalConnectionCycle.FSM_TCP = _STATE_RECV) then
              if (LocalConnectionCycle.RingbufferForSending.udUsed > sizeof(LocalConnectionCycle.BufferHeader.DataSize)) then // if udUsed is sizeof(BufferHeader), then only the header is in the ringbuffer and not data to send
                LocalConnectionCycle.FSM_TCP := _STATE_READ_RINGBUFFER; //_STATE_SEND;
              end_if;
            end_if;
          //****************************************************************************
          _STATE_READ_RINGBUFFER: // read from ringbuffer
          //****************************************************************************
            co_MultiTask.WAIT(handle0:=SemaHandle1);
            //##########################################################
            //### read message header from ringbuffer
            //##########################################################
            RingbufferRead(pBuffer := #LocalConnectionCycle.RingbufferForSending,
                           pData := #LocalConnectionCycle.BufferHeader.DataSize$^void,
                           udSize := sizeof(_BUFFER_HEADER)
                           );

            //##########################################################
            //### read message from ringbuffer
            //##########################################################
            
            if LocalConnectionCycle.BufferHeader.DataSize > 0 then
              RingbufferRead(pBuffer := #LocalConnectionCycle.RingbufferForSending,
                             pData := LocalConnectionCycle.pSendReceiveBuffer,
                             udSize := LocalConnectionCycle.BufferHeader.DataSize 
                             ); 
              co_MultiTask.SIGNAL(handle0:=SemaHandle1);                     
              LocalConnectionCycle.pSendReceiveBufferHelp := LocalConnectionCycle.pSendReceiveBuffer;
              LocalConnectionCycle.FSM_TCP := _STATE_SEND;
            else
              co_MultiTask.SIGNAL(handle0:=SemaHandle1);  // HubChr v1.6
              LocalConnectionCycle.FSM_TCP := _STATE_RECV;
            end_if;
            
          //****************************************************************************
          _STATE_SEND: // send data
          //****************************************************************************

            //##########################################################
            //### send data via OS function
            //##########################################################
            
            dRet := OS_TCP_USER_SEND(LocalConnectionCycle.dSocket, LocalConnectionCycle.pSendReceiveBufferHelp, LocalConnectionCycle.BufferHeader.DataSize, 0, 0);
            
            if dRet >= 0 then
              LocalConnectionCycle.BufferHeader.DataSize -= dRet$UDINT;
              LocalConnectionCycle.pSendReceiveBufferHelp += dRet;
              LocalConnectionCycle.udTimeStamp := ops.tAbsolute;
            else
              if (dRet <> TCP_NOT_READY) then
                LocalConnectionCycle.FSM_TCP := _STATE_SHUTDOWN;
              else 
                if (LocalConnectionCycle.udTimeout) & (LocalConnectionCycle.udTimeStamp) then
                  if (ops.tAbsolute - LocalConnectionCycle.udTimeStamp) >= LocalConnectionCycle.udTimeout then
                    LocalConnectionCycle.FSM_TCP := _STATE_SHUTDOWN;
                    LocalConnectionCycle.udTimeStamp := 0;
                  end_if;
                end_if;
              end_if;
            end_if;
            
            if LocalConnectionCycle.BufferHeader.DataSize <= 0 then
              LocalConnectionCycle.FSM_TCP := _STATE_RECV;
              LocalConnectionCycle.pSendReceiveBufferHelp := LocalConnectionCycle.pSendReceiveBuffer;
            end_if;

          //****************************************************************************
          _STATE_SHUTDOWN: // disable receives and sends on socket
          //****************************************************************************

            OS_TCP_USER_SHUTDOWN(LocalConnectionCycle.dSocket, 2);
            LocalConnectionCycle.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;


          //****************************************************************************
          _STATE_CLOSE_MAIN_SOCK: // close socket
          //****************************************************************************

            OS_TCP_USER_CLOSESOCKET(LocalConnectionCycle.dSocket, 0);
            LocalConnectionCycle.dSocket := 0;
            LocalConnectionCycle.bConnected := false;
            LocalConnectionCycle.FSM_TCP   := _STATE_IDLE;

          //****************************************************************************
          _STATE_ERROR,
          _STATE_ERROR_ALLOCATING_MEMORY, // error state
          _STATE_ERROR_CREATING_MUTEX: 
          //****************************************************************************
        
        else
          
          TRACE("Fatal Error");
          LocalConnectionCycle.FSM_TCP := _STATE_ERROR;
        
        end_case;      
        
        retval := co_MultiTask.WAIT(handle0:=SemaHandle1);
        
        if pActConnection^.bInUse = true then
          // recopy connection buffer
          _memcpy(ptr1:=pActConnection, ptr2:=#LocalConnectionCycle, cntr:=sizeof(_CONNECTION));
        end_if;
        
        pActConnection += sizeof(_CONNECTION);
        udCountActualCon += 1;
        
        if udCountActualCon > cMaxConnections$UDINT then
          udCountActualCon := 1;
          pActConnection := pConnectionBuffer;
        end_if;
        
        i := 0;
        while (pActConnection^.bInUse <> true) do
          // Search for next availabel connection
          pActConnection += sizeof(_CONNECTION);
          udCountActualCon += 1;
          if udCountActualCon > cMaxConnections$UDINT then
            pActConnection := pConnectionBuffer;
            dActConnections := 1;
          end_if;
          
          i += 1;
          // no connection available
          if i >= 16 then
            dActConnections := 0;
            FSMClient := _STATE_INIT;
          end_if;
        end_while;
        
        retval := co_MultiTask.SIGNAL(handle0:=SemaHandle1);
        
      else  // pActualConnection = NIL
        TRACE("Fatal Error");
        
//        retval := co_MultiTask.WAIT(handle0:=SemaHandle1); // deactivated by HubChr, v1.6
        
        pActConnection := pConnectionBuffer;
        
        // Search for available connection
        if pActConnection^.bInUse <> true then
          for i := 1 to cMaxConnections do
            pActConnection := pConnectionBuffer + (sizeof(_CONNECTION) * i);
            if pActConnection^.bInUse = true then
              exit;
            end_if;
          end_for;
          // When no connection is available go to Init state
          if pActConnection^.bInUse = false then
            dActConnections := 0;
            FSMClient := _STATE_INIT;
          end_if;
        end_if;
        
        retval := co_MultiTask.SIGNAL(handle0:=SemaHandle1);
        
      end_if;
      
  end_case;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::SendData
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
		dHandle 	: DINT;
		bDirect 	: BOOL;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
VAR
  BufferHeader    : _BUFFER_HEADER;
  dRet            : DINT;
  retval          : DINT;
END_VAR  

    dRetcode := TCP_CLT_SEND_FAILED;
    
    retval := co_MultiTask.WAIT(handle0:=SemaHandle1); // lock while copying data into local buffer
    if (CheckHandleValid(dHandle := dHandle) = false) then
      dRetcode := TCP_CLT_INVALID_HANDLE;
      retval := co_MultiTask.SIGNAL(handle0:=SemaHandle1);
      return;
    end_if;
    
    // copy connection informations to local buffer
    _memcpy(ptr1:=#LocalConnectionSending, ptr2:=dHandle$^_CONNECTION, cntr:=sizeof(_CONNECTION));
    retval := co_MultiTask.SIGNAL(handle0:=SemaHandle1);
    
    if (LocalConnectionSending.bConnected = false) then
      dRetcode := TCP_CLT_NOT_CONNECTED;
      return;
    end_if;

    if (bDirect = true) & (udSize <= 1452) then

      //#########################################################################################
      //### send data via OS function
      //#########################################################################################

      dRet := SendTCP(pConnection := #LocalConnectionSending,
                      pData := pData$^CHAR,
                      udSize := udSize,
                      udTimeout := 0
                      );

      if (dRet = udSize$DINT) then
        dRetcode := TCP_CLT_SEND_OK;
      end_if;
    elsif (bDirect = false) then

      //#########################################################################################
      //### put data into send buffer and send it in next cycle
      //#########################################################################################
      if ((LocalConnectionSending.RingbufferForSending.udSize - LocalConnectionSending.RingbufferForSending.udUsed) < (udSize + sizeof(_BUFFER_HEADER))) then 
        dRetcode := TCP_CLT_SEND_BUFFER_FULL;
        return;
      end_if;

      BufferHeader.DataSize := udSize;
      
      retval := co_MultiTask.WAIT(handle0:=SemaHandle1); // lock if send is called from a higher task
      
      // write data size into ringbuffer
      dRet := RingbufferWrite(pBuffer := #LocalConnectionSending.RingbufferForSending,
                              pData := #BufferHeader,
                              udSize := sizeof(_BUFFER_HEADER));

      if (dRet <> sizeof(_BUFFER_HEADER)) then
        retval := co_MultiTask.SIGNAL(handle0:=SemaHandle1);
        return;
      end_if;
      
      // write data into ringbuffer
      dRet := RingbufferWrite(pBuffer := #LocalConnectionSending.RingbufferForSending,
                              pData := pData,
                              udSize := BufferHeader.DataSize);      
      
      // copy local buffer back to connection structure
      if dHandle$^_CONNECTION^.bInUse = true then
      _memcpy(ptr1:=dHandle$^_CONNECTION, ptr2:=#LocalConnectionSending, cntr:=sizeof(_CONNECTION)); 
      end_if;
      
      retval := co_MultiTask.SIGNAL(handle0:=SemaHandle1);
      
      if (dRet = BufferHeader.DataSize$DINT) then
        dRetcode := TCP_CLT_SEND_OK;
      end_if;
    else
      dRetcode := TCP_CLT_DATA_TO_BIG_FOR_DIRECT_SENDING;
    end_if;
    
END_FUNCTION

FUNCTION _TCPIP_CLIENT::RingbufferRead
	VAR_INPUT
		pBuffer 	: ^_TX_RINGBUFFER;
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
VAR
	udBytes2End   : UDINT;
  udBytesTmp    : UDINT;
END_VAR

  dRetcode := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pBuffer^.pMem = NIL) then
    return; //### invalid pointer
  end_if;

  udBytes2End := (pBuffer^.pMem$UDINT + pBuffer^.udSize) - pBuffer^.pRead$UDINT;

  if (udSize > udBytes2End) then 

    //##########################################################################################
    //### we must read the data in 2 blocks (|second|...........other data...........|first|)
    //##########################################################################################
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udBytes2End); //### copy the first block
    pData += udBytes2End;
    pBuffer^.pRead := pBuffer^.pMem$^USINT;
    udBytesTmp := udSize - udBytes2End;
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udBytesTmp); //### copy the second block
    pBuffer^.pRead += udBytesTmp;

  else

    //##########################################################################################
    //### read data in one block
    //##########################################################################################
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udSize);
    pBuffer^.pRead += udSize;
  end_if;

  pBuffer^.udUsed -= udSize; // decrease the number of bytes in ringbuffer
  dRetcode := udSize$DINT;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::RingbufferWrite
VAR_INPUT
  pBuffer 	: ^_TX_RINGBUFFER;
  pData 	: ^void;
  udSize 	: UDINT;
END_VAR
VAR_OUTPUT
  dRetcode 	: DINT;
END_VAR
VAR
	udBytes2End   : UDINT;
  udBytesTmp    : UDINT;
END_VAR

  dRetcode := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pBuffer^.pMem = NIL) then
    return; //### invalid pointer
  end_if;

  if ((udSize) > (pBuffer^.udSize - pBuffer^.udUsed)) then
    return; //### buffer full
  end_if;

  udBytes2End := (pBuffer^.pMem$UDINT + pBuffer^.udSize) - pBuffer^.pWrite$UDINT; // calculate number of bytes till the end of SENDbuffer

  if (udSize > udBytes2End) then
    
    //##########################################################################################
    //### we must write the data in 2 blocks  (|second|...........other data...........|first|)
    //##########################################################################################
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udBytes2End); // copy the first block
    pData += udBytes2End;
    pBuffer^.pWrite := pBuffer^.pMem$^USINT;
    udBytesTmp := udSize - udBytes2End;
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udBytesTmp); // copy the second block
    pBuffer^.pWrite += udBytesTmp;
  else
    
    //##########################################################################################
    //### store data in one block
    //##########################################################################################
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udSize);
    pBuffer^.pWrite += udSize;
  end_if;
  
  pBuffer^.udUsed += udSize; // increase the number of bytes in ringbuffer
  dRetcode := udSize$DINT;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::FLUSHRingbuffer
	VAR_INPUT
		dHandle 	: DINT;
	END_VAR
VAR
	pBuffer   : ^_TX_RINGBUFFER;
END_VAR
  
  co_MultiTask.WAIT(handle0:=SemaHandle1);
  //*******************************************************
  if (CheckHandleValid(dHandle := dHandle) = true) then
    pBuffer := #dHandle$^_CONNECTION^.RingbufferForSending;
    pBuffer^.pRead := pBuffer^.pMem;
    pBuffer^.pWrite := pBuffer^.pMem;
    pBuffer^.udUsed := 0;
  end_if;
  //********************************************************
  co_MultiTask.SIGNAL(handle0:=SemaHandle1);
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::CyWork
VAR_INPUT
  EAX 	: UDINT;
END_VAR
VAR_OUTPUT
  state (EAX) 	: UDINT;
END_VAR
  
  CyclicCall();

	state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::IsConnected
	VAR_INPUT
		dHandle 	: DINT;
	END_VAR
	VAR_OUTPUT
		bRetcode 	: BOOL;
	END_VAR

  bRetcode := false;

  if (CheckHandleValid(dHandle := dHandle) = true) then
    bRetcode := dHandle$^_CONNECTION^.bConnected;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::CheckHandleValid
	VAR_INPUT
		dHandle 	: DINT;
	END_VAR
	VAR_OUTPUT
		bRetcode 	: BOOL;
	END_VAR
VAR
	i           : USINT;
  pConnection : ^_CONNECTION;
END_VAR

  bRetcode := false;

  if (dHandle = 0) then //### NIL pointer
    return;
  end_if;

  pConnection := pConnectionBuffer;

  i := 0;
  while i < cMaxConnections do
    if (pConnection = dHandle$^_CONNECTION) then
      bRetcode := true;
      exit;
    end_if;
    pConnection := pConnection + sizeof(_CONNECTION);
    i += 1;
  end_while;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::SendTCP
	VAR_INPUT
		pConnection 	: ^_CONNECTION;
		pData 	: ^CHAR;
		udSize 	: UDINT;
		udTimeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  
  dRetcode := OS_TCP_USER_SEND(pConnection^.dSocket,
                               pData,
                               udSize,
                               0, //### flags ... not used
                               udTimeout
                               );

  if (dRetcode = udSize$DINT) then
    pConnection^.udTimeStamp := ops.tAbsolute;
  else
    udSendError += 1;
    pConnection^.FSM_TCP := _STATE_SHUTDOWN;
  end_if;

END_FUNCTION
