//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES


// Eigenschaften des UDCs
//----------------------------------------------------------------------------------------------------------------------------
#define   AccessControlList_UDCVersion                1           // Version des aktuellen UDCs

#define   AccessControlList_VariableNo                6           // Anzahl der Variablen, die dem UDC mitgegeben werden
#define   AccessControlList_ImageAndTextNo            2           // Anzahl der Images und TextSchemes, die dem UDC mitgegeben werden

#define   AccessControlList_VarUserNameRoom           0           // Index 0
#define   AccessControlList_VarPasswordRoom           1           // Index 1
#define   AccessControlList_VarLevelRoom              2           // Index 2
#define   AccessControlList_VarTimeoutRoom            3           // Index 3
#define   AccessControlList_VarUSBSerNumRoom          4           // Index 4
#define   AccessControlList_VarInfoRoom               5           // Index 5


// Einstellungen zum Bestimmen der Texte aus LSE
//----------------------------------------------------------------------------------------------------------------------------
#define   AccessControlList_USBLinkedNo               0           // Text wenn der USB Stick nicht gelinkt ist
#define   AccessControlList_USBLinkedYes              1           // Text wenn der USB Stick gelinkt ist
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "AccessControlList"
	Revision           = "2.9"
	GUID               = "{9505AB2E-C41F-471A-BBFA-C0AE45895270}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,360)"
	Comment            = "This class is listing the users (ScrollList)&#13;&#10;Mode=0: administration all users (show all data) &#13;&#10;Mode=1: login data (show only user names)&#13;&#10;">
	<Channels>
		<Server Name="SelectFunction" GUID="{910F880F-BD1A-4637-A408-648C07AF54D2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Selects a function of the Class:&#13;&#10;1:  DeleteSelectedUser()&#13;&#10;2:  ModifySelectedUser()&#13;&#10;3:  ShowUserDataSelectedUser()&#13;&#10;4:  AddUsbSNSelectedUser()&#13;&#10;5:  DelUsbSNSelectedUser()"/>
		<Server Name="UpdateList" GUID="{1C407C1D-CEDF-4BDE-9B42-7C1A2EAC5F82}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="write() refreshes the list"/>
		<Server Name="UserUsbLinked" GUID="{D72DA4FB-7106-4B55-9E4B-CA45E0A42D4C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows if the user of the actual line is USB linked or not"/>
		<Server Name="Visible" GUID="{979D2115-0ADE-4FAE-8B55-2B64F035CF39}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Server (Marker) to set the list invisible or visible in LSE"/>
		<Client Name="coAccessControl" Required="true" Internal="false" Comment="object channel - Connect to AccessControlMain object"/>
		<Client Name="coSystemLogging" Required="false" Internal="false" Comment="Object channel to SystemLogging (optional)."/>
		<Client Name="Dummy" Required="true" Internal="true"/>
		<Client Name="Mode" Required="true" Internal="false" Comment="0...Use list for Usermanagement&#13;&#10;1...Use list to select Username for Login"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\AccessControlList\AccessControl.UDC"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="KruAle"/>
		<Dokumentation Revision="2.9" Date="2016-05-19" Author="GreJoh" Company="Sigmatek" Description="Get Text if USB Stick is linked or not from a textscheme from the UDC.&#13;&#10;Client coSystemLogging must not be connected."/>
		<Dokumentation Revision="2.8" Date="2016-05-11" Author="KaiAnd" Company="Sigmatek" Description="create a tmpAdmin (&quot;Admin&quot;/&quot;Admin&quot; with level 255) automatically if no user is configured"/>
		<Dokumentation Revision="2.7" Date="2016-05-xx" Author="GreJoh" Company="Sigmatek" Description="Overwrite IfRun() and added the server UserUsbLinked."/>
		<Dokumentation Revision="2.6&#13;&#10;" Date="2015-09-29" Author="BraLis" Company="Sigmatek" Description="insert the method SystemLogging::LogEventText instead of TRACE-Messages"/>
		<Dokumentation Revision="2.5" Date="2015-09-28" Author="KruAle" Company="Sigmatek" Description="get udc-data in IF_Start."/>
		<Dokumentation Revision="2.4" Date="2015-09-22" Company="Sigmatek" Description="Creation."/>
	</RevDoku>
	<Network Name="AccessControlList">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{9977A37A-76E1-432E-A867-1BB798F38617}"
				Class      = "_ScrollArea2"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="ActPos"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="ExtendedScrollBar" Value="0"/>
					<Client Name="LineHighness"/>
					<Client Name="LineWidth"/>
					<Client Name="Lse"/>
					<Client Name="VerticalLevel" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "Dummy"
				GUID       = "{F5EC8281-4317-4ED1-A70C-205EA8149617}"
				Class      = "String"
				Position   = "(270,480)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(998,210),(518,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.LineWidth" Destination="this.LineWidth" Vertices="(218,330),(38,270),"/>
			<Connection Source="this.Dummy" Destination="Dummy.Data"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _ScrollArea2

AccessControlList : CLASS
: _ScrollArea2
  //Servers:
	UpdateList 	: SvrCh_DINT;
	SelectFunction 	: SvrCh_DINT;
	Visible 	: SvrCh_DINT;
	UserUsbLinked 	: SvrCh_DINT;
  //Clients:
	Mode 	: CltCh_DINT;
	coAccessControl 	: CltChCmd_AccessControlMain;
	Dummy 	: CltChCmd_String;
	coSystemLogging 	: CltChCmd_SystemLogging;
  //Variables:
		bInitialized 	: BOOL;
		ScrollImage 	: _ANYTHING;
		aExtVisPara : ARRAY [0..AccessControlList_VariableNo-1] OF DINT;

		aVarSingle : ARRAY [0..AccessControlList_VariableNo-1] OF _VARSINGLE;

		USBLinkText 	: _ANYTHING;
		IsCon_coSystemLogging 	: BOOL;
		DeletedNbr 	: DINT;
		EditNbr 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to redraw the io&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;pr ........ pointer to result information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;
			pr 	: ^_RESULT;
			pv 	: ^_VARIABLE;
			input 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL InitScroll
		VAR_INPUT
			pio 	: ^_IO;
			vno 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when redraw of a single line is necessary.&#13;&#10;ps ..... --&gt; to structure _SCROLL&#13;&#10;pr ..... --&gt; to place where line should be drawn&#13;&#10;line ... number of line which should be drawn&#13;&#10;state .. line is selected (TRUE) or passive (FALSE)&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;
			pr 	: ^_ROOM;
			line 	: UINT;
			state 	: BOOL;
		END_VAR;
				//! <Function Comment="Get user data depending on the list position and delete them." Name="DeleteSelectedUser"/>
	FUNCTION GLOBAL DeleteSelectedUser;
				//! <Function Comment="Calls the method EditUser() of the class AccessControlMain." Name="EditSelectedUser"/>
	FUNCTION GLOBAL EditSelectedUser;
				//! <Function Comment="Get the userdata depending on the line position." Name="ShowUserDataSelectedUser"/>
	FUNCTION GLOBAL ShowUserDataSelectedUser;
				//! <Function Comment="Writes the username to the string for editing or login." Name="setUserName"/>
	FUNCTION setUserName
		VAR_INPUT
			User 	: AccessControlMain::t_s_User;			//! <Variable Comment="Struct with the user data." Name="setUserName.User"/>
		END_VAR;
				//! <Function Comment="Links the serial number of a plugged in usb-stick with the selected user." Name="AddUsbSNSelectedUser"/>
	FUNCTION GLOBAL AddUsbSNSelectedUser;
				//! <Function Comment="Deletes the usb link of the selected user." Name="DelUsbSNSelectedUser"/>
	FUNCTION GLOBAL DelUsbSNSelectedUser;
				//! <Function Comment="This method reads the data, which are delivered by the UDC, with the theurge pointer." Name="GetTheUrge"/>
	FUNCTION GetTheUrge
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="Pointer to the _IO information." Name="GetTheUrge.pio"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE..Ok&#13;&#10;FALSE..Error" Name="GetTheUrge.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Get values for the column width from servers if they were defined as server values in LSE." Name="GetTheUrgeValues"/>
	FUNCTION GetTheUrgeValues
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="Pointer to the _IO information." Name="GetTheUrgeValues.pio"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE..Ok&#13;&#10;FALSE..Error" Name="GetTheUrgeValues.bSuccessful"/>
		END_VAR;
	
	FUNCTION GLOBAL GetDeletedNbr
		VAR_INPUT
			SetToZero 	: DINT;
		END_VAR
		VAR_OUTPUT
			Pos 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetEditNbr
		VAR_INPUT
			SetToZero 	: DINT;
		END_VAR
		VAR_OUTPUT
			Pos 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateList::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SelectFunction::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd AccessControlMain
#pragma usingLtd SystemLogging


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AccessControlList::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_ACCESSCONTROLLIST
2$UINT, 9$UINT, (SIZEOF(::AccessControlList))$UINT, 
4$UINT, 4$UINT, 0$UINT, 
TO_UDINT(2532933484), "AccessControlList", //Class
TO_UDINT(2779823616), "_ScrollArea2", 0$UINT, 8$UINT, //Baseclass
//Servers:
(::AccessControlList.UpdateList.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3579543998), "UpdateList", 
(::AccessControlList.SelectFunction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2341012260), "SelectFunction", 
(::AccessControlList.Visible.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1173689923), "Visible", 
(::AccessControlList.UserUsbLinked.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2901458497), "UserUsbLinked", 
//Clients:
(::AccessControlList.Mode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2707401247), "Mode", 
(::AccessControlList.coAccessControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3559082873), "coAccessControl", TO_UDINT(1830373904), "AccessControlMain", 2$UINT, 17$UINT, 
(::AccessControlList.Dummy.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3097505935), "Dummy", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AccessControlList.coSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(292037947), "coSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_AccessControlList 23

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AccessControlList] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AccessControlList::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _ScrollArea2::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AccessControlList;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #InitScroll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	UpdateList.pMeth			:= StoreMethod( #M_RD_DIRECT(), #UpdateList::Write() );
	IF UpdateList.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SelectFunction.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SelectFunction::Write() );
	IF SelectFunction.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Visible.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Visible.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION GLOBAL __CDECL accesslist_line
  VAR_INPUT
    ps    : ^_SCROLL;  
    pt    : ^void;  
    pr    : ^_ROOM; 
    line  : UINT; 
    state : BOOL; 
  END_VAR

  pt$^_ScrollArea^.Line(ps, pr, line, state); 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AccessControlList::Init

  if _FirstScan then
  
    //-----------------------------------------------------------------------------------------
    //  check client-connnections and set flags                   GreJoh
    //-----------------------------------------------------------------------------------------    
    if IsClientConnected(#coSystemLogging) then
      IsCon_coSystemLogging := TRUE;
    else 
      IsCon_coSystemLogging := FALSE;
    end_if;  
  
    coAccessControl.RegisterAccessList(pNewAccessList:=this);
    
  end_if;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AccessControlList::Line
	VAR_INPUT
		ps 	: ^_SCROLL;
		pr 	: ^_ROOM;
		line 	: UINT;
		state 	: BOOL;
	END_VAR
  VAR
    txt         : ARRAY [0..300] of _ASCII; 
    tmpActUser  : AccessControlMain::t_s_User;
    color       : _COLOR; 
    att         : _ATTRIB; 
    tmpX        : INT;
    tmpY        : INT;
    tmpYDiff    : INT;
    tmpRoomDiff : INT;
    tmpHeight   : INT;
    tmpWidth    : INT;
    pString     : ^_CHAR;
  END_VAR
  
  // UDC-Parameter geholt?
  if bInitialized then

    tmpX        := pr^.xy1.x + 5;
    tmpY        := pr^.xy1.y;
    tmpRoomDiff := pr^.xy2.x - pr^.xy1.x;
    att         := T_LEFTBOUND or T_UPBOUND or T_COPY or T_SOLID or T_PROP; 

    // Größe des eingestellten Font ermitteln
    font_size(ps^.font, (#tmpWidth)$^UINT, (#tmpHeight)$^UINT);
    
    tmpYDiff := (pr^.xy2.y - pr^.xy1.y) / 2 + pr^.xy1.y - tmpHeight / 2;
      
    // Gültige Zeile und gültige Benutzerdaten
    if(line < ps^.position.no) & (coAccessControl.getUserDataByNr(udUserNr:=line, #tmpActUser) = 0) then
      
      if(state = TRUE) then
        // Ausgewählte Zeile gleich in entsprechendes Stringfeld schreiben
        if Mode = 1 then
          setUserName(User:=tmpActUser);
        end_if;
        color := Graphic.MakeColor(INVISIBLE, ps^.color_activ); 
      else
        color := Graphic.MakeColor(INVISIBLE, ps^.color_inactiv); 
      end_if; 


      // Benutzername immer zeichnen
      if aExtVisPara[AccessControlList_VarUserNameRoom] > 0 then    
        StrCpy(#txt[0], sizeof(_ASCII), #tmpActUser.aUsername[0], sizeof(_ASCII));
        Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
        tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarUserNameRoom]) / 100;
      end_if;
      
      // Nur bei der Benutzerverwaltung alles zeichnen
      //-----------------------------------------------------------------------------------------
      if Mode = 0 then
              
        if aExtVisPara[AccessControlList_VarPasswordRoom] > 0 then
          StrCpy(#txt[0], sizeof(_ASCII), "******", sizeof(_ASCII));
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
          tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarPasswordRoom]) / 100;
        end_if;
        
        if aExtVisPara[AccessControlList_VarLevelRoom] > 0 then
          DToA(#txt[0], tmpActUser.usUserLevel, 0x0000, sizeof(_ASCII));
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
          tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarLevelRoom]) / 100;
        end_if;
        
        if aExtVisPara[AccessControlList_VarTimeoutRoom] > 0 then
          DToA(#txt[0], TO_DINT(tmpActUser.udUserTimeout), 0x0000, sizeof(_ASCII));
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
          tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarTimeoutRoom]) / 100;
        end_if;

        if aExtVisPara[AccessControlList_VarUSBSerNumRoom] > 0 then 
          if _strlen(#tmpActUser.USBSerial[0]) then
          
            pString$^void := NewDoScheme( x0  := USBLinkText.list, 
                                          x1  := AccessControlList_USBLinkedYes, 
                                          x2  := USBLinkText.no);
                                          
            StrCpy(#txt[0], sizeof(_UNI), pString, sizeof(_UNI));
            
          else
          
            pString$^void := NewDoScheme( x0  := USBLinkText.list, 
                                          x1  := AccessControlList_USBLinkedNo, 
                                          x2  := USBLinkText.no);
                                          
            StrCpy(#txt[0], sizeof(_UNI), pString, sizeof(_UNI));
            
          end_if;
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_UNI));
          tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarUSBSerNumRoom]) / 100;
        end_if;

        if aExtVisPara[AccessControlList_VarInfoRoom] > 0 then
          StrCpy(#txt[0], sizeof(_ASCII), #tmpActUser.aUserInfo[0], sizeof(_ASCII));
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
          tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarInfoRoom]) / 100;
        end_if;
        
      end_if;
    end_if;
    
    
    // Spalten nur bei der Benutzerverwaltung zeichnen
    //-----------------------------------------------------------------------------------------
    if Mode = 0 then
    
      tmpX := pr^.xy1.x;
    
      if aExtVisPara[AccessControlList_VarUserNameRoom] > 0 then
        tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarUserNameRoom]) / 100;
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      if aExtVisPara[AccessControlList_VarPasswordRoom] > 0 then
        tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarPasswordRoom]) / 100;
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      if aExtVisPara[AccessControlList_VarLevelRoom] > 0 then
        tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarLevelRoom]) / 100;
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      if aExtVisPara[AccessControlList_VarTimeoutRoom] > 0 then
        tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarTimeoutRoom]) / 100;
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      if aExtVisPara[AccessControlList_VarUSBSerNumRoom] > 0 then
        tmpX += tmpRoomDiff * TO_INT(aExtVisPara[AccessControlList_VarUSBSerNumRoom]) / 100;
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      // Rahmen erneut zeichnen
      DrawButton(#ps^.out_room, T_FILL or T_COPY or T_SOLID, ps^.frametype, INVISIBLE, ps^.frame_out);
      
    end_if;      

  end_if;
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AccessControlList::Draw
	VAR_INPUT
		pio 	: ^_IO;
		pr 	: ^_RESULT;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  
  if bInitialized then
    
    GetTheUrgeValues(pio:=pio);
    
    // ScrollListe initialisieren
    InitScroll(pio:=pio, vno:=TO_UINT(coAccessControl.getNumberOfUsers()));
    
    retcode := _ScrollArea2::Draw(pio, pr, pv, input);
    
  else
    retcode := _IFAILED;
  end_if;
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AccessControlList::InitScroll
	VAR_INPUT
		pio 	: ^_IO;
		vno 	: UINT;
	END_VAR
VAR
  tmpX  : UINT; 
  tmpY  : UINT; 
	hno   : DINT; 
	hzl   : BOOL; 
	tmpColor : _COLOR; 
   #ifdef LEFT_RIGHT_SELECTION
    sb_iswo : dint; 
   #endif
END_VAR 

  font_size(pio^.font, #tmpX, #tmpY); 
  tmpY := LineHeight(tmpY);

  Scroll.attrib_inactiv    := pio^.attrib; 
  Scroll.attrib_activ      := pio^.attrib; 
  Scroll.out_room          := pio^.space; 
  Scroll.scroll_room       := pio^.space;
  Scroll.font              := pio^.font; 
  Scroll.color_inactiv     := Graphic.MakeColor(GetPenColor(pio^.colback), GetPenColor(pio^.coltxt));
  Scroll.color_activ       := Graphic.MakeColor(GetEditColorBack(_EDITACTIVE), GetEditColorTxt(_EDITACTIVE));
  Scroll.frame_out         := pio^.colframe;
  Scroll.frame_scroll      := pio^.colframe;
  tmpColor := GetBackColor(Scroll.color_inactiv); 
  Scroll.level.color       := Graphic.MakeColor(tmpColor, tmpColor); 
  Scroll.level.frame_color := pio^.colframe;
  if (ExtendedScrollBar.Read() = 1) then
    Scroll.level.pguppgdown  := true;
  end_if;
  Scroll.hlevel.color       := Scroll.level.color; 
  Scroll.hlevel.frame_color := pio^.colframe;
  Scroll.line_height        := tmpY;
  Scroll.frametype          := pio^.frametype;

  Scroll.scroll_room.xy1.x += 1; 
  Scroll.scroll_room.xy1.y += 1; 
  Scroll.scroll_room.xy2.x -= 1; 
  Scroll.scroll_room.xy2.y -= 1; 

  Scroll.position.no  := vno; 

  Scroll.level.active := FALSE;

 #ifdef LEFT_RIGHT_SELECTION
  sb_iswo := VerticalLevel.Read(); 
  if(sb_iswo = 1) then
    // scrollbalken rechts
    Scroll.scroll_room.xy2.x -= LEVELBUTTON_WIDTH; 
    Scroll.level.room.xy1.x  := Scroll.scroll_room.xy2.x+1; 
    Scroll.level.room.xy2.x  := Scroll.out_room.xy2.x;
    Scroll.level.room.xy1.y  := Scroll.out_room.xy1.y; 
    Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
    Scroll.level.active      := TRUE; 
  elsif(sb_iswo = 2) then
    //scrollbalken links
    Scroll.scroll_room.xy1.x += LEVELBUTTON_WIDTH; 
    Scroll.level.room.xy1.x  := Scroll.out_room.xy1.x + 1;  
    Scroll.level.room.xy2.x  := Scroll.out_room.xy1.x + LEVELBUTTON_WIDTH;
    Scroll.level.room.xy1.y  := Scroll.out_room.xy1.y; 
    Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
    Scroll.level.active      := TRUE; 
  end_if; 
 #else
  if(VerticalLevel.Read() = TRUE) then
    Scroll.scroll_room.xy2.x -= LEVELBUTTON_WIDTH; 
    Scroll.level.room.xy1.x  := Scroll.scroll_room.xy2.x+1; 
    Scroll.level.room.xy1.y  := Scroll.out_room.xy1.y; 
    Scroll.level.room.xy2.x  := Scroll.out_room.xy2.x;
    Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
    Scroll.level.active      := TRUE; 
  end_if; 
 #endif

  Scroll.line_width := to_uint(Scroll.scroll_room.xy2.x - Scroll.scroll_room.xy1.x + 1);


  // neuer code
  hno := LineWidth.Read();
  if(hno < Scroll.line_width) then
    hzl := FALSE;
    Scroll.hposition.no := 0; 
  else
    hzl := TRUE; 
	  Scroll.hposition.no := hno - Scroll.line_width; 
  end_if; 	 


  if(hzl = TRUE) then
    Scroll.level.room.xy2.y  -= (LEVELBUTTON_HEIGHT + 1); 
    Scroll.scroll_room.xy2.y -= (LEVELBUTTON_HEIGHT + 1);
    Scroll.hlevel.room.xy1.x := Scroll.out_room.xy1.x;  
    Scroll.hlevel.room.xy1.y := Scroll.scroll_room.xy2.y + 1;  
    Scroll.hlevel.room.xy2.x := Scroll.out_room.xy2.x;  
    Scroll.hlevel.room.xy2.y := Scroll.out_room.xy2.y;  
    if(Scroll.level.active = TRUE) then
     #ifdef LEFT_RIGHT_SELECTION
	  if(sb_iswo = 1) then
	    // scrollbalken ist rechts
        Scroll.hlevel.room.xy2.x -= LEVELBUTTON_WIDTH; 
	  elsif(sb_iswo = 2) then
	    // scrollbalken ist links
        Scroll.hlevel.room.xy1.x += LEVELBUTTON_WIDTH-1;
	    Scroll.hlevel.room.xy2.x -= 1; 
      end_if; 
     #else
      Scroll.hlevel.room.xy2.x -= LEVELBUTTON_WIDTH; 
     #endif 
    end_if; 
    Scroll.hlevel.active     := TRUE;  
    Scroll.hposition.height  := 1; //to_uint((Scroll.scroll_room.xy2.x - Scroll.scroll_room.xy1.x) / 4);  
  elsif (Scroll.hlevel.active = TRUE) then
  	Scroll.scroll_room.xy2.y := pio^.space.xy2.y - 1;
	  Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
	  Scroll.hlevel.active     := FALSE;
  end_if; 
  
  Scroll.position.height := to_uint((Scroll.scroll_room.xy2.y - Scroll.scroll_room.xy1.y + 1) / tmpY);
  if(Scroll.position.height < 1) then 
    Scroll.position.height := 1; 
  end_if; 

  if(Scroll.level.active = TRUE) then
    Scroll.hlevel.room.xy2.x += 1; 
  end_if; 

  Scroll.line_height += to_uint((Scroll.scroll_room.xy2.y - Scroll.scroll_room.xy1.y + 1 - Scroll.position.height * Scroll.line_height) / Scroll.position.height); 

  // wenn "eigentlich nicht mehr sichtbare Zeile" selektiert ist bzw. selektierte Zeile nicht mehr existiert
  if Scroll.position.pos >= Scroll.position.no then
    Scroll.position.pos := Scroll.position.no - 1;
  end_if;
  if Scroll.position.begin > (Scroll.position.no - Scroll.position.height) then
    if (Scroll.position.no - Scroll.position.height) < 1 then
      Scroll.position.begin := 0;
    else
      Scroll.position.begin := (Scroll.position.no - Scroll.position.height) - 1;
    end_if;
  end_if;

  // Bild von der Visu als Scrollbutton angeben
  Scroll.image := (get_Anything(#ScrollImage, NIL))$^_BMP;
  
  Scroll.pt      := this;  
  Scroll.pt_line := #accesslist_line(); // to userdefined linedraw-interface
  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AccessControlList::UpdateList::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	UpdateList := input;
  
  Refresh.Write(input:=1);
  
 	result := UpdateList;
  UpdateList := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AccessControlList::SelectFunction::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	SelectFunction := input;
  
  //*****************************************************************************
  //** Ausgewählte Funktion                                                    **
  //*****************************************************************************
  case SelectFunction of
    
    // Ausgewählten Benutzer löschen
    1:  DeleteSelectedUser();
    
    // Ausgewählten Benutzer bearbeiten
    2:  EditSelectedUser();
    
    // Daten des ausgewählten Benutzers anzeigen
    3:  ShowUserDataSelectedUser();
    
    // Verknüpft die Seriennummer des aktuellen Speichermediums mit dem eingeloggten Benutzer
    4:  AddUsbSNSelectedUser();
    
    // Löscht die Verknüpfung der Seriennummer mit dem aktuellen Speichermedium
    5:  DelUsbSNSelectedUser();
  
  end_case;
  
 	result := SelectFunction;
  SelectFunction := 0;

END_FUNCTION


FUNCTION GLOBAL AccessControlList::DeleteSelectedUser
  VAR
    tmpUser : AccessControlMain::t_s_User;
  END_VAR
  
  // Benutzerdaten anhand der Zeilenposition holen und löschen
  //-----------------------------------------------------------------------------------------
  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
    setUserName(User:=tmpUser);
    coAccessControl.DeleteUser();
    DeletedNbr := Scroll.position.pos;
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlList::EditSelectedUser
  
  // Methode der Manager-Klasse aufrufen
  coAccessControl.EditUser();
  EditNbr := Scroll.position.pos;

END_FUNCTION


FUNCTION GLOBAL AccessControlList::ShowUserDataSelectedUser
  VAR
    tmpUser : AccessControlMain::t_s_User;
  END_VAR

  // Benutzerdaten anhand der Zeilenposition holen
  //-----------------------------------------------------------------------------------------
  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
    setUserName(User:=tmpUser);
    coAccessControl.ShowUserData();
  end_if;

END_FUNCTION


FUNCTION AccessControlList::setUserName
	VAR_INPUT
		User 	: AccessControlMain::t_s_User;
	END_VAR
  
  // Benutzername in den String zum Editieren oder zum Anmelden schreiben
  //-----------------------------------------------------------------------------------------
  if Mode = 0 then
  
    coAccessControl.StrEditUserName.WriteDataOff(udLen:=StrLen(txt:=#User.aUsername[0], size:=sizeof(_ASCII)), udOff:=0, pData:=#User.aUsername[0]);
  
  elsif Mode = 1 then
  
    coAccessControl.StrLoginUserName.WriteDataOff(udLen:=StrLen(txt:=#User.aUsername[0], size:=sizeof(_ASCII)), udOff:=0, pData:=#User.aUsername[0]);
  
  end_if;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AccessControlList::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  VAR
    tmpUser : AccessControlMain::t_s_User;
  END_VAR

  // Methoder der Basis-Klasse aufrufen
  retcode :=_ScrollArea::GetEvent(ped, pe);
  
  if (Focus = TRUE) then
    
    //***************************************************************************** 
    //** Schrittschaltwerk für das Event in der Login-Help Scroll-Liste          **
    //***************************************************************************** 
    case (pe^.ftype) of
	    
      //***************************************************************************** 
		  _EVENT_HIDPRESS: 
                
                // Touch-Event im Bereich der Scroll-Liste
                if ((pe^.dot.x >= Scroll.out_room.xy1.x) & (pe^.dot.x <= Scroll.out_room.xy2.x) &
                    (pe^.dot.y >= Scroll.out_room.xy1.y) & (pe^.dot.y <= Scroll.out_room.xy2.y)) then
                  
                  // Benutzerdaten anhand der Position holen
                  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
                    setUserName(User:=tmpUser);
                  else 
                    tmpUser.aUsername[0] := 0;
                    setUserName(tmpUser);
                  end_if;
                  
                end_if;
                
      
      //***************************************************************************** 
      _EVENT_HIDRELEASE:
                
                // Benutzerdaten anhand der Position holen
                if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
                  setUserName(User:=tmpUser);
                else
                  tmpUser.aUsername[0] := 0;
                  setUserName(tmpUser);
                end_if;

    end_case; 
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlList::AddUsbSNSelectedUser
  VAR
    tmpUser : AccessControlMain::t_s_User;
  END_VAR
  
  // Benutzerdaten anhand der Position holen
  //-----------------------------------------------------------------------------------------
  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
    setUserName(User:=tmpUser);
    coAccessControl.AddUsbSN();
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlList::DelUsbSNSelectedUser
VAR
	tmpUser : AccessControlMain::t_s_User;
END_VAR
  
  // Benutzerdaten anhand der Position holen
  //-----------------------------------------------------------------------------------------
  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
    setUserName(User:=tmpUser);
    coAccessControl.DelUsbSN();
  end_if;
  
END_FUNCTION



FUNCTION AccessControlList::GetTheUrge
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
	  pVarLabel       : ^_VARLABEL;
    tmpCounter      : USINT;
    pHelpAnyThing   : ^_ANYTHING;
  END_VAR
  
  tmpCounter  := 0;
  bSuccessful := true;
  
  // Zeiger auf die Daten aus der Visu gültig?
  if (pio <> NIL) & (pio^.theurge <> NIL) then
    
    // Richtige Version des UDCs?
    if (pio^.theurge^.info = AccessControlList_UDCVersion) then

      // Variablen-Informationen
      //--------------------------------------------------------------
      // check number of variables
      if pio^.theurge^.memvarlabel.no = AccessControlList_VariableNo then
        
        // pointer to variable informations
        pVarLabel := pio^.theurge^.memvarlabel.ptr;
        
        // loop to store all parameter
        for tmpCounter := 0 to sizeof(aVarSingle) / sizeof(aVarSingle[0]) - 1 do
        
          // save variable informations
          aVarSingle[tmpCounter] := pVarLabel^.info[0];
          
          // check for constant
          if aVarSingle[tmpCounter].state = CONST_VAL then
            aExtVisPara[tmpCounter] := aVarSingle[tmpCounter].value;
          end_if;

          // step to next variable
          pVarLabel += sizeof(_VARLABEL);
          
        end_for;

      else
        bSuccessful := false;
      end_if;
      
      
      // Scroll-Bild holen
      //-----------------------------------------------------------------------------------------
      if (pio^.theurge^.memanything.no = AccessControlList_ImageAndTextNo) then
        
        pHelpAnyThing := pio^.theurge^.memanything.ptr;

        ScrollImage.list := pHelpAnyThing^.list;
        ScrollImage.no   := pHelpAnyThing^.no;
        
        // Textschema holen
        //-----------------------------------------------------------------------------------------
        pHelpAnyThing += sizeof(_ANYTHING);
        
        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          USBLinkText.list := pHelpAnyThing^.list;
          USBLinkText.no   := pHelpAnyThing^.no;
        else
          USBLinkText.list := DEFLST;
          USBLinkText.no   := DEFSCOPE;
          if IsCon_coSystemLogging = TRUE then
            coSystemLogging.LogEventText("EventJournal::GetTheUrge(): Verweis auf Textliste konnte nicht bestimmt werden");
          end_if;
        end_if;
      
      else
        bSuccessful := false;
      end_if;
    
    else
      bSuccessful := false;
      if IsCon_coSystemLogging = TRUE then
        coSystemLogging.LogEventText("AccessControlList::GetTheUrge(): Falsche Version des UDCs");
      end_if;
    end_if;

  else
    bSuccessful := false;
    if IsCon_coSystemLogging = TRUE then
      coSystemLogging.LogEventText("AccessControlList::GetTheUrge(): Ungültiger Übergabeparameter");
    end_if;
  end_if;

END_FUNCTION


FUNCTION AccessControlList::GetTheUrgeValues
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpCounter  : USINT;
    tmpResult   : _RESULT;
    tmpVariable : _VARIABLE;
    tmpVarLabel : _VARLABEL;
  END_VAR
  
  bSuccessful := true;
  
  // loop to check all variables
  for tmpCounter := 0 to sizeof(aVarSingle) / sizeof(aVarSingle[0]) - 1 do
  
    // check if variable is a dataserver
    if aVarSingle[tmpCounter].state = VAR_VAL then
      
      // build varlabel
      tmpVarLabel.no      := 1;
      tmpVarLabel.info[0] := aVarSingle[tmpCounter];
    
      // get server-value
      if VarList_GetSystemData( p0  := #tmpResult, 
                                p1  := #tmpVariable, 
                                p2  := #tmpVarLabel, 
                                x3  := false) = true then
        
        // save the new value + change checksum
        aExtVisPara[tmpCounter] := tmpResult.value;
      
      else
        bSuccessful := false;
      end_if;

    end_if;

  end_for;  
    
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AccessControlList::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  VAR
	  myNumUsers : UDINT;
  END_VAR
  
  bInitialized := GetTheUrge(pio:=pio);

  // Methode der Basis-Klasse
  _ScrollArea2::IF_Start(pio, firsttime);


  //-----------------------------------------------------------------------------------------------
  // Admin-User temporär anlegen, solange keine echten User angelegt sind               KaiAnd
  //-----------------------------------------------------------------------------------------------
  myNumUsers := coAccessControl.getNumberOfUsers();
  if (myNumUsers <= 0) then
    coAccessControl.CreateAdmin(pUsername:="Admin", pPassword:="Admin", usLevel:=255);
  end_if;
  //-----------------------------------------------------------------------------------------------


END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AccessControlList::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR
  VAR
  	tmpActUser  : AccessControlMain::t_s_User;
  END_VAR

  coAccessControl.getUserDataByNr(udUserNr:=to_UDINT(ActPos), #tmpActUser);

  if aExtVisPara[AccessControlList_VarUSBSerNumRoom] > 0 then 
    if _strlen(#tmpActUser.USBSerial[0]) then
      UserUsbLinked := 1;
    else
      UserUsbLinked := 0;
    end_if;
  end_if;    

  // Methode der Basisklasse aufrufen
  _ScrollArea2::IF_Run(pio, input);

END_FUNCTION


FUNCTION GLOBAL AccessControlList::GetDeletedNbr
	VAR_INPUT
		SetToZero 	: DINT;
	END_VAR
	VAR_OUTPUT
		Pos 	: DINT;
	END_VAR
  
  if SetToZero = 1 then
    DeletedNbr := -1;
  else
    Pos := DeletedNbr;
  end_if;

END_FUNCTION


FUNCTION GLOBAL AccessControlList::GetEditNbr
	VAR_INPUT
		SetToZero 	: DINT;
	END_VAR
	VAR_OUTPUT
		Pos 	: DINT;
	END_VAR
  
  if SetToZero = 1 then
    EditNbr := -1;
  else
    Pos := EditNbr;
  end_if;

END_FUNCTION
