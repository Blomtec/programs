//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "LslRemote"
	Revision           = "1.2"
	GUID               = "{B4A14911-B080-4C46-9CF1-CE31D8AB5481}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "true"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\LslRemote\LRM.ico"
	SharedCommandTable = "true"
	Objectsize         = "(450,480)"
	Comment            = "Interface class for the remote manager: Set Cyclic time to 1s and background time to the save value as _LSE has!">
	<Channels>
		<Server Name="OfflineReason" GUID="{39E50CF4-F8D1-4B1B-867E-DC1FF0F17250}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0..Logout, 1..not allowed, 2..Timeout, 3..wrong password"/>
		<Server
			Name           = "RemoteOnline"
			GUID           = "{7AA0F33B-C824-4148-BEF5-220B201797E0}"
			Visualized     = "true"
			Initialize     = "false"
			WriteProtected = "true"
			Retentive      = "false"
			Comment        = "0..offline, 1..online">
			<NewInst>
				<Function Name="LOGIN">
				</Function>
				<Function Name="LOGOUT">
				</Function>
				<Function Name="SendMsg">
				</Function>
				<Function Name="SetServer">
				</Function>
				<Function Name="IamAlive">
				</Function>
				<Function Name="QueueState">
				</Function>
				<Function Name="GetLastError">
				</Function>
				<Function Name="AddMsg">
				</Function>
				<Function Name="AddServer">
				</Function>
			</NewInst>
		</Server>
		<Client Name="ChangeServers" Required="false" Internal="false" Comment="1..RemoteManager may change servers, 0.. may not"/>
		<Client Name="ImageNumber" Required="true" Internal="false" Comment="ImageNumber of message screen"/>
		<Client Name="IsAllowed" Required="false" Internal="false" Comment="0..remote login not allowed, 1..allowed"/>
		<Client Name="LoginLevel" Required="true" Internal="false" Comment="connect to a ram cell"/>
		<Client Name="Message" Required="true" Internal="false" Comment="Message string for ImageNumber (must be placed on the according screen)"/>
		<Client Name="RemotePassword" Required="true" Internal="false" Comment="Connect to a string class"/>
		<Client Name="To_LSE" Required="true" Internal="false" Comment="Connect to _LSE"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Lsl_st_ifssr.h" Include="false"/>
		</Files>
	</Dependencies>
</Class>
*)
LslRemote : CLASS
	TYPE
	  CmdRemoteOnline :  //! <Type Public="true" Name="CmdRemoteOnline"/>
	  (
	    LOGIN,
	    LOGOUT,
	    SendMsg,
	    SetServer,
	    IamAlive,
	    QueueState,
	    GetLastError,
	    AddMsg,
	    AddServer
	  )$UINT;
#pragma pack(push, 1)
	  s_Error : STRUCT
	    actionID : USINT;
	    pobj : ^void;
	    reason : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  s_SetMessage : STRUCT
	    typ : USINT;
	    len : UDINT;
	    data : ^void;
	  END_STRUCT;
#pragma pack(push, 1)
	  s_SetServer : STRUCT
	    TID : INT;
	    SID : USINT;
	    typ : USINT;
	    servername : ^void;
	    sn_complete : BOOL;
	    data : ^void;
	    len : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	RemoteOnline 	: SvrChCmd_DINT;
	OfflineReason 	: SvrCh_DINT;
  //Clients:
	To_LSE 	: CltChCmd__Lse;
	ImageNumber 	: CltCh_DINT;
	Message 	: CltChCmd_StringInternal;
	IsAllowed 	: CltCh_DINT;
	RemotePassword 	: CltChCmd_StringInternal;
	LoginLevel 	: CltCh_DINT;
	ChangeServers 	: CltCh_DINT;
  //Variables:
		ud_deadtime 	: UDINT;
		a_serverqueue : ARRAY [0..255] OF s_SetServer;

		a_messagequeue : ARRAY [0..255] OF s_SetMessage;

		a_errorqueue : ARRAY [0..255] OF s_Error;

		us_serverqueueentries 	: USINT;
		us_messagequeueentries 	: USINT;
		us_errorqueueentries 	: USINT;
		us_messagequeue_sema 	: USINT;
		us_serverqueue_sema 	: USINT;
		di_localloginlevel 	: DINT;
		di_remoteloginlevel 	: DINT;
		ud_access 	: UDINT;
		message0 	: s_SetMessage;
		server0 	: s_SetServer;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10; CyWork will trigger the Logout upon a timeout event&#13;&#10; [Globals]&#13;&#10; [Members] (s) OfflineReason :W  :tell the local user that a timeout occured&#13;&#10;    (s) RemoteOnline :R  :check if we are remote online &#13;&#10;     ud_deadtime  :R/W :deadtime counter&#13;&#10;    (c) LoginLevel  :W  :current login level&#13;&#10; [Locals]&#13;&#10;[&lt;EAX]&#13;&#10;[&gt;state]&#13;&#10;" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; Background will process the queues&#13;&#10; [Globals]&#13;&#10; [Members] us_serverqueueentries :R/W :process the server queue&#13;&#10;    us_serverqueue_sema  :W&#13;&#10;    a_serverqueue   :R&#13;&#10;    us_messagequeueentries :R/W :process the message queue&#13;&#10;    us_messagequeue_sema :W&#13;&#10;    a_messagequeue   :R&#13;&#10;    us_errorqueueentries :R/W :process the error queue&#13;&#10;    a_errorqueue   :W&#13;&#10; [Locals]&#13;&#10;    i      :R/W :counter&#13;&#10;    result     :R/W :temporary result storage &#13;&#10;    vl0      :R/W :SetSystemData variable&#13;&#10;    va      :R/W :SetSystemData variable&#13;&#10;    res      :R/W SetSystemData result    &#13;&#10;[&lt;EAX]&#13;&#10;[&gt;state]&#13;&#10;" Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LoginRemote
		VAR_INPUT
			pPwd 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			dLevel 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LogoutRemote
		VAR_INPUT
			dOfflineReason 	: DINT;
		END_VAR;
				//! <Function Comment="################################################################################&#13;&#10; methods&#13;&#10;################################################################################&#13;&#10;[#ENGLISH]&#13;&#10; Calls to this function are triggered by the RemoteManager.&#13;&#10; This is the main communication routine.&#13;&#10; [Globals]&#13;&#10; [Members] (c) IsAllowed  :R  :allow remote login (read from application)&#13;&#10;    (c) MaxLoginLevel :R  :maximum allowed login level (read from application)&#13;&#10;    (c) LoginLevel  :R/W :current login level (read from application)&#13;&#10;    (s) RemoteOnline :W  :show online state&#13;&#10;    (s) OfflineReason :W  :why are we offline&#13;&#10;     ud_deadtime  :W  :reset deadtime counter&#13;&#10;     ud_access  :W  :acces privilegs (t.b.d)&#13;&#10;     a_serverqueue :W  :queue for setver set commands&#13;&#10;     a_messagequeue :W  :queue for message commands&#13;&#10;     a_errorqueue :R  :queue for error messages&#13;&#10;   us_serverqueueentries :R/W :entries in the server queue&#13;&#10;   us_messagequeueentries :R/W :entries in the message queue&#13;&#10;   us_errorqueueentries :R/W :entries in the error queue&#13;&#10;   us_messagequeue_sema :R  :semaphor for message queue access&#13;&#10;   us_serverqueue_sema  :R  :semaphor for server queue access&#13;&#10;     message0  :R/W :current message&#13;&#10;     server0   :R/W :current server&#13;&#10; [Locals]  lpwd    :R/W :temporary password  &#13;&#10;    result    :R/W :temporary result storage&#13;&#10;    ud_foffs   :R/W :offset in message structure&#13;&#10;    ud_lsize   :R/W :offset in server structure     &#13;&#10;[&lt;pPara] Parameters for this call&#13;&#10;[&lt;Results] Pointer to the result structure]&#13;&#10;[&gt;ret_code]&#13;&#10;" Name="RemoteOnline.NewInst"/>
	FUNCTION VIRTUAL GLOBAL RemoteOnline::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Lse
#pragma usingLtd StringInternal


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB LslRemote::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_LSLREMOTE
1$UINT, 2$UINT, (SIZEOF(::LslRemote))$UINT, 
2$UINT, 7$UINT, 0$UINT, 
TO_UDINT(2636191234), "LslRemote", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::LslRemote.RemoteOnline.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2125629626), "RemoteOnline", 
(::LslRemote.OfflineReason.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3527144954), "OfflineReason", 
//Clients:
(::LslRemote.To_LSE.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2175857666), "To_LSE", TO_UDINT(1552551876), "_Lse", 0$UINT, 110$UINT, 
(::LslRemote.ImageNumber.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2263803273), "ImageNumber", 
(::LslRemote.Message.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2314784357), "Message", TO_UDINT(2898603620), "StringInternal", 1$UINT, 81$UINT, 
(::LslRemote.IsAllowed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(508500690), "IsAllowed", 
(::LslRemote.RemotePassword.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3995691762), "RemotePassword", TO_UDINT(2898603620), "StringInternal", 1$UINT, 81$UINT, 
(::LslRemote.LoginLevel.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(170011250), "LoginLevel", 
(::LslRemote.ChangeServers.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2563046657), "ChangeServers", 
END_FUNCTION


#define USER_CNT_LslRemote 3

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_LslRemote] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION LslRemote::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_LslRemote, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #LoginRemote();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #LogoutRemote();

#pragma warning (default : 74)
	RemoteOnline.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF RemoteOnline.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\LslRemote\LslRemote_00_00.st*********************



 



(**********************************************************************************
*
*	Class for RemoteManager communication
*	Created : Sigmatek / 2005
*			
*	Always set the object name to "LslRemote0" to ensure correct communication with
*	the RemoteManager.
*	Furthermore, it is favourable to set the cyclic time to 1000 ms (this causes the 
*	AutoLogOff constant to represent full seconds) and the background cycle to the 
*	same time as the _LSE object has.
*
*	Changes	:	
*
*			1.1 => 1.2 / 24.10.2006 / Mark: //ws002
*			  application request: construct a generally usable base class, which is 
*			  to be derived by application engineers to adopt to customer needs
*			1.0 => 1.1 / 24.03.2006 / Mark: //ws001
*			  activate res.remotedata
*			  removed dependency of T_types.h
*           0.0 => 1.0 / 31.08.2005 / no Mark: ws
*             initial creation
*
**********************************************************************************)


//################################################################################
//	defines
//################################################################################

#define LSLREMOTE_AUTOLOGOFF 16#05 //wait <n> cycles/seconds before going offline
#define LSLREMOTE_OFFLINE	 16#00
#define LSLREMOTE_ONLINE	 16#01
#define LSLREMOTE_WRONGPWD	 16#03
#define LSLREMOTE_NOTALLOWED 16#01

#define LSLREMOTE_L0ACCESS	 16#00000000

#define LSLREMOTE_ST_INT	 16#00000001
#define LSLREMOTE_ST_FLOAT	 16#00000002
#define LSLREMOTE_ST_ASCII	 16#00000003
#define LSLREMOTE_ST_UNI	 16#00000004

//################################################################################
//	methods
//################################################################################

//[#ENGLISH]
// Calls to this function are triggered by the RemoteManager.
// This is the main communication routine.
// [Globals]
// [Members]	(c)	IsAllowed		:R		:allow remote login (read from application)
//				(c) MaxLoginLevel	:R		:maximum allowed login level (read from application)
//				(c)	LoginLevel		:R/W	:current login level (read from application)
//				(s)	RemoteOnline	:W		:show online state
//				(s)	OfflineReason	:W		:why are we offline
//					ud_deadtime		:W		:reset deadtime counter
//					ud_access		:W		:acces privilegs (t.b.d)
//					a_serverqueue	:W		:queue for setver set commands
//					a_messagequeue	:W		:queue for message commands
//					a_errorqueue	:R		:queue for error messages
//			us_serverqueueentries	:R/W	:entries in the server queue
//			us_messagequeueentries	:R/W	:entries in the message queue
//			us_errorqueueentries	:R/W	:entries in the error queue
//			us_messagequeue_sema	:R		:semaphor for message queue access
//			us_serverqueue_sema		:R		:semaphor for server queue access
//					message0		:R/W	:current message
//					server0			:R/W	:current server
// [Locals]		lpwd				:R/W	:temporary password 	
//				result				:R/W	:temporary result storage
//				ud_foffs			:R/W	:offset in message structure
//				ud_lsize			:R/W	:offset in server structure					
//[<pPara] Parameters for this call
//[<Results] Pointer to the result structure]
//[>ret_code]
FUNCTION VIRTUAL GLOBAL LslRemote::RemoteOnline::NewInst
VAR_INPUT
	pPara		: ^CmdStruct;
	pResult		: ^Results;
END_VAR
VAR_OUTPUT
	ret_code		: IprStates;
END_VAR
var
	result 		: dint;
	lpwd 		: array[ 0..81 ] of usint;
	ud_lsize	: udint;
	ud_foffs	: udint;
end_var

	CASE pPara^.uiCmd$CmdRemoteOnline OF 


	//[!LOGIN] 0
	//Input: 	zero terminated password string (ascii)
	//Output: 	uiLng (0-1): 	14
	//			aData (0-3): 	result: 	0..success, 
	//										1..not allowed, 
	//										3..wrong password
	//			aData (4-7): 	access privilegs (t.b.d)
	//			aData (8-11): 	IsAllowed (from class client)
	LOGIN:
		IsAllowed 	:= IsAllowed.Read();

		// remote login is allowed
		if( IsAllowed )then

			//ws002: leave login method to the child class (virtual)
			result := LoginRemote( pPwd := #pPara^.aPara[ 0 ]$char );
			if ( result = -1 )then
				OfflineReason	:= LSLREMOTE_WRONGPWD;
				RemoteOnline	:= LSLREMOTE_OFFLINE;
				ud_access		:= LSLREMOTE_L0ACCESS;				
				result 			:= LSLREMOTE_WRONGPWD;
			elsif( result = 0 )then
				OfflineReason 	:= LSLREMOTE_NOTALLOWED;
				RemoteOnline 	:= LSLREMOTE_OFFLINE;
				ud_access		:= LSLREMOTE_L0ACCESS;
				result 			:= LSLREMOTE_NOTALLOWED;
			else
				OfflineReason 	:= 0;
				RemoteOnline	:= LSLREMOTE_ONLINE;
				ud_access		:= result$udint;
				result 			:= 0;
				us_errorqueueentries 	:= 0;
				us_messagequeueentries 	:= 0;
				us_serverqueueentries 	:= 0;
				us_messagequeue_sema	:= 0;
				us_serverqueue_sema		:= 0;
				ud_deadtime				:= 0;
			end_if;
			
		// remote login is not allowed
		else
			OfflineReason 	:= LSLREMOTE_NOTALLOWED;
			RemoteOnline 	:= LSLREMOTE_OFFLINE;
			ud_access		:= LSLREMOTE_L0ACCESS;
			result 			:= LSLREMOTE_NOTALLOWED;
		end_if;

		pResult^.uiLng 				:= 14;
		pResult^.aData[ 0 ]$dint 	:= result;
		pResult^.aData[ 4 ]$udint 	:= ud_access;
		pResult^.aData[ 8 ]$dint 	:= IsAllowed;


	//[!LOGOUT]
	//Input: 	-
	//Output: 	uiLng (0-1): 2
	LOGOUT:
		//To_Login.LogoutRemote();	//ws002: same with the logout method
		LogoutRemote( 0 );			//ws002: may also need the offline reason
		RemoteOnline 			:= 0;
		OfflineReason 			:= 0;
		us_errorqueueentries 	:= 0;
		us_messagequeueentries 	:= 0;
		us_serverqueueentries 	:= 0;
		us_messagequeue_sema	:= 0;
		us_serverqueue_sema		:= 0;
		LoginLevel 				:= 0;
		pResult^.uiLng 			:= 2;

	
	//[!SendMsg] 2
	//Input: 	aPara (0-3): 	UNICODE <-> ASCIICODE (dint: 1:ASCII, 2:UNI) (only if no fragment)
	//			aPara (4-n): 	message string, terminate with zero/double zero! 
	//Output: 	uiLng (0-1): 	6
	//			aData (0-3): 	result: 	0..success, 
	//										1..queue full (but message stored!), 
	//										2..queue access prohibited (try later)
	SendMsg:
		ud_deadtime := 0;		// trigger deadtime counter
		//msgqueue
		if( us_messagequeue_sema )then
			result := 2;	// semaphor ist set, do not touch the queue
		else
			ud_foffs := 0;
			if( message0.typ = 0 )then
				message0.typ := pPara^.aPara[ 0 ]$usint;
				ud_foffs := 1;
			end_if;
			_memcpy( #lpwd[ 0 ], #pPara^.aPara[ ud_foffs ], 80 - ud_foffs * 4 );
			lpwd[ 80 - ud_foffs ]$uint := 0;
			ud_lsize := To_LSE.Str_Size( #lpwd[ 0 ], message0.typ );
			if( message0.data <> NIL )then
				message0.data := OS_SSR_ReAlloc( message0.data, message0.len + ud_lsize + 2 );
				To_LSE.Str_Cpy( ( message0.data + message0.len )$^char, message0.typ, #lpwd[ 0 ], message0.typ );
				message0.len += ud_lsize;
			else
				message0.data := OS_SSR_Malloc( message0.len + 82 );
				lpwd[ 76 ]$uint := 0;
				To_LSE.Str_Cpy( message0.data$^char, message0.typ, #lpwd[ 0 ], message0.typ );
				message0.len := ud_lsize + 1;
			end_if;
			a_messagequeue[ us_messagequeueentries ].data := OS_SSR_Malloc( message0.len );
			_memcpy( a_messagequeue[ us_messagequeueentries ].data, message0.data, message0.len );
			OS_SSR_Free( message0.data );
			message0.data := NIL;
			a_messagequeue[ us_messagequeueentries ].typ := message0.typ;
			message0.typ := 0;
			a_messagequeue[ us_messagequeueentries ].len := message0.len;
			message0.len := 0;

			us_messagequeueentries += 1;
			if( us_messagequeueentries = 0 )then
				result					:= 1; //queue full, but recently set data are in queue
				us_messagequeueentries 	:= 255;
			else
				result 					:= 0;
			end_if;
		end_if;
		pResult^.uiLng 				:= 6;
		pResult^.aData[ 0 ]$dint 	:= result;


	//[!SetServer] 3
	//Input: 	aPara (0-1): 	Transaction ID (int: used for error check) (only if no fragment)
	//			aPara (2): 		Station number (byte) (only if no fragment)
	//			aPara (3): 		Servertype: 	1..int
	//											2..float
	//											3..ascii code
	//											4..unicode (only if no fragment)
	//			aPara (4-n): 	Servername (ASCII-code, zero terminated) (only if no fragment)
	//			aPara (n-m):	data to write (see data type) (m<80!)
	//Output: 	uiLng (0-1): 	6
	//			aData (0-3): 	result: 	0..success, 
	//										1..queue full (but message stored!) (only if no fragment), 
	//										2..queue access prohibited (try later) (only if no fragment)
	SetServer:
		ud_deadtime 	:= 0;	// trigger deadtime counter
		ChangeServers := ChangeServers.Read();
		if( ChangeServers = 0 )then
			pResult^.uiLng 				:= 6;
			pResult^.aData[ 0 ]$dint 	:= 2;	//forbidden by application
			ret_code := READY;
			return;
		end_if;
		if( us_serverqueue_sema )then
			result := 2;	// semaphor is set, do not touch the queue
		else	
			ud_lsize := 0;
			if( server0.TID = 0 )then
				_memcpy( #server0.TID, #pPara^.aPara[ 0 ], 4 );
				server0.sn_complete := FALSE;
				ud_lsize += 4;
			end_if;		
			if( server0.sn_complete = FALSE )then
				server0.servername := OS_SSR_Malloc( 80 );
				_memcpy( server0.servername, #pPara^.aPara[ 1 ], 79 );
				( server0.servername + 79 )^$usint := 0;
				ud_lsize += To_LSE.Str_Size( server0.servername$^char, 1 ) + 1;
				if( ud_lsize < 79 )then
					server0.sn_complete := TRUE;
					server0.servername := OS_SSR_ReAlloc( server0.servername, ud_lsize );
				end_if;
			end_if;
			if( ( server0.sn_complete = TRUE ) )then
				case server0.typ of

				LSLREMOTE_ST_INT, 	// integer
				LSLREMOTE_ST_FLOAT: // float
					server0.data := ( #pPara^.aPara[ ud_lsize shr 2 ] + ( ud_lsize and 16#03 ) )^$^void;
					server0.len := 1;

				LSLREMOTE_ST_ASCII: // ASCII-text
					if( server0.len = 0 )then
						server0.data := OS_SSR_Malloc( 80 - ud_lsize + 1 );
						_memcpy( server0.data, #pPara^.aPara[ ud_lsize shr 2 ] + ( ud_lsize and 16#03 ), 80 - ud_lsize );
						( server0.data + 80 - ud_lsize )^$usint := 0;
						server0.len := To_LSE.Str_Size( server0.data$^char, 1 );
						if( 80 - ud_lsize >= server0.len )then
							server0.data := OS_SSR_ReAlloc( server0.data, server0.len + 1 );
						end_if;
					else
						server0.data := OS_SSR_ReAlloc( server0.data, server0.len + 80 + 1 );
						_memcpy( server0.data + server0.len, #pPara^.aPara[ 0 ], 80 );
						( server0.data + server0.len + 80 )^$usint := 0;
						server0.len := To_LSE.Str_Size( server0.data$^char, 1 );
					end_if;				

				LSLREMOTE_ST_UNI:	// UNICODE-text
					if( server0.len = 0 )then
						server0.data := OS_SSR_Malloc( 80 - ud_lsize + 2 );
						_memcpy( server0.data, #pPara^.aPara[ ud_lsize shr 2 ] + ( ud_lsize and 16#03 ), 80 - ud_lsize );
						( server0.data + 80 - ud_lsize )^$uint := 0;
						server0.len := To_LSE.Str_Size( server0.data$^char, 2 );
						if( 80 - ud_lsize >= server0.len )then
							server0.data := OS_SSR_ReAlloc( server0.data, server0.len + 2 );
						end_if;
					else
						server0.data := OS_SSR_ReAlloc( server0.data, server0.len + 80 + 2 );
						_memcpy( server0.data + server0.len, #pPara^.aPara[ 0 ], 80 );
						( server0.data + server0.len + 80 )^$uint := 0;
						server0.len := To_LSE.Str_Size( server0.data$^char, 2 );
					end_if;				

				end_case;

			end_if;

			a_serverqueue[ us_serverqueueentries ].TID := server0.TID;
			server0.TID := 0;
			a_serverqueue[ us_serverqueueentries ].SID := server0.SID;
			a_serverqueue[ us_serverqueueentries ].typ := server0.typ;
			a_serverqueue[ us_serverqueueentries ].servername := OS_SSR_Malloc( _strlen( server0.servername$^char ) + 1 );
			_strcpy( a_serverqueue[ us_serverqueueentries ].servername$^char, server0.servername$^char );
			OS_SSR_Free( server0.servername );
			server0.servername := NIL;
			a_serverqueue[ us_serverqueueentries ].len := server0.len;
			a_serverqueue[ us_serverqueueentries ].data := OS_SSR_Malloc( a_serverqueue[ us_serverqueueentries ].len + 2 );
			if( ( server0.typ = LSLREMOTE_ST_INT) | ( server0.typ = LSLREMOTE_ST_FLOAT ) )then
				a_serverqueue[ us_serverqueueentries ].data^$udint := server0.data$udint;
			else
				_memcpy( a_serverqueue[ us_serverqueueentries ].data, server0.data, a_serverqueue[ us_serverqueueentries ].len + 2 );
				OS_SSR_Free( server0.data );
			end_if;
			server0.len := 0;
			server0.data := NIL;

			us_serverqueueentries += 1;
			if( us_serverqueueentries = 0 )then
				result					:= 1; //queue full, but recently set data are in queue
				us_serverqueueentries 	:= 255;
			else
				result 					:= 0;
			end_if;
		end_if;
		pResult^.uiLng 				:= 6;
		pResult^.aData[ 0 ]$dint 	:= result;


	//[!IamAlive] 4
	//Input: 	-
	//Output: 	uiLng (0-1): 	2
	IamAlive:
		// must be called at least once in 10 cyclic runs ( cyclic time is to be set to 1 sec )
		ud_deadtime 	:= 0;
		pResult^.uiLng 	:= 2;


	//[!QueueState] 5
	//Input: 	-
	//Output: 	uiLng (0-1): 	7
	//			aData (0): 		server queue entries
	//			aData (1): 		server queue semaphor
	//			aData (2):		message queue entries
	//			aData (3): 		message queue semaphor
	//			aData (4): 		error queue entries
	QueueState:
		ud_deadtime := 0;
		pResult^.uiLng 				:= 7;
		pResult^.aData[ 0 ]$usint 	:= us_serverqueueentries;
		pResult^.aData[ 1 ]$usint 	:= us_serverqueue_sema;
		pResult^.aData[ 2 ]$usint 	:= us_messagequeueentries;
		pResult^.aData[ 3 ]$usint 	:= us_messagequeue_sema;
		pResult^.aData[ 4 ]$usint 	:= us_errorqueueentries;

	
	//[!GetLastError] 6
	//Input: 	-
	//Output: 	uiLng (0-1): 	9
	//			aData (0): 		actionID: 1..set server error, 2..message error
	//			aData (1-4): 	transaction ID
	//			aData (5): 		reason: error code from application
	//			aData (6): 		queue entries left in error queue
	GetLastError:
		ud_deadtime := 0;
		pResult^.uiLng				:= 9;
		if( us_errorqueueentries > 0 )then
			us_errorqueueentries		-= 1;
			pResult^.aData[ 0 ]$usint	:= a_errorqueue[ us_errorqueueentries ].actionID;
			pResult^.aData[ 1 ]$^void	:= a_errorqueue[ us_errorqueueentries ].pobj;
			pResult^.aData[ 5 ]$usint	:= a_errorqueue[ us_errorqueueentries ].reason;
			pResult^.aData[ 6 ]$usint	:= us_errorqueueentries;
		else
			pResult^.aData[ 0 ]$usint	:= 0;
			pResult^.aData[ 1 ]$^void	:= NIL;
			pResult^.aData[ 5 ]$usint	:= 0;
			pResult^.aData[ 6 ]$usint	:= 0;
		end_if;			


	//[!AddMsg] 7
	//Input: 	aPara (0): 		UNICODE <-> ASCIICODE (dint: 1:ASCII, 2:UNI) (only if first fragment)
	//			aPara (4-n): 	message string (n<80, should be terminated with single or double zero)
	//Output: 	uiLng (0-1): 	2
	AddMsg:
		ud_deadtime := 0;
		ud_foffs 	:= 0;
		if( message0.typ = 0 )then
			message0.typ := pPara^.aPara[ 0 ]$usint;
			ud_foffs := 1;
		end_if;
		_memcpy( #lpwd[ 0 ], #pPara^.aPara[ ud_foffs ], 80 - ud_foffs * 4 );
		lpwd[ 80 - ud_foffs * 4 ]$uint := 0;
		ud_lsize := To_LSE.Str_Size( #lpwd[ 0 ], message0.typ );
		if( message0.data <> NIL )then
			message0.data := OS_SSR_ReAlloc( message0.data, message0.len + ud_lsize + 2 );
			To_LSE.Str_Cpy( ( message0.data + message0.len )$^char, message0.typ, #lpwd[ 0 ], message0.typ );
			message0.len += ud_lsize;
		else
			message0.data := OS_SSR_Malloc( message0.len + ud_lsize + 2 );
			lpwd[ 76 ]$uint := 0;
			//if( ud_lsize >= 80 )then ud_lsize := 76; end_if;
			To_LSE.Str_Cpy( message0.data$^char, message0.typ, #lpwd[ 0 ], message0.typ );
			message0.len := ud_lsize;
		end_if;
		pResult^.uiLng := 2;


	//[!AddServer] 8
	//Input: 	aPara (0-1): 	Transaction ID (int: used for error check) (only if first fragment)
	//			aPara (2): 		Station number (byte) (only if first fragment)
	//			aPara (3): 		Servertype: 	1..int
	//											2..float
	//											3..ascii code
	//											4..unicode (only if first fragment)
	//			aPara (4-n): 	Servername (ASCII-code, zero terminated) (only if first fragment), 
	//							The servername may span across multiple messages.
	//			aPara (n-m):	data to write (see data type) (m<80!)
	//Output: 	uiLng (0-1): 	2
	AddServer:
		ud_deadtime := 0;
		ud_lsize 	:= 0;
		ChangeServers := ChangeServers.Read();
		if( ChangeServers = 0 )then
			pResult^.uiLng := 2;
			ret_code := READY;
			return;
		end_if;
		if( server0.TID = 0 )then
			_memcpy( #server0.TID, #pPara^.aPara[ 0 ], 4 );
			server0.sn_complete := FALSE;
			ud_lsize 			+= 4;
		end_if;
		
		if( server0.sn_complete = FALSE )then
			server0.servername := OS_SSR_Malloc( 80 );
			_memcpy( server0.servername, #pPara^.aPara[ 1 ], 79 );
			( server0.servername + 79 )^$usint := 0;
			ud_lsize += To_LSE.Str_Size( server0.servername$^char, 1 ) + 1;
			if( ud_lsize < 79 )then
				server0.sn_complete := TRUE;
				server0.servername := OS_SSR_ReAlloc( server0.servername, ud_lsize );
			end_if;
		end_if;
		if( (*( *)server0.sn_complete = TRUE (*) & ( ud_lsize < 76 )*) )then
			case server0.typ of

			LSLREMOTE_ST_INT, 	// integer
			LSLREMOTE_ST_FLOAT: // float
				server0.data := ( #pPara^.aPara[ ud_lsize shr 2 ] + ( ud_lsize and 16#03 ) )^$^void;
				server0.len := 1;

			LSLREMOTE_ST_ASCII: // ASCII-text
				if( server0.len = 0 )then
					server0.data := OS_SSR_Malloc( 80 - ud_lsize + 1 );
					_memcpy( server0.data, #pPara^.aPara[ ud_lsize shr 2 ] + ( ud_lsize and 16#03 ), 80 - ud_lsize );
					( server0.data + 80 - ud_lsize )^$usint := 0;
					server0.len := To_LSE.Str_Size( server0.data$^char, 1 );
					if( 80 - ud_lsize >= server0.len )then
						server0.data := OS_SSR_ReAlloc( server0.data, server0.len + 1 );
					end_if;
				else
					server0.data := OS_SSR_ReAlloc( server0.data, server0.len + 80 + 1 );
					_memcpy( server0.data + server0.len, #pPara^.aPara[ 0 ], 80 );
					( server0.data + server0.len + 80(* - ud_lsize + 1 *))^$usint := 0;
					server0.len := To_LSE.Str_Size( server0.data$^char, 1 );
				end_if;				

			LSLREMOTE_ST_UNI:	// UNICODE-text
				if( server0.len = 0 )then
					server0.data := OS_SSR_Malloc( 80 - ud_lsize + 2 );
					_memcpy( server0.data, #pPara^.aPara[ ud_lsize shr 2 ] + ( ud_lsize and 16#03 ), 80 - ud_lsize );
					( server0.data + 80 - ud_lsize )^$uint := 0;
					server0.len := To_LSE.Str_Size( server0.data$^char, 2 );
					if( 80 - ud_lsize >= server0.len )then
						server0.data := OS_SSR_ReAlloc( server0.data, server0.len + 2 );
					end_if;
				else
					server0.data := OS_SSR_ReAlloc( server0.data, server0.len + 80 + 2 );
					_memcpy( server0.data + server0.len, #pPara^.aPara[ 0 ], 80 );
					( server0.data + server0.len + 80(* - ud_lsize + 1 *))^$uint := 0;
					server0.len := To_LSE.Str_Size( server0.data$^char, 2 );
				end_if;				

			end_case;
		end_if;
		pResult^.uiLng := 2;

	END_CASE;

	ret_code := READY;

END_FUNCTION //VIRTUAL GLOBAL LslRemote::RemoteOnline::NewInst

//[#ENGLISH]
// CyWork will trigger the Logout upon a timeout event
// [Globals]
// [Members]	(s)	OfflineReason	:W		:tell the local user that a timeout occured
//				(s) RemoteOnline	:R		:check if we are remote online 
//					ud_deadtime		:R/W	:deadtime counter
//				(c) LoginLevel		:W		:current login level
// [Locals]
//[<EAX]
//[>state]
FUNCTION VIRTUAL GLOBAL LslRemote::CyWork
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR

	// deadtime counter
	// automatically log out after LSLREMOTE_AUTOLOGOFF cyclic runs without a deadtime reset
	ud_deadtime += 1;
	if( ( ud_deadtime >= LSLREMOTE_AUTOLOGOFF ) & ( RemoteOnline = LSLREMOTE_ONLINE ) )then
		// go offline
		//To_Login.LogoutRemote(); //ws002
		LogoutRemote( 2 );
		OfflineReason 	:= 2;
		//Same asLogout except OfflineReason and queue states
		RemoteOnline 	:= LSLREMOTE_OFFLINE;
		LoginLevel 		:= LSLREMOTE_OFFLINE;
	end_if;
	state:= READY;

END_FUNCTION //VIRTUAL GLOBAL LslRemote::CyWork
//[#ENGLISH]
// Background will process the queues
// [Globals]
// [Members]	us_serverqueueentries	:R/W	:process the server queue
//				us_serverqueue_sema		:W
//				a_serverqueue			:R
//				us_messagequeueentries	:R/W	:process the message queue
//				us_messagequeue_sema	:W
//				a_messagequeue			:R
//				us_errorqueueentries	:R/W	:process the error queue
//				a_errorqueue			:W
// [Locals]
//				i						:R/W	:counter
//				result					:R/W	:temporary result storage	
//				vl0						:R/W	:SetSystemData variable
//				va						:R/W	:SetSystemData variable
//				res						:R/W	SetSystemData result				
//[<EAX]
//[>state]
FUNCTION VIRTUAL GLOBAL LslRemote::Background
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR
var
	i 		: usint;
	result 	: dint;
	vl0		: _VARLABEL;
	va		: _VARIABLE;
	res		: _RESULT;
end_var

	if( us_serverqueueentries > 0 )then
		us_serverqueue_sema 	:= TRUE;
		for i := 0 to us_serverqueueentries - 1 do

			vl0.no 				:= 1;
			vl0.info[ 0 ].state := VAR_VAL;
			vl0.info[ 0 ].value := VarList_GetVarNoStation( a_serverqueue[ i ].servername$^char, a_serverqueue[ i ].SID )$dint;
			init_VARIABLE( #va );
			init_RESULT( #res );

			if( a_serverqueue[ i ].typ = LSLREMOTE_ST_INT )then
				res.ftype := RES_NUMERIC;
				res.value := a_serverqueue[ i ].data^$dint;
				res.remotedata 	:= 1;
			end_if;
			if( a_serverqueue[ i ].typ = LSLREMOTE_ST_FLOAT )then
				res.ftype 		:= RES_REAL;
				res.value$real 	:= a_serverqueue[ i ].data^$real;
				res.remotedata 	:= 1;
			end_if;
			if( ( a_serverqueue[ i ].typ = LSLREMOTE_ST_ASCII ) | ( a_serverqueue[ i ].typ = LSLREMOTE_ST_UNI ) )then
				res.ftype 		:= RES_ANUMERIC;
				res.ptr 		:= a_serverqueue[ i ].data$^void;
				res.remotedata 	:= 1;
			end_if;

			result := VarList_SetSystemData( #res, #va, #vl0, _FALSE );

			if( result = 0 )then
				a_errorqueue[ us_errorqueueentries ].actionID 	:= 1; //setserver error
				a_errorqueue[ us_errorqueueentries ].pobj$udint	:= to_udint( a_serverqueue[ i ].TID$uint );
				a_errorqueue[ us_errorqueueentries ].reason	  	:= result$usint;
				us_errorqueueentries 							+= 1;
				if( us_errorqueueentries = 0 )then
				us_errorqueueentries := 255;
					_memcpy( #a_errorqueue[ 0 ].actionID, #a_errorqueue[ 1 ].actionID, sizeof( a_errorqueue[ 0 ] ) * 255 ); 
				end_if;
			end_if;
		end_for;
		us_serverqueueentries 	:= 0;
		us_serverqueue_sema		:= FALSE;
	end_if;
	if( us_messagequeueentries > 0 )then
		us_messagequeue_sema := TRUE;
		for i := 0 to us_messagequeueentries - 1 do
			//if( IsClientConnected( #ImageNumber ) )then
			ImageNumber := ImageNumber.Read();
			Message.WriteDataOff( 1, 0, "" );
			Message.WriteDataOff( a_messagequeue[ i ].len, 0, ( a_messagequeue[ i ].data )$^char );
			OS_SSR_Free( a_messagequeue[ i ].data );
			a_messagequeue[ i ].data := NIL;
			result := InsertCmd( CMD_NEWWINDOW, ImageNumber, 0 );
			if( result = FALSE )then
				a_errorqueue[ us_errorqueueentries ].actionID := 2; //setmessage error
				a_errorqueue[ us_errorqueueentries ].pobj	  := NIL;
				a_errorqueue[ us_errorqueueentries ].reason	  := result$usint;
				us_errorqueueentries += 1;
				if( us_errorqueueentries = 0 )then
					us_errorqueueentries := 255;
					_memcpy( #a_errorqueue[ 0 ].actionID, #a_errorqueue[ 1 ].actionID, sizeof( a_errorqueue[ 0 ] ) * 255 ); 
				end_if;
			end_if;
			(*else
				a_errorqueue[ us_errorqueueentries ].actionID := 2; //setmessage error
				a_errorqueue[ us_errorqueueentries ].pobj	  := NIL;
				a_errorqueue[ us_errorqueueentries ].reason	  := 1; //client "ImageNumber" is not connected
				us_errorqueueentries += 1;
				if( us_errorqueueentries = 0 )then
				us_errorqueueentries := 255;
				_memcpy( #a_errorqueue[ 0 ].actionID, #a_errorqueue[ 1 ].actionID, sizeof( a_errorqueue[ 0 ] ) * 255 ); 
				end_if;
			end_if;*)
		end_for;
		us_messagequeueentries 	:= 0;
		us_messagequeue_sema	:= FALSE;
	end_if;
	state := READY;

END_FUNCTION //VIRTUAL GLOBAL LslRemote::Background
FUNCTION VIRTUAL GLOBAL LslRemote::LoginRemote	//ws002
VAR_INPUT
	pPwd 	: ^CHAR;
END_VAR
VAR_OUTPUT
	dLevel 	: DINT;
END_VAR
VAR
	lpwd : ARRAY[ 0..81 ] OF USINT;
END_VAR

	RemotePassword.ReadDataOff( 0, #lpwd[ 0 ], RemotePassword.GetLength() );
	lpwd[ RemotePassword.GetLength() ] := 0;
	if( _strcmp( pPwd , #lpwd[ 0 ] ) = 0 )then
		dLevel 	:= LoginLevel.Read();
	else
		dLevel := -1;
	end_if;

END_FUNCTION
#pragma warning (disable:073)
FUNCTION VIRTUAL GLOBAL LslRemote::LogoutRemote	//ws002
VAR_INPUT
	dOfflineReason 	: DINT;
END_VAR

END_FUNCTION
#pragma warning(default:073)
