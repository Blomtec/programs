//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "SRAMInfo_User"
	Revision           = "1.0"
	GUID               = "{D2BB8D74-CF36-4836-86A2-527DF66B3DAC}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(420,180)"
	Comment            = "This class creates a file and writes the recived SRAM data into this file.">
	<Channels>
		<Client Name="cFileSys" Required="false" Internal="false" Comment="Object channel to _FileSys. Does not have to be connected."/>
		<Client Name="cStdLib" Required="false" Internal="false" Comment="Object channel to StdLib. Does not have to be connected."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.0" Date="2016-04-25" Author="GreJoh" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
	<Network Name="SRAMInfo_User">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{F350280F-9131-4548-AEF7-E355BE9BF770}"
				Class      = "DiagnosticUserFunction"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="sStatus"/>
					<Client Name="cSigCLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.sStatus" Destination="_base.sStatus" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using DiagnosticUserFunction

SRAMInfo_User : CLASS
: DiagnosticUserFunction
	TYPE
	  t_e_SRAMInfoSteps :
	  (
	    _IDLE,
	    _CREATE_FILE,
	    _WRITE_FILE,
	    _CLOSE_FILE,
	    _FINISHED,
	    _CHECK_STATE,
	    _ERROR
	  )$UDINT;
	END_TYPE
  //Servers:
  //Clients:
	cStdLib 	: CltChCmd__StdLib;
	cFileSys 	: CltChCmd__FileSys;
  //Variables:
		DrivePath : ARRAY [0..Diagnostic_MAX_FileFolderString] OF CHAR;
			//! <Variable Comment="String with the path where the file with the sram data will be created." Name="DrivePath"/>
		ssw_SRAMInfo 	: t_e_SRAMInfoSteps;
		pSRAMInfo 	: pVoid;			//! <Variable Comment="Pointer to the sram data." Name="pSRAMInfo"/>
		ssw_NextStep 	: t_e_SRAMInfoSteps;
		SizeSRamInfo 	: UDINT;			//! <Variable Comment="Size of the sram data." Name="SizeSRamInfo"/>
		dRetID 	: DINT;
		dHandle 	: DINT;
		pHandleAddress 	: ^DINT;
		dIdentification 	: DINT;
		dWrittenBytes 	: DINT;			//! <Variable Comment="Size of the written bytes." Name="dWrittenBytes"/>
  //Functions:
				//! <Function Comment="Use this method to set the drive path." Name="SetDrivePath"/>
	FUNCTION VIRTUAL GLOBAL SetDrivePath
		VAR_INPUT
			pDP 	: ^CHAR;			//! <Variable Comment="Pointer to the data with the drive path." Name="SetDrivePath.pDP"/>
		END_VAR;
				//! <Function Comment="Receive data." Name="ReceivedData"/>
	FUNCTION VIRTUAL GLOBAL ReceivedData
		VAR_INPUT
			size 	: UDINT;			//! <Variable Comment="Size of the received data." Name="ReceivedData.size"/>
			pdata 	: ^USINT;			//! <Variable Comment="Pointer to the received data." Name="ReceivedData.pdata"/>
			OptCMD 	: USINT;			//! <Variable Comment="Optional command." Name="ReceivedData.OptCMD"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="FALSE..Error&#13;&#10;TRUE..Data received" Name="ReceivedData.retcode"/>
		END_VAR;
				//! <Function Comment="This method will be called cyclic when the diagnostic export is started." Name="WorkMethode"/>
	FUNCTION VIRTUAL GLOBAL WorkMethode;
				//! <Function Comment="Get the actual state." Name="GetWorkState"/>
	FUNCTION VIRTUAL GLOBAL GetWorkState
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Actual state." Name="GetWorkState.retcode"/>
		END_VAR;
				//! <Function Comment="Get error code." Name="GetErrorCode"/>
	FUNCTION VIRTUAL GLOBAL GetErrorCode
		VAR_OUTPUT
			retcode 	: _DiagErrorCode;			//! <Variable Comment="Error code." Name="GetErrorCode.retcode"/>
		END_VAR;
				//! <Function Comment="Is called when the work method finished." Name="EndWork"/>
	FUNCTION VIRTUAL GLOBAL EndWork;
				//! <Function Comment="Method to set the parameters for the GetAsyncState method." Name="SetAsyncParam"/>
	FUNCTION SetAsyncParam
		VAR_INPUT
			pHandleAddr 	: ^DINT;			//! <Variable Comment="Pointer which is used for the input variable Erg of the method GetAsyncState." Name="SetAsyncParam.pHandleAddr"/>
			dId 	: DINT;			//! <Variable Comment="Variable which is used for the input variable ID of the method GetAsyncState." Name="SetAsyncParam.dId"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SRAMInfo_User::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_SRAMINFO_USER
1$UINT, 0$UINT, (SIZEOF(::SRAMInfo_User))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2684662291), "SRAMInfo_User", //Class
TO_UDINT(487743715), "DiagnosticUserFunction", 1$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::SRAMInfo_User.cStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2073677046), "cStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::SRAMInfo_User.cFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(194275965), "cFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
END_FUNCTION


#define USER_CNT_SRAMInfo_User 6

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SRAMInfo_User] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SRAMInfo_User::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= DiagnosticUserFunction::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DiagnosticUserFunction::sStatus.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DiagnosticUserFunction::sStatus.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SRAMInfo_User;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #SetDrivePath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #ReceivedData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #WorkMethode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetWorkState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetErrorCode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #EndWork();

#pragma warning (default : 74)
	DiagnosticUserFunction::sStatus.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DiagnosticUserFunction::sStatus.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION



FUNCTION VIRTUAL GLOBAL SRAMInfo_User::WorkMethode

  case ssw_SRAMInfo of

    // Idle
    //**********************************************************************    
    _IDLE : // Wait for Start Aktion (  RecivedData )

        

    // Create File
    //**********************************************************************
    _CREATE_FILE : 
        cSigCLib.StrCat(ps1:=#DrivePath[0], ps2:=Diagnostic_SRAMInfoFileName);   
        dRetID := cFileSys.FileOpen_A(Async:=1, filename:=#DrivePath[0], attributes:=ATT_CREATE_ALWAYS);
        ssw_NextStep := _WRITE_FILE;
        SetAsyncParam(pHandleAddr:=#dHandle, dId:=dRetID);
        

    // Write data to the created file
    //**********************************************************************    
    _WRITE_FILE : 
        dRetID := cFileSys.FileWrite_AV1(Async:=1, handle:=dHandle, buffer:=pSRAMInfo, length:=SizeSRamInfo);
        ssw_NextStep := _CLOSE_FILE;
        SetAsyncParam(pHandleAddr:=#dWrittenBytes, dId:=dRetID);


    // Close File
    //**********************************************************************    
    _CLOSE_FILE : 
        dRetID := cFileSys.FileClose_A(Async:=1, handle:=dHandle);
        ssw_NextStep := _FINISHED;
        SetAsyncParam(pHandleAddr:=#dHandle, dId:=dRetID);
        
        
    // Finished
    //**********************************************************************           
    _FINISHED : sStatus := READY;
        ssw_SRAMInfo := _IDLE;
        
        
    // Check asynchronous state 
    //**********************************************************************    
    _CHECK_STATE :

        dRetID := cFileSys.GetAsyncState(ID:=to_udint(dIdentification), Erg:=pHandleAddress);
        
        case dRetID of          
          
          RT_INVALID_ID,
          RT_ERG_DELETED:
            Fault.ErrorNr := to_DINT(ssw_SRAMInfo);
            Fault.ErrorCode := -1;
            ssw_SRAMInfo := _ERROR;
          
          0:     
            ssw_SRAMInfo := ssw_NextStep;
            
        end_case;
   
        
        
    // Error
    //**********************************************************************    
    _ERROR :
      sStatus := ERROR;
      ssw_SRAMInfo := _IDLE;
      
    
  end_case;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_User::EndWork

  if pSRAMInfo <> NIL then
    cStdLib.Free(mptr:=pSRAMInfo);
    pSRAMInfo := NIL;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_User::ReceivedData
	VAR_INPUT
		size 	: UDINT;
		pdata 	: ^USINT;
		OptCMD 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := FALSE;
  if ssw_SRAMInfo = _IDLE then
    if pdata <> 0 & size <> 0 then
       
      SizeSRamInfo := size;
      pSRAMInfo := cStdLib.Malloc(size:=size);
      
      if pSRAMInfo <> NIL then
        // copy the sram infos of the received data to a local variable
        _memcpy(ptr1:=pSRAMInfo, ptr2:=pdata, cntr:=size);
        retcode := TRUE;
        // set next step
        ssw_SRAMInfo := _CREATE_FILE;
        sStatus := BUSY;    
      else
        Fault.ErrorNr := 1;
        Fault.ErrorCode := -2;
        sStatus := ERROR;
      end_if;

    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_User::SetDrivePath
	VAR_INPUT
		pDP 	: ^CHAR;
	END_VAR

  cSigCLib.StrCpy(dst0:=#DrivePath[0], src0:=pDP);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_User::GetWorkState
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR

  retcode := sStatus;


END_FUNCTION
FUNCTION SRAMInfo_User::SetAsyncParam
	VAR_INPUT
		pHandleAddr 	: ^DINT;
		dId 	: DINT;
	END_VAR

    pHandleAddress := pHandleAddr;
    dIdentification := dId;
    ssw_SRAMInfo := _CHECK_STATE;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_User::GetErrorCode
	VAR_OUTPUT
		retcode 	: _DiagErrorCode;
	END_VAR

  retcode := Fault;

END_FUNCTION
