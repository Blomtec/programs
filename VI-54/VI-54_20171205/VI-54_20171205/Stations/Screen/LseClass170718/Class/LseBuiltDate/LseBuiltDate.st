//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "LseBuiltDate"
	Revision           = "0.0"
	GUID               = "{9E72C239-B90C-4332-8B27-61288A3B060C}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(660,180)">
	<Channels>
		<Server Name="Datum" GUID="{6BB98E03-BF4E-4DBE-B24D-A77EBB7BA881}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="filesys" Required="false" Internal="false"/>
		<Client Name="ToLseBuiltString" Required="true" Internal="false"/>
	</Channels>
	<Network Name="LseBuiltDate">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{C6043388-C78C-4862-8704-12E07155455D}"
				Class      = "String"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Data" Destination="_base.Data" Vertices="(946,210),(774,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using String

LseBuiltDate : CLASS
: String
  //Servers:
	Datum 	: SvrCh__DDE_DATIM;
  //Clients:
	filesys 	: CltChCmd__FileSys;
	ToLseBuiltString 	: CltChCmd_String;
  //Variables:
		Fileinfo 	: _DDE_INFO;
		Vnr : ARRAY [0..10] OF CHAR;

		DateStruct 	: DateTime;
		udDatum 	: _DDE_DATIM;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION ConvToDate
		VAR_INPUT
			dde_dt 	: _DDE_DATIM;
		END_VAR
		VAR_OUTPUT
			DT_struct 	: DateTime;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Datum::Read
		VAR_OUTPUT
			output (EAX) 	: _DDE_DATIM;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Datum::Write
		VAR_INPUT
			input (EAX) 	: _DDE_DATIM;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: _DDE_DATIM;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB LseBuiltDate::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_LSEBUILTDATE
0$UINT, 0$UINT, (SIZEOF(::LseBuiltDate))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3808693144), "LseBuiltDate", //Class
TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, //Baseclass
//Servers:
(::LseBuiltDate.Datum.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3974964380), "Datum", 
//Clients:
(::LseBuiltDate.filesys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "filesys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
(::LseBuiltDate.ToLseBuiltString.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3429375009), "ToLseBuiltString", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_LseBuiltDate 22

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_LseBuiltDate] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION LseBuiltDate::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= String::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= VirtualBaseInit::Data.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, VirtualBaseInit::Data.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_LseBuiltDate;
	vmt.CmdTable.Init		:= #Init();
	VirtualBaseInit::Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VirtualBaseInit::Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Datum.pMeth			:= StoreMethod( #Datum::Read(), #Datum::Write() );
	IF Datum.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL LseBuiltDate::Init

  FileSys.FindFirst("c:\MPC\","LSEMPC.CRC",#FileInfo,0,0);
  
  udDatum:=Fileinfo.datetime;
  
  DateStruct:=ConvToDate(udDatum);
  
  Datum:=udDatum;
  
  ToLseBuiltString.writedataoff(20,0,#DateStruct.str[0]);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL LseBuiltDate::Datum::Read
	VAR_OUTPUT
		output (EAX) 	: _DDE_DATIM;
	END_VAR

	output := Datum;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL LseBuiltDate::Datum::Write
	VAR_INPUT
		input (EAX) 	: _DDE_DATIM;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: _DDE_DATIM;
	END_VAR

	Datum := input;
 	result := Datum;

END_FUNCTION


FUNCTION LseBuiltDate::ConvToDate
	VAR_INPUT
		dde_dt 	: _DDE_DATIM;
	END_VAR
	VAR_OUTPUT
		DT_struct 	: DateTime;
	END_VAR
  VAR
    dde_udint:udint;
  END_VAR;

  dde_udint:=dde_dt$udint;
  
  // read date time data

  DT_struct.Year    := (dde_udint AND 2#11111110000000000000000000000000) shr 25;

  DT_struct.Year    += 1980;

  DT_struct.Month   := (dde_udint AND 2#00000001111000000000000000000000) shr 21;

  DT_struct.Day     :=   (dde_udint AND 2#00000000000111110000000000000000) shr 16;

  DT_struct.Hour    := (dde_udint AND 2#00000000000000001111100000000000) shr 11;

  DT_struct.Minute  := (dde_udint AND 2#00000000000000000000011111100000) shr 5;

  

  //write date time data in a string

  if DT_struct.Day < 10 then                

     DtoA(#dt_struct.str[1],to_DINT(DT_struct.Day), 0x0800,sizeof(_ASCII));
  
     dt_struct.str[0] := '0';

  else       

     DtoA(#dt_struct.str[0],to_DINT(DT_struct.Day), 0x0800,sizeof(_ASCII));

  end_if;

  dt_struct.str[2] := '.';



  if DT_struct.Month < 10 then         

     DtoA(#dt_struct.str[4],to_DINT(DT_struct.Month), 0x0800,sizeof(_ASCII));

     dt_struct.str[3] := '0';

  else       

     DtoA(#dt_struct.str[3],to_DINT(DT_struct.Month), 0x0800,sizeof(_ASCII));

  end_if;

  dt_struct.str[5] := '.';



  DtoA(#dt_struct.str[6],to_DINT(DT_struct.Year), 0x0800,sizeof(_ASCII));

  dt_struct.str[10] := 32;

  dt_struct.str[11] := 32;

  

  if DT_struct.Hour < 10 then             

     DtoA(#dt_struct.str[13],to_DINT(DT_struct.Hour), 0x0800,sizeof(_ASCII));
  
     dt_struct.str[12] := '0';

  else       

     DtoA(#dt_struct.str[12],to_DINT(DT_struct.Hour), 0x0800,sizeof(_ASCII));

  end_if;

  dt_struct.str[14] := ':';

  

  if DT_struct.Minute < 10 then      

     DtoA(#dt_struct.str[16],to_DINT(DT_struct.Minute), 0x0800,sizeof(_ASCII));
  
     dt_struct.str[15] := '0';

  else       

     DtoA(#dt_struct.str[15],to_DINT(DT_struct.Minute), 0x0800,sizeof(_ASCII));

  end_if;



  dt_struct.str[17] := 0;


END_FUNCTION
