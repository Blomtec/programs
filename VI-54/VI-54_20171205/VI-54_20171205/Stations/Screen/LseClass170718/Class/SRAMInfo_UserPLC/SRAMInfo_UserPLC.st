//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "SRAMInfo_UserPLC"
	Revision           = "1.0"
	GUID               = "{71033A50-5904-497B-8C52-50CD74725827}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(416,120)"
	Comment            = "Use this class to get SRAM data.">
	<Channels>
		<Client Name="cFileSys" Required="false" Internal="false" Comment="Object channel to _FileSys. Does not have to be connected."/>
		<Client Name="cSigCLib" Required="false" Internal="false" Comment="Object channel to SigCLib. Does not have to be connected."/>
		<Client Name="cStdLib" Required="false" Internal="false" Comment="Object channel to _StdLib. Does not have to be connected."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.0" Date="2016-04-25" Author="GreJoh" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
	<Network Name="SRAMInfo_UserPLC">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{82C4E0EF-E37F-42C5-ACAC-E934FBCB64AF}"
				Class      = "DiagnosticUserFunction_PLC"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="sStatus"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.sStatus" Destination="_base.sStatus" Vertices="(946,210),(774,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using DiagnosticUserFunction_PLC

SRAMInfo_UserPLC : CLASS
: DiagnosticUserFunction_PLC
	TYPE
	  t_e_SRAM_STEPS :
	  (
	    _IDLE,
	    _CREATE_FILENAME,
	    _SAVE_SRAM,
	    _OPEN_FILE,
	    _GET_FILELENGTH,
	    _READ_SRAMDATA,
	    _CLOSE_FILE,
	    _DELETE_FILE,
	    _CHECK_STATE,
	    _FINISHED,
	    _ERROR
	  )$UDINT;
	END_TYPE
  //Servers:
  //Clients:
	cFileSys 	: CltChCmd__FileSys;
	cSigCLib 	: CltChCmd_SigCLib;
	cStdLib 	: CltChCmd__StdLib;
  //Variables:
		pSRAMInfo_PLC 	: pVoid;			//! <Variable Comment="Pointer to the SRAM data." Name="pSRAMInfo_PLC"/>
		Fault 	: _DiagErrorCode;			//! <Variable Comment="Struct for error." Name="Fault"/>
		ssw_SRAMInfo 	: t_e_SRAM_STEPS;
		ssw_NextStep 	: t_e_SRAM_STEPS;
		dRetID 	: DINT;
		dHandle 	: DINT;
		pHandleAddress 	: ^DINT;
		dIdentification 	: DINT;
		FilePath : ARRAY [0..Diagnostic_MAX_FileFolderString] OF CHAR;
			//! <Variable Comment="String for the path of the Sram.dat file." Name="FilePath"/>
		dWriteHandle 	: DINT;
		dFileLength 	: DINT;
		dReadBytes 	: DINT;			//! <Variable Comment="Number of bytes which were read." Name="dReadBytes"/>
  //Functions:
				//! <Function Comment="Is called when the diagnostic export starts." Name="StartWork"/>
	FUNCTION VIRTUAL GLOBAL StartWork
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Ready..Continue with the work methode&#13;&#10;Error..ssw is in a wrong step" Name="StartWork.retcode"/>
		END_VAR;
				//! <Function Comment="This method will be called cyclic when the diagnostic export is started." Name="WorkMethode"/>
	FUNCTION VIRTUAL GLOBAL WorkMethode;
				//! <Function Comment="Get the actual state of the function." Name="GetWorkState"/>
	FUNCTION VIRTUAL GLOBAL GetWorkState
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Actual state." Name="GetWorkState.retcode"/>
		END_VAR;
				//! <Function Comment="Method to get the actual error code." Name="GetErrorCode"/>
	FUNCTION VIRTUAL GLOBAL GetErrorCode
		VAR_OUTPUT
			retcode 	: _DiagErrorCode;			//! <Variable Comment="Error code." Name="GetErrorCode.retcode"/>
		END_VAR;
				//! <Function Comment="Method to get the size of the data which should be send." Name="GetDataSize"/>
	FUNCTION VIRTUAL GLOBAL GetDataSize
		VAR_OUTPUT
			retcode 	: UDINT;			//! <Variable Comment="Size of the data." Name="GetDataSize.retcode"/>
		END_VAR;
				//! <Function Comment="Method to get the pointer to the data of the user function." Name="GetDataPtr"/>
	FUNCTION VIRTUAL GLOBAL GetDataPtr
		VAR_OUTPUT
			dataPtr 	: ^void;			//! <Variable Comment="Pointer to the user data." Name="GetDataPtr.dataPtr"/>
		END_VAR;
				//! <Function Comment="Is called when the work method finished." Name="EndWork"/>
	FUNCTION VIRTUAL GLOBAL EndWork;
				//! <Function Comment="Method to set the parameters of the method GetAsyncState." Name="SetAsyncParam"/>
	FUNCTION SetAsyncParam
		VAR_INPUT
			pHandleAddr 	: ^DINT;			//! <Variable Comment="Pointer which is used for the input variable Erg of the method GetAsyncState." Name="SetAsyncParam.pHandleAddr"/>
			dId 	: DINT;			//! <Variable Comment="Variable which is used for the input variable ID of the method GetAsyncState." Name="SetAsyncParam.dId"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SRAMInfo_UserPLC::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_SRAMINFO_USERPLC
1$UINT, 0$UINT, (SIZEOF(::SRAMInfo_UserPLC))$UINT, 
0$UINT, 3$UINT, 0$UINT, 
TO_UDINT(4011520555), "SRAMInfo_UserPLC", //Class
TO_UDINT(4200646535), "DiagnosticUserFunction_PLC", 1$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::SRAMInfo_UserPLC.cFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(194275965), "cFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
(::SRAMInfo_UserPLC.cSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1539399991), "cSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 14$UINT, 
(::SRAMInfo_UserPLC.cStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2073677046), "cStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_SRAMInfo_UserPLC 7

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SRAMInfo_UserPLC] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SRAMInfo_UserPLC::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= DiagnosticUserFunction_PLC::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DiagnosticUserFunction_PLC::sStatus.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DiagnosticUserFunction_PLC::sStatus.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SRAMInfo_UserPLC;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #StartWork();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #WorkMethode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetWorkState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetErrorCode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetDataSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #GetDataPtr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #EndWork();

#pragma warning (default : 74)
	DiagnosticUserFunction_PLC::sStatus.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DiagnosticUserFunction_PLC::sStatus.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL SRAMInfo_UserPLC::WorkMethode


  case ssw_SRAMInfo of
  
    // Idle
    //**********************************************************************
    _IDLE :


    // Create FileName
    //**********************************************************************  
    _CREATE_FILENAME :
    
      cSigCLib.StrCpy(dst0:=#FilePath[0], src0:=Diagnostic_SRAMInfoTmpDPNE);
      ssw_SRAMInfo := _SAVE_SRAM;
    
    // Save Sram image to file
    //**********************************************************************  
    _SAVE_SRAM :
    
      dRetID := cFileSys.SRamSave(filename:=#FilePath[0]);
      if dRetID = 0 then
        ssw_SRAMInfo := _OPEN_FILE;
      else
        ssw_SRAMInfo := _ERROR;
      end_if;


     // open file
    //**********************************************************************  
    _OPEN_FILE :
    
      dRetID := cFileSys.FileOpen_A(Async:=1, filename:=#FilePath[0], attributes:=ATT_READ_WRITE);
      SetAsyncParam(pHandleAddr:=#dHandle, dId:=dRetID);
      ssw_SRAMInfo := _CHECK_STATE;
      ssw_NextStep := _GET_FILELENGTH;

    // Get file length
    //**********************************************************************  
    _GET_FILELENGTH :
    
      dRetID := cFileSys.FileLength_A(Async:=1, handle:=dHandle);
      SetAsyncParam(pHandleAddr:=#dFileLength, dId:=dRetID);
      ssw_SRAMInfo := _CHECK_STATE;
      ssw_NextStep := _READ_SRAMDATA;


    // Read Sram Data
    //**********************************************************************  
    _READ_SRAMDATA :
    
      pSRAMInfo_PLC := cStdLib.Malloc(size:=to_udint(dFileLength));
      if pSRAMInfo_PLC = NIL then
        ssw_SRAMInfo := _ERROR;
        return;
      end_if;
   
      dRetID := cFileSys.FileRead_AV1(Async:=1, handle:=dHandle, buffer:=pSRAMInfo_PLC, length:=to_udint(dFileLength));
      SetAsyncParam(pHandleAddr:=#dReadBytes, dId:=dRetID);
      ssw_SRAMInfo := _CHECK_STATE;
      ssw_NextStep := _CLOSE_FILE;
      
    
    // Close File
    //**********************************************************************  
    _CLOSE_FILE :
      
      dRetID := cFileSys.FileClose_A(Async:=1, handle:=dHandle);
      SetAsyncParam(pHandleAddr:=#dHandle, dId:=dRetID);
      ssw_SRAMInfo := _CHECK_STATE;
      ssw_NextStep := _DELETE_FILE; 


    // Delete File
    //**********************************************************************  
    _DELETE_FILE :
    
      dRetID := cFileSys.FileDelete_A(Async:=1, filename:=#FilePath[0]);
      SetAsyncParam(pHandleAddr:=#dHandle, dId:=dRetID);
      ssw_SRAMInfo := _CHECK_STATE;
      ssw_NextStep := _FINISHED;
    
    
    // Check asynchronous state
    //**********************************************************************  
    _CHECK_STATE :
    
      dRetID := cFileSys.GetAsyncState(ID:=to_udint(dIdentification), Erg:=pHandleAddress);
      
      case dRetID of
      
        RT_INVALID_ID,
        RT_ERG_DELETED: 
          ssw_SRAMInfo := _ERROR;
        
        0:
          if ssw_NextStep = _GET_FILELENGTH then
            dWriteHandle := dHandle;            
          elsif ssw_NextStep = _CLOSE_FILE then
            
            if dReadBytes = dFileLength then
            
            else
              
              ssw_SRAMInfo := _ERROR;
              return;
            
            end_if;
            
          end_if;

          ssw_SRAMInfo := ssw_NextStep;
          
      end_case;


      
    
    // Finished
    //**********************************************************************  
    _FINISHED :
    
        sStatus := READY;
        ssw_SRAMInfo := _IDLE;


    // Error
    //**********************************************************************
    _ERROR :
        
        Fault.ErrorNr := to_dint(ssw_SRAMInfo);
        Fault.ErrorCode := -1;
        
        sStatus := ERROR;
        ssw_SRAMInfo := _IDLE;
  
  end_case;


END_FUNCTION


FUNCTION SRAMInfo_UserPLC::SetAsyncParam
	VAR_INPUT
		pHandleAddr 	: ^DINT;
		dId 	: DINT;
	END_VAR

    pHandleAddress := pHandleAddr;
    dIdentification := dId;
    ssw_SRAMInfo := _CHECK_STATE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_UserPLC::StartWork
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR

  if ssw_SRAMInfo = _IDLE then
    ssw_SRAMInfo := _CREATE_FILENAME;
    retcode := Ready;
    sStatus:= BUSY;
  else
    retcode := ERROR;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_UserPLC::EndWork

  ssw_SRAMInfo := _IDLE;
  
  if pSRAMInfo_PLC <> NIL then
    cStdLib.Free(mptr:=pSRAMInfo_PLC);
    pSRAMInfo_PLC := NIL;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_UserPLC::GetDataPtr
	VAR_OUTPUT
		dataPtr 	: ^void;
	END_VAR

  dataPtr := pSRAMInfo_PLC;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_UserPLC::GetDataSize
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

    retcode := to_udint(dFileLength);
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_UserPLC::GetErrorCode
	VAR_OUTPUT
		retcode 	: _DiagErrorCode;
	END_VAR

  retcode := Fault;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SRAMInfo_UserPLC::GetWorkState
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR

  retcode := sStatus;

END_FUNCTION
