//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_FileExplorer"
	Revision           = "0.8"
	GUID               = "{808D7E98-486F-43F2-9B5A-DF67AA474A8C}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_FileExplorer\FileExplorer.ico"
	SharedCommandTable = "true"
	Objectsize         = "(390,540)"
	Comment            = "Contains basic functionality like file copy, delete file, make directory...&#13;&#10;">
	<Channels>
		<Server Name="ActPos" WriteProtected="false">
		</Server>
		<Server Name="ConfirmYes" GUID="{3C42E9CC-AA4A-4D3F-A7FE-2B9DF7AD73E5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Execute" GUID="{75AB05F9-B04E-4794-8BE9-51FF9DDC9495}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="IsActivated" GUID="{A7FAF9B6-BE75-4836-A516-A79AA582FC44}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="IsBusySignal" GUID="{73C3A9C1-6CF7-4972-8C88-E67AD8187C9D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="IsMarked" GUID="{215AEB99-1AF3-45A5-A304-C83280D291A5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="SortCriteria" GUID="{09CFE241-24BA-4E20-BC80-B35EF3211564}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Client Name="ActFileName" Required="true" Internal="true"/>
		<Client Name="ActSelection" Required="true" Internal="true"/>
		<Client Name="ActSelectionDPNE" Required="true" Internal="true"/>
		<Client Name="ConfirmWindow" Required="true" Internal="false" DefValue="-1"/>
		<Client Name="DescriptionText" Required="true" Internal="true"/>
		<Client Name="ErrorWindow" Required="true" Internal="false" DefValue="-1"/>
		<Client Name="KeyPadAnumFileExplorer" Required="true" Internal="true"/>
		<Client Name="Mux" Required="true" Internal="true"/>
		<Client Name="NameInput" Required="true" Internal="true"/>
		<Client Name="PixelWidthDate" Required="true" Internal="false" DefValue="0" Comment="Width of column in pixel where filedate is shown. Use 0 as default"/>
		<Client Name="PixelWidthFileSize" Required="true" Internal="false" DefValue="0" Comment="Width of column in pixel where filesize is shown. Use 0 as default"/>
		<Client Name="PixelWidthName" Required="true" Internal="false" DefValue="0" Comment="Width of column in pixel where filename is shown. Use 0 as default"/>
		<Client Name="PixelWidthTime" Required="true" Internal="false" DefValue="0" Comment="Width of column in pixel where filetime is shown. Use 0 as default"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.8" Date="2016-08-23" Author="kolott" Company="sigmatek" Description="sa33281: setup pixelwidth of div.colums is implemented. look at new clients starting with &quot;PixelWidth&quot;.&#13;&#10;new server &quot;SortCriteria&quot; to ensure different sortalgorithm (A-Z, Z-A, DateTime, Size)&#13;&#10;Default text added in portuguese lanuage as well."/>
		<Dokumentation Revision="0.7" Date="2013-10-07" Author="kolott" Company="sigmatek" Description="ascii-keypad (qwertz, qwerty, azerty) included"/>
		<Dokumentation Revision="0.6" Date="2013-04-02" Author="kolott" Company="sigmatek" Description="sa24986: new embedded string ActSelectionDPNE&#13;&#10;sa25093: update directory"/>
		<Dokumentation Revision="0.5" Date="2013-03-20" Author="kolott" Company="sigmatek" Description="dr1885: bugfix to ensure messageboxes in all languages"/>
		<Dokumentation Revision="0.4" Date="2012-12-20" Author="kolott" Company="sigmatek" Description="dr1811: new functionality Overwrite existing File added"/>
		<Dokumentation Revision="0.3" Date="2012-11-15" Author="kolott" Company="sigmatek" Description="dr1784: text NoName at function Rename exchanged with actual filename"/>
		<Dokumentation Revision="0.2" Date="2012-09-03" Author="kolott" Company="sigmatek" Description="dr1739: overwrie existing file didn&apos;t work properly"/>
		<Dokumentation Revision="0.1" Date="2012-06-25" Author="kolott" Company="sigmatek" Description="release"/>
	</RevDoku>
	<Network Name="_FileExplorer">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{7FF11839-2F5B-4A6D-A875-171024FA6DCD}"
				Class      = "_ScrollArea2"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ActPos"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="ExtendedScrollBar" Value="0"/>
					<Client Name="LineHighness"/>
					<Client Name="LineWidth"/>
					<Client Name="Lse"/>
					<Client Name="VerticalLevel"/>
				</Channels>
			</Object>
			<Object
				Name       = "ActFileName"
				GUID       = "{A8A8E6DE-A1C4-4959-AAF8-7DA66CA127E0}"
				Class      = "String"
				Position   = "(600,1140)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "ActSelection"
				GUID       = "{A7F71126-A84C-411D-B981-ECD4319C9EE3}"
				Class      = "String"
				Position   = "(600,540)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "ActSelectionDPNE"
				GUID       = "{78657BB9-D1E3-4D87-9C29-D4146E858F07}"
				Class      = "String"
				Position   = "(600,690)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "DescriptionText"
				GUID       = "{6AB6CFC3-9FC1-428E-BEDD-2AEBF5BEC97B}"
				Class      = "String"
				Position   = "(600,990)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "KeyPadAnumFileExplorer"
				GUID       = "{570DA4AE-D76F-4AE0-A8A3-81FFF64C26A4}"
				Class      = "KeyPadAnumFileExplorer"
				Position   = "(180,690)"
				Visualized = "false">
				<Channels>
					<Server Name="Screen"/>
					<Client Name="CapitalLetter" Value="1"/>
					<Client Name="ImA" Value="IMA_WINDOW"/>
					<Client Name="Lse"/>
					<Client Name="No" Value="_WIN_EDITOR_ANUMFILEX"/>
				</Channels>
			</Object>
			<Object
				Name       = "Mux"
				GUID       = "{09153CCF-300F-4C99-8C60-9F142557FE87}"
				Class      = "CriticalSection"
				Position   = "(600,1290)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "NameInput"
				GUID       = "{F6D1F601-7EE6-43F4-9F0F-FEBF2106ED9C}"
				Class      = "String"
				Position   = "(600,840)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(1328,210),(518,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(1328,270),(518,270),"/>
			<Connection Source="this.ActPos" Destination="_base.ActPos" Vertices="(1328,330),(518,330),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.LineWidth" Destination="this.LineWidth" Vertices="(218,330),(38,330),"/>
			<Connection Source="_base.VerticalLevel" Destination="this.VerticalLevel" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.ActSelection" Destination="ActSelection.Data"/>
			<Connection Source="this.NameInput" Destination="NameInput.Data"/>
			<Connection Source="this.DescriptionText" Destination="DescriptionText.Data"/>
			<Connection Source="this.ActFileName" Destination="ActFileName.Data"/>
			<Connection Source="_base.ExtendedScrollBar" Destination="this.ExtendedScrollBar" Vertices="(218,450),(38,450),"/>
			<Connection Source="_base.LineHighness" Destination="this.LineHighness" Vertices="(218,390),(38,390),"/>
			<Connection Source="this.Mux" Destination="Mux.ClassSvr"/>
			<Connection Source="this.ActSelectionDPNE" Destination="ActSelectionDPNE.Data"/>
			<Connection Source="this.KeyPadAnumFileExplorer" Destination="KeyPadAnumFileExplorer.Screen"/>
			<Connection Source="KeyPadAnumFileExplorer.Lse" Destination="this.Lse" Vertices="(180,780),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _ScrollArea2

_FileExplorer : CLASS
: _ScrollArea2
	TYPE
	  Exec :  //! <Type Public="true" Name="Exec"/>
	  (
	    ExecIdle,
	    ExecLoad,
	    ExecSave,
	    ExecMark,
	    ExecUnMark,
	    ExecPaste,
	    ExecDelete,
	    ExecMkDir,
	    ExecUpdate,
	    ExecPanic,
	    ExecRename,
	    ExecOverwrite
	  )$UDINT;
	  FexSortCrit :  //! <Type Public="true" Name="FexSortCrit"/>
	  (
	    SortAz:=0,
	    SortAzInvert:=1,
	    SortDateTime:=2,
	    SortDateTimeInvert:=3,
	    SortSize:=4,
	    SortSizeInvert:=5
	  )$UDINT;
	END_TYPE
  //Servers:
	Execute 	: SvrCh_Exec_PTofCls__FileExplorer;
	IsBusySignal 	: SvrCh_UDINT;
	IsActivated 	: SvrCh_UDINT;
	IsMarked 	: SvrCh_UDINT;
	ConfirmYes 	: SvrCh_DINT;
	SortCriteria 	: SvrCh_FexSortCrit_PTofCls__FileExplorer;
  //Clients:
	ActSelection 	: CltChCmd_String;
	ConfirmWindow 	: CltCh_DINT;
	DescriptionText 	: CltChCmd_String;
	ErrorWindow 	: CltCh_DINT;
	NameInput 	: CltChCmd_String;
	ActFileName 	: CltChCmd_String;
	Mux 	: CltChCmd_CriticalSection;
	ActSelectionDPNE 	: CltChCmd_String;
	KeyPadAnumFileExplorer 	: CltChCmd_KeyPadAnumFileExplorer;
	PixelWidthName 	: CltCh_DINT;
	PixelWidthDate 	: CltCh_DINT;
	PixelWidthTime 	: CltCh_DINT;
	PixelWidthFileSize 	: CltCh_DINT;
  //Variables:
		Pex 	: ^_FILEXPLORER;
		OldPos 	: DINT;
		VarNoName 	: UDINT;
		MyIoVarNo 	: UDINT;
		InDPNE : ARRAY [0..255] OF CHAR;

		InLine 	: DINT;
		InCmd 	: UDINT;
		InNameCrc 	: UDINT;
		ExecuteLine 	: DINT;
		ExecuteCmd 	: UDINT;
		Font 	: _FONT;
		SelectionIs 	: _SELIS;
		InSelIs 	: _SELIS;
		IsBusyTimex 	: UDINT;
		IsBusy 	: UDINT;
		TmpName : ARRAY [0..64] OF CHAR;

  //Functions:
	
	FUNCTION _FileExplorer
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method will be called once when the focus will be given to this object&#13;&#10;&#13;&#10;pio ....... pointer to _IO information&#13;&#10;&#13;&#10;return _IFAILED if you dont want to get the focus on the other hand _IDLE&#13;&#10;" Name="GetFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="GetFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return _IFAILED if you dont want to get the focus on the other hand _IDLE" Name="GetFocus.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to redraw the io&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;pr ........ pointer to result information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
				//! <Function Comment="this method is called right away before the object will be destroyed.&#13;&#10;for example close picture or window&#13;&#10;" Name="IF_End"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_End;
				//! <Function Comment="method is called every time when redraw of a single line is necessary.&#13;&#10;" Name="Line32"/>
	FUNCTION VIRTUAL GLOBAL Line32
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to structure _SCROLL" Name="Line32.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to place where line should be drawn" Name="Line32.pr"/>
			line 	: DINT;			//! <Variable Comment="aktual linenumber starts with 0" Name="Line32.line"/>
			state 	: BOOL;			//! <Variable Comment="line is selected (true) or passive (false)" Name="Line32.state"/>
		END_VAR;
	
	FUNCTION DoActPath
		VAR_INPUT
			state 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to do userconfiguration" Name="PerformInit"/>
	FUNCTION VIRTUAL GLOBAL PerformInit;
				//! <Function Comment="method will be performed to set whol view to default" Name="ExecutePanic"/>
	FUNCTION VIRTUAL GLOBAL ExecutePanic
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false&#13;&#10;" Name="ExecutePanic.retcode"/>
		END_VAR;
				//! <Function Comment="method will be performed to load a selected file" Name="ExecuteLoad"/>
	FUNCTION VIRTUAL GLOBAL ExecuteLoad
		VAR_INPUT
			dpne 	: ^CHAR;			//! <Variable Comment="DrivePathNameExtention of file to load" Name="ExecuteLoad.dpne"/>
			isfile 	: BOOL;			//! <Variable Comment="true when &apos;dpne&apos; is a file, on the other hand false" Name="ExecuteLoad.isfile"/>
			linepos 	: DINT;			//! <Variable Comment="numeric lineposition in scrolllist" Name="ExecuteLoad.linepos"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false&#13;&#10;" Name="ExecuteLoad.retcode"/>
		END_VAR;
				//! <Function Comment="method will be performed to save new file" Name="ExecuteSave"/>
	FUNCTION VIRTUAL GLOBAL ExecuteSave
		VAR_INPUT
			dpne 	: ^CHAR;			//! <Variable Comment="DrivePathNameExtention of file to save" Name="ExecuteSave.dpne"/>
			isfile 	: BOOL;			//! <Variable Comment="true when &apos;dpne&apos; is a file, on the other hand false" Name="ExecuteSave.isfile"/>
			linepos 	: DINT;			//! <Variable Comment="numeric lineposition in scrolllist" Name="ExecuteSave.linepos"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false&#13;&#10;" Name="ExecuteSave.retcode"/>
		END_VAR;
				//! <Function Comment="method will be performed to delete existing file or directory" Name="ExecuteDelete"/>
	FUNCTION VIRTUAL GLOBAL ExecuteDelete
		VAR_INPUT
			dpne 	: ^CHAR;			//! <Variable Comment="DrivePathNameExtention of file or directory to delete" Name="ExecuteDelete.dpne"/>
			selis 	: _SELIS;			//! <Variable Comment="true when &apos;dpne&apos; is a file, on the other hand false" Name="ExecuteDelete.selis"/>
			linepos 	: DINT;			//! <Variable Comment="numeric lineposition in scrolllist" Name="ExecuteDelete.linepos"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false&#13;&#10;" Name="ExecuteDelete.retcode"/>
		END_VAR;
				//! <Function Comment="method will be performed to mark actual selection" Name="ExecuteMark"/>
	FUNCTION VIRTUAL GLOBAL ExecuteMark
		VAR_INPUT
			dpne 	: ^CHAR;			//! <Variable Comment="DrivePathNameExtention of file or directory to mark" Name="ExecuteMark.dpne"/>
			selis 	: _SELIS;			//! <Variable Comment="true when &apos;dpne&apos; is a file, on the other hand false" Name="ExecuteMark.selis"/>
			linepos 	: DINT;			//! <Variable Comment="numeric lineposition in scrolllist" Name="ExecuteMark.linepos"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false&#13;&#10;" Name="ExecuteMark.retcode"/>
		END_VAR;
				//! <Function Comment="method will be performed to paste actual selection" Name="ExecutePaste"/>
	FUNCTION VIRTUAL GLOBAL ExecutePaste
		VAR_INPUT
			dpne 	: ^CHAR;			//! <Variable Comment="DrivePathNameExtention of file or directory to paste" Name="ExecutePaste.dpne"/>
			linepos 	: DINT;			//! <Variable Comment="numeric lineposition in scrolllist" Name="ExecutePaste.linepos"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false&#13;&#10;" Name="ExecutePaste.retcode"/>
		END_VAR;
				//! <Function Comment="method will be performed to update actual node in scrollist" Name="ExecuteUpdate"/>
	FUNCTION VIRTUAL GLOBAL ExecuteUpdate
		VAR_INPUT
			linepos 	: DINT;			//! <Variable Comment="numeric lineposition in scrolllist" Name="ExecuteUpdate.linepos"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false&#13;&#10;" Name="ExecuteUpdate.retcode"/>
		END_VAR;
				//! <Function Comment="method will be performed to unmark all marked items" Name="ExecuteUnMark"/>
	FUNCTION VIRTUAL GLOBAL ExecuteUnMark
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false&#13;&#10;" Name="ExecuteUnMark.retcode"/>
		END_VAR;
				//! <Function Comment="method will be performed to create new directory" Name="ExecuteMakeDirectory"/>
	FUNCTION VIRTUAL GLOBAL ExecuteMakeDirectory
		VAR_INPUT
			dpne 	: ^CHAR;			//! <Variable Comment="DrivePathNameExtention directory to create" Name="ExecuteMakeDirectory.dpne"/>
			isfile 	: BOOL;			//! <Variable Comment="true when &apos;dpne&apos; is a file, on the other hand false" Name="ExecuteMakeDirectory.isfile"/>
			linepos 	: DINT;			//! <Variable Comment="numeric lineposition in scrolllist" Name="ExecuteMakeDirectory.linepos"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false&#13;&#10;" Name="ExecuteMakeDirectory.retcode"/>
		END_VAR;
	
	FUNCTION GetAsciiText
		VAR_INPUT
			dst 	: ^CHAR;
			psrc 	: ^String;
			dstmaxlen 	: UDINT;
		END_VAR;
	
	FUNCTION InitiateNameInput
		VAR_INPUT
			dpne 	: ^CHAR;
			selis 	: _SELIS;
			linepos 	: DINT;
			cmd 	: UDINT;
			txtid 	: UDINT;
		END_VAR;
	
	FUNCTION ExecuteSaveIntern
		VAR_INPUT
			stp 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ExecuteOverwriteIntern
		VAR_INPUT
			stp 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ExecuteMakeDirectoryIntern
		VAR_INPUT
			stp 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION InitiateQuestionConfirm
		VAR_INPUT
			dpne 	: ^CHAR;
			selis 	: _SELIS;
			linepos 	: DINT;
			cmd 	: UDINT;
			txtid 	: UDINT;
		END_VAR;
	
	FUNCTION ExecuteMarkIntern
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ExecuteDeleteIntern
		VAR_INPUT
			stp 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION InitiateErrorConfirm
		VAR_INPUT
			txtid 	: UDINT;
			txtext 	: ^void;
			txtextchrsize 	: UINT;
		END_VAR;
	
	FUNCTION ExecuteLoadIntern
		VAR_INPUT
			stp 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ExecutePasteIntern
		VAR_INPUT
			stp 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GetPathName
		VAR_INPUT
			line 	: DINT;
			pselis 	: ^_SELIS;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
				//! <Function Comment="method will be performed to execute arbitrary command" Name="RunExecute"/>
	FUNCTION VIRTUAL GLOBAL RunExecute
		VAR_INPUT
			cmdno 	: UDINT;			//! <Variable Comment="commandnumber to execute" Name="RunExecute.cmdno"/>
		END_VAR
		VAR_OUTPUT
			upd 	: BOOL;			//! <Variable Comment="true means that update of view is nezessary, on the other hand false" Name="RunExecute.upd"/>
		END_VAR;
				//! <Function Comment="method is used to get description text" Name="GetDescriptionText"/>
	FUNCTION VIRTUAL GLOBAL GetDescriptionText
		VAR_INPUT
			ptxt 	: ^pVoid;			//! <Variable Comment="pointer where text should be given" Name="GetDescriptionText.ptxt"/>
			pchrsize 	: ^UINT;			//! <Variable Comment="1 for ascii-code, 2 to get text in unicode-format" Name="GetDescriptionText.pchrsize"/>
			txtid 	: UDINT;			//! <Variable Comment="id of text to be given" Name="GetDescriptionText.txtid"/>
		END_VAR;
	
	FUNCTION IsFocusGiven
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION SetStringText
		VAR_INPUT
			pdst 	: ^String;
			psrc 	: ^void;
			chrsize 	: UINT;
		END_VAR;
	
	FUNCTION CheckName
		VAR_INPUT
			txt 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CheckDrivelist
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="user keep off, is internal used" Name="MessageBoxResultIntern"/>
	FUNCTION __CDECL GLOBAL MessageBoxResultIntern
		VAR_INPUT
			messboxres 	: _MESSAGEBOXRESULT;
		END_VAR;
				//! <Function Comment="method will be called after confirm of messagebox" Name="MessageBoxResult"/>
	FUNCTION VIRTUAL GLOBAL MessageBoxResult
		VAR_INPUT
			messboxres 	: _MESSAGEBOXRESULT;			//! <Variable Comment="result of messageboxconfirmation" Name="MessageBoxResult.messboxres"/>
		END_VAR;
	
	FUNCTION GetPathNameCut
		VAR_INPUT
			line 	: DINT;
			pselis 	: ^_SELIS;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
				//! <Function Comment="method is called to represent result of async copy command" Name="ExecuteAsyncDeleteCallBack"/>
	FUNCTION GLOBAL ExecuteAsyncDeleteCallBack
		VAR_INPUT
			pline 	: ^_Thread2CmdLine;			//! <Variable Comment="information about async command" Name="ExecuteAsyncDeleteCallBack.pline"/>
			result 	: BOOL;			//! <Variable Comment="result of async command" Name="ExecuteAsyncDeleteCallBack.result"/>
		END_VAR;
	
	FUNCTION BusyPush;
	
	FUNCTION BusyPop;
				//! <Function Comment="method is called to represent result of async paste command" Name="ExecuteAsyncPasteCallBack"/>
	FUNCTION __CDECL GLOBAL ExecuteAsyncPasteCallBack
		VAR_INPUT
			pline 	: ^_Thread2CmdLine;			//! <Variable Comment="information of async command" Name="ExecuteAsyncPasteCallBack.pline"/>
			result 	: BOOL;			//! <Variable Comment="result of async command" Name="ExecuteAsyncPasteCallBack.result"/>
		END_VAR;
	
	FUNCTION ExecuteUpdateIntern
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ExecuteRenameIntern
		VAR_INPUT
			stp 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION MakeName
		VAR_INPUT
			name 	: ^CHAR;
			filefilter 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to rename file" Name="ExecuteRename"/>
	FUNCTION VIRTUAL GLOBAL ExecuteRename
		VAR_INPUT
			newname 	: ^CHAR;			//! <Variable Comment="new DrivePathNameExtenton of file" Name="ExecuteRename.newname"/>
			isfile 	: BOOL;			//! <Variable Comment="has to be true" Name="ExecuteRename.isfile"/>
			linepos 	: DINT;			//! <Variable Comment="numeric lineposition of scrolllist" Name="ExecuteRename.linepos"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true on success, on the other hand false" Name="ExecuteRename.retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL ExecutePreLoad
		VAR_INPUT
			dpne 	: ^CHAR;
			isfile 	: BOOL;
			linepos 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL ExecutePreSave
		VAR_INPUT
			dpne 	: ^CHAR;
			isfile 	: BOOL;
			linepos 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION UpdateWholeTree;
	
	FUNCTION GetSaveAsName
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL CheckUpdate;
	
	FUNCTION VIRTUAL GLOBAL ActPos::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Execute::Write
		VAR_INPUT
			input (EAX) 	: _FileExplorer::Exec;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: _FileExplorer::Exec;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using CriticalSection
#pragma using KeyPadAnumFileExplorer
#pragma using String


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _FileExplorer::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__FILEEXPLORER
0$UINT, 8$UINT, (SIZEOF(::_FileExplorer))$UINT, 
6$UINT, 13$UINT, 0$UINT, 
TO_UDINT(129556241), "_FileExplorer", //Class
TO_UDINT(2779823616), "_ScrollArea2", 0$UINT, 8$UINT, //Baseclass
//Servers:
(::_FileExplorer.Execute.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3223776964), "Execute", 
(::_FileExplorer.IsBusySignal.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3441133598), "IsBusySignal", 
(::_FileExplorer.IsActivated.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(107368977), "IsActivated", 
(::_FileExplorer.IsMarked.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1995179535), "IsMarked", 
(::_FileExplorer.ConfirmYes.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2468045121), "ConfirmYes", 
(::_FileExplorer.SortCriteria.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(4073798929), "SortCriteria", 
//Clients:
(::_FileExplorer.ActSelection.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(455631546), "ActSelection", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::_FileExplorer.ConfirmWindow.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3496877262), "ConfirmWindow", 
(::_FileExplorer.DescriptionText.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2763306315), "DescriptionText", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::_FileExplorer.ErrorWindow.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2750713059), "ErrorWindow", 
(::_FileExplorer.NameInput.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2256111188), "NameInput", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::_FileExplorer.ActFileName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3110629722), "ActFileName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::_FileExplorer.Mux.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(629126998), "Mux", TO_UDINT(794617671), "CriticalSection", 0$UINT, 4$UINT, 
(::_FileExplorer.ActSelectionDPNE.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3748020132), "ActSelectionDPNE", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::_FileExplorer.KeyPadAnumFileExplorer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1264995709), "KeyPadAnumFileExplorer", TO_UDINT(1264995709), "KeyPadAnumFileExplorer", 0$UINT, 3$UINT, 
(::_FileExplorer.PixelWidthName.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4086163132), "PixelWidthName", 
(::_FileExplorer.PixelWidthDate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(120631232), "PixelWidthDate", 
(::_FileExplorer.PixelWidthTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3258581247), "PixelWidthTime", 
(::_FileExplorer.PixelWidthFileSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3125892921), "PixelWidthFileSize", 
END_FUNCTION


#define USER_CNT__FileExplorer 40

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__FileExplorer] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _FileExplorer::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _ScrollArea2::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__FileExplorer;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #IF_End();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #Line32();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #PerformInit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #ExecutePanic();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #ExecuteLoad();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #ExecuteSave();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #ExecuteDelete();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #ExecuteMark();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #ExecutePaste();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #ExecuteUpdate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #ExecuteUnMark();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #ExecuteMakeDirectory();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #RunExecute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #GetDescriptionText();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #MessageBoxResult();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #ExecuteRename();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #ExecutePreLoad();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #ExecutePreSave();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #CheckUpdate();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ActPos::Write() );
	IF ActPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Execute.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Execute::Write() );
	IF Execute.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ConfirmYes.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ConfirmYes.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SortCriteria.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SortCriteria.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _FileExplorer();

END_FUNCTION

#pragma usingLtd String

//{{LSL_IMPLEMENTATION

#define FEXEC_IDLE         0
#define FEXEC_LOAD0       10
#define FEXEC_LOAD1       11
#define FEXEC_SAVE0       20
#define FEXEC_SAVE1       21
#define FEXEC_SAVE2       22
#define FEXEC_MARK        30
#define FEXEC_UNMARK      40
#define FEXEC_PASTE0      50
#define FEXEC_PASTE1      51
#define FEXEC_DELETE0     60
#define FEXEC_DELETE1     61
#define FEXEC_MAKEDIR0    70
#define FEXEC_MAKEDIR1    71
#define FEXEC_UPDT        80
#define FEXEC_PANIC       90
#define FEXEC_RENAME0    100
#define FEXEC_RENAME1    101
#define FEXEC_OVERWRITE0 110
#define FEXEC_OVERWRITE1 111

#define ERROR_SAVE_INVALIDNAME           0
#define ERROR_RENAME_INVALIDNAME         1
#define ERROR_RENAME_NAMEALREADYEXIST    2
#define ERROR_DELETE_INVALIDNAME         3
#define ERROR_DELETE_NOTPOSSIBLE         4
#define ERROR_DELETE_NOTRDLY             5
#define ERROR_LOAD_NOTAFILE              6
#define ERROR_PASTE_NOITEMSELECTED       7
#define ERROR_SRCDST_INTERSECT           8
#define ERROR_FOCUSNOTGIVEN              9
#define ERROR_DELETE_FAILED             10
#define ERROR_PASTE_FAILED              11

#define CONFIRM_ALREADYEXIST_OVERWRITE 106
#define CONFIRM_DELETEFILE             107
#define CONFIRM_DELETEDIR              108
#define CONFIRM_LOADFILE               109
#define CONFIRM_COPYITEM               110
#define INPUT_NEWFILENAME              212
#define INPUT_NEWDIRECTORYNAME         213

FUNCTION _FileExplorer::_FileExplorer
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code     := C_OK;
  MyIoVarNo    := DEFSCOPE;
  VarNoName    := DEFSCOPE;
  IsBusy       := 0;
  IsBusyTimex  := 0;
  IsBusySignal := 0;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _FileExplorer::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  VAR
  	myv : _VARIABLE;
  END_VAR

  _ScrollArea2::If_Start(pio, firsttime);
  
  Font := pio^.font;
  
  if(firsttime = true) then
    SelectionIs := SELIS_NONE;
    InCmd       := FEXEC_IDLE;
    ExecuteCmd  := FEXEC_IDLE;
    if(VarList_GetVariable(#myv, #pio^.variable) = true) then
      MyIoVarNo := pio^.variable.info[0].value$udint;
      if(VarNoName = DEFSCOPE) then
        VarNoName := VarList_GetVarNoByID(NameInput.pCmd$udint, myv.info.station, true);
      end_if;
      PerformInit();
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::Line32
	VAR_INPUT
		ps 	: ^_SCROLL;
		pr 	: ^_ROOM;
		line 	: DINT;
		state 	: BOOL;
	END_VAR
  VAR
  	color : _COLOR;
  END_VAR

  if(state = TRUE) then
    color := ps^.color_activ; 
  else
    color := ps^.color_inactiv; 
  end_if;

  LineBackGround(ps, pr, GetBackColor(color));
  filexplo_line(Pex, line, pr, color);

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _FileExplorer::IF_End

  _ScrollArea2::If_End();
  //Pex := explorer_end(Pex);

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _FileExplorer::GetFocus
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR

  retcode := _ScrollArea::GetFocus(pio);
  FocusJustGiven := false;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _FileExplorer::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  VAR
  	doaction : bool;
    tmp : dint;
    room     : _ROOM;  
  END_VAR

  doaction := false;

  if((Focus = true) & (IsBusy = 0)) then // nur wenn focus und nicht busy

    if(pe^.ftype = _EVENT_KEYPRESS) then
      if(pe^.scancode = _ENTER) then // action
        doaction := true;
      elsif(pe^.scancode = _DEL) then  // delete
        Execute.Write(ExecDelete);
      elsif(IsCtrlKeyPress(pe, 'c') = true) then // CTRL-C
        Execute.Write(ExecMark);
      elsif(IsCtrlKeyPress(pe, 'v') = true) then // CTRL-V
        Execute.Write(ExecPaste);
      end_if;
    elsif(pe^.ftype = _EVENT_HIDPRESS) then
//      if(IsButtonPosition(#ped^.input.io, #pe^.dot) <> 0) then
//        //pe^.ftype := _EVENT_NONE;
//        retcode := _IDIDIT;
//        return;
//      else
        tmp := Scroll.position.pos - Scroll.position.begin;
        GetLinePosition_SCROLL(#Scroll, to_uint(tmp), #room);
        if((pe^.dot.x >= room.xy1.x) & (pe^.dot.x <= room.xy2.x) & 
           (pe^.dot.y >= room.xy1.y) & (pe^.dot.y <= room.xy2.y)) then
          doaction := true;
        end_if;
//      end_if;
    elsif(pe^.ftype = _EVENT_LASALOS) then
      CheckDrivelist();
    end_if;

    if(doaction = true) then
      if(filexplo_enter(Pex, #Scroll.position) = true) then
        _ScrollArea2::OutPage(); // out page      
      end_if;
    end_if;

    DoActPath(false);
  end_if;

  retcode := _ScrollArea2::GetEvent(ped, pe);
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::RunExecute
	VAR_INPUT
		cmdno 	: udint;
	END_VAR
	VAR_OUTPUT
		upd 	: bool;
	END_VAR
  
  upd := false;
  case cmdno of
    FEXEC_MARK       : upd := ExecuteMarkIntern();
    FEXEC_UNMARK     : upd := ExecuteUnMark();
    FEXEC_MAKEDIR0   : upd := ExecuteMakeDirectoryIntern(0);
    FEXEC_MAKEDIR1   : upd := ExecuteMakeDirectoryIntern(1);
    FEXEC_DELETE0    : upd := ExecuteDeleteIntern(0);
    FEXEC_DELETE1    : upd := ExecuteDeleteIntern(1);
    FEXEC_SAVE0      : upd := ExecuteSaveIntern(0);
    FEXEC_SAVE1      : upd := ExecuteSaveIntern(1);
    FEXEC_SAVE2      : upd := ExecuteSaveIntern(2);
    FEXEC_LOAD0      : upd := ExecuteLoadIntern(0);
    FEXEC_LOAD1      : upd := ExecuteLoadIntern(1);
    FEXEC_PASTE0     : upd := ExecutePasteIntern(0);
    FEXEC_PASTE1     : upd := ExecutePasteIntern(1);
    FEXEC_PANIC      : upd := ExecutePanic();
    FEXEC_UPDT       : upd := ExecuteUpdateIntern();
    FEXEC_RENAME0    : upd := ExecuteRenameIntern(0);
    FEXEC_RENAME1    : upd := ExecuteRenameIntern(1);
    FEXEC_OVERWRITE0 : upd := ExecuteOverwriteIntern(0);
    FEXEC_OVERWRITE1 : upd := ExecuteOverwriteIntern(1);
  end_case;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _FileExplorer::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR
  VAR
  	te : udint;
    upd : bool;
  END_VAR

  if(IsBusy <> 0) then
    te := ops.tAbsolute;
    if((te - IsBusyTimex) > 100) then
      IsBusyTimex  := te;
      IsBusySignal += 1;
      if(IsBusySignal > 5) then 
        IsBusySignal := 1;
      end_if;
    end_if;
  else
    IsBusySignal := 0;
  end_if;
  
  _ScrollArea2::IF_Run(pio, input);

  if(Pex <> NIL) then

    CheckUpdate();
 
    if(ExecuteCmd <> FEXEC_IDLE) then
      te         := ExecuteCmd;
      upd        := false;
      ConfirmYes := 0;
      InNameCrc  := NameInput.GetCRC();
      ExecuteCmd := FEXEC_IDLE;
      
      if(RunExecute(te) = true) then
        DoActPath(true);
        _ScrollArea2::OutPage();
      end_if;
    elsif(InCmd <> FEXEC_IDLE) then
      // confirm question
      // confirm name
      if((InNameCrc <> NameInput.GetCRC()) | (ConfirmYes <> 0) 
         | (AcknowledgeFlag(-1) <> 0) // sa27246: ask for and ifnec reset acknowledgeflag
        ) then
        if(ConfirmYes = 0) then
          InsertCmd(CMD_EDIT, MyIoVarNo$dint, 0); // set focus to filelist
        end_if;
        InNameCrc   := NameInput.GetCRC();
        ConfirmYes  := 0;
        ExecuteCmd  := InCmd;
        ExecuteLine := InLine;
        InCmd       := FEXEC_IDLE;
      end_if;
    end_if;
    
    if(Focus = false) then
      IsMarked    := 0;
      IsActivated := 0;
    else
      IsMarked    := Pex^.Tree.markedlines;
      IsActivated := 1;
    end_if;
    
    CheckDrivelist();
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ActPos::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

 	result := _ScrollArea::ActPos.Write(input);
  DoActPath(false);

END_FUNCTION

FUNCTION _FileExplorer::DoActPath
	VAR_INPUT
		state 	: BOOL;
	END_VAR
  VAR
  	dpne : ^char;
  END_VAR

  if((Scroll.position.pos <> OldPos)|(state = true)) then
    OldPos := Scroll.position.pos;
    dpne := filexplo_path(Pex, #SelectionIs, Scroll.position.pos, true);
    if(dpne <> NIL) then
      ActSelection.WriteDataOff(StrLen(dpne, sizeof(_ASCII)), 0, dpne);
    end_if;
    
    dpne := filexplo_path(Pex, #SelectionIs, Scroll.position.pos, false);
    if(dpne <> NIL) then
      ActSelectionDPNE.WriteDataOff(StrLen(dpne, sizeof(_ASCII)), 0, dpne); // sa24986
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::Execute::Write
	VAR_INPUT
		input (EAX) 	: _FileExplorer::Exec;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: _FileExplorer::Exec;
	END_VAR

	Execute     := input;
 	result      := Execute;
  ExecuteCmd  := FEXEC_IDLE;
  ExecuteLine := -1;
  
  if(Execute = ExecPanic) then
    ExecuteCmd := FEXEC_PANIC;
  elsif(IsActivated = true) then
    ExecuteLine := Scroll.position.pos;
    case Execute of 
      ExecLoad      : ExecuteCmd := FEXEC_LOAD0;
      ExecSave      : ExecuteCmd := FEXEC_SAVE0;
      ExecOverwrite : ExecuteCmd := FEXEC_OVERWRITE0;
      ExecMark      : ExecuteCmd := FEXEC_MARK;
      ExecUnMark    : ExecuteCmd := FEXEC_UNMARK;
      ExecPaste     : ExecuteCmd := FEXEC_PASTE0;
      ExecDelete    : ExecuteCmd := FEXEC_DELETE0;
      ExecMkDir     : ExecuteCmd := FEXEC_MAKEDIR0;
      ExecUpdate    : ExecuteCmd := FEXEC_UPDT;
      ExecRename    : ExecuteCmd := FEXEC_RENAME0;
    end_case;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::PerformInit

  //Pex := explorer_end(Pex); // start always new initialized
  if(Pex = NIL) then
    Pex := filexplo_start(#Scroll.position, NIL, NIL);
    
    if(Pex <> NIL) then
      Pex^.ShowAttribute := true;
      Pex^.ShowDate      := true;
      Pex^.ShowSize      := true;
      Pex^.ShowTime      := true;
      Pex^.xoffset       := 200;
      Pex^.ColorImage    := YELLOW;
      Pex^.ColorMarked   := LIGHTGREEN;
      Pex^.BoldMarked    := true;
    end_if;
  end_if;

  if(Pex <> NIL) then
    Pex^.WidthName    := PixelWidthName.Read();
    Pex^.WidthDate    := PixelWidthDate.Read();
    Pex^.WidthTime    := PixelWidthTime.Read();
    Pex^.WidthSize    := PixelWidthFileSize.Read();
    Pex^.SortCriteria := to_udint(SortCriteria.Read());
  end_if;
  
  UpdateWholeTree();
  DoActPath(true);

END_FUNCTION

FUNCTION _FileExplorer::GetAsciiText
	VAR_INPUT
		dst 	: ^CHAR;
		psrc 	: ^String;
    dstmaxlen : udint;
	END_VAR
  VAR
  	tmp : array[0..500] of char;
    len : udint;
  END_VAR

  dst^ := 0;
  len  := psrc^.GetLength();
  
  if(len > 0) then
    psrc^.GetDataAt(#tmp[0], 2, 0);
    
    if(len > 1) then
      if((tmp[0] = 0) & (tmp[1] = 2)) then
        psrc^.GetDataAt(#tmp[0], len, 0);
        tmp[len]   := 0;
        tmp[len+1] := 0;
        if(Strlen(#tmp[0], 2) < dstmaxlen) then
          StrCpy(dst, sizeof(char), #tmp[2], 2);
        end_if;
        
        return;
      end_if;
    end_if;
  
    psrc^.GetDataAt(#tmp[0], len, 0);
    tmp[len] := 0;
    
    if(Strlen(#tmp[0], sizeof(char)) < dstmaxlen) then
      StrCpy(dst, sizeof(char), #tmp[0], sizeof(char));
    end_if;
    
  end_if;  

END_FUNCTION

FUNCTION _FileExplorer::SetStringText
	VAR_INPUT
		pdst 	: ^String;
		psrc 	: ^void;
    chrsize : uint;
	END_VAR
  VAR
    len : udint;
    tmp : array[0..999] of char;
  END_VAR

  if(psrc = NIL) then
    psrc    := "";
    chrsize := 1;
  end_if;
  
  if(chrsize > 1) then
    len := Strlen(psrc, 2) + 1;
    len *= 2;
    _memcpy(#tmp[2], psrc, len);
    tmp[0] := 0;
    tmp[1] := 2;
    psrc   := #tmp[0];
  else
    len := Strlen(psrc, 1) + 1;
  end_if;  
  
  pdst^.WriteDataOff(len, 0, psrc$^usint);
  
END_FUNCTION

FUNCTION _FileExplorer::InitiateErrorConfirm
	VAR_INPUT
		txtid 	: UDINT;
		txtext 	: ^void;
		txtextchrsize 	: uint;
	END_VAR
  VAR
  	txt : ^char;
  	chrsize : uint;
    tmpstr : array[0..499] of _CHAR;
  END_VAR
  
  Mux.SectionStart(); // *************************************************************
  GetDescriptionText(#txt, #chrsize, txtid);

  InSelIs    := SELIS_NONE;
  InLine     := 0;
  InCmd      := FEXEC_IDLE;
  InNameCrc  := NameInput.GetCRC();
  ExecuteCmd := FEXEC_IDLE;

  if(txt <> NIL) then
    if(txtext <> NIL) then
      StrCpy(#tmpstr[0], sizeof(_CHAR), txt, chrsize);
      StrCat(#tmpstr[0], sizeof(_CHAR), "|", sizeof(_ASCII));
      StrCat(#tmpstr[0], sizeof(_CHAR), txtext, txtextchrsize);
      txt     := #(tmpstr[0]$char);
      chrsize := sizeof(_CHAR);
    end_if;  
  
    ErrorWindow := ErrorWindow.Read();
    if(Prj_GetEntryByNo(ErrorWindow$uint, _PE_WINDOW) <> NIL) then
      SetStringText(DescriptionText.pCmd, txt, chrsize);
      InsertCmd(CMD_NEWWINDOW, ErrorWindow, 0);
    else
      MessageBoxCall(txt, chrsize, Font, MESSAGEBOXTYP_OK, this, NIL);
    end_if;
  end_if;
  Mux.SectionStop(); // **************************************************************
  
END_FUNCTION

FUNCTION _FileExplorer::InitiateQuestionConfirm
	VAR_INPUT
		dpne 	: ^CHAR;
		selis 	: _SELIS;
		linepos 	: DINT;
		cmd 	: UDINT;
		txtid 	: UDINT;
	END_VAR
  VAR
    tmpstr : array[0..512] of char;
  	txt : ^char;
  	chrsize : uint;
  END_VAR
  
  GetDescriptionText(#txt, #chrsize, txtid);

  if(#InDPNE[0] <> dpne) then
    InDPNE[0] := 0;
    if(dpne <> NIL) then
      StrCpy(#InDPNE[0], sizeof(char), dpne, sizeof(char));
    end_if;
  end_if;
  
  InSelIs     := selis;
  InLine      := linepos;
  InCmd       := cmd;
  InNameCrc   := NameInput.GetCRC();
  ExecuteCmd  := FEXEC_IDLE;
  ExecuteLine := linepos;
  
  StrCpy(#tmpstr[0], sizeof(char), txt, sizeof(char));
  filexplo_make_user_path(#tmpstr[StrLen(#tmpstr[0], sizeof(char))], Pex, #InDPNE[0]);

  ConfirmWindow := ConfirmWindow.Read();
  if(Prj_GetEntryByNo(ConfirmWindow$uint, _PE_WINDOW) <> NIL) & (txt <> NIL) then
//    ExecuteCmd  := FEXEC_IDLE;
//    ExecuteLine := linepos;
//    StrCpy(#tmpstr[0], sizeof(char), txt, sizeof(char));
//    filexplo_make_user_path(#tmpstr[StrLen(#tmpstr[0], sizeof(char))], Pex, #InDPNE[0]);
    SetStringText(DescriptionText.pCmd, #tmpstr[0], chrsize);
    InsertCmd(CMD_NEWWINDOW, ConfirmWindow, 0);
  else
    MessageBoxCall(#tmpstr[0], chrsize, Font, MESSAGEBOXTYP_OK_CANCLE, this, #MessageBoxResultIntern());
    
//    ExecuteCmd  := cmd;
//    ExecuteLine := linepos;
  end_if;
END_FUNCTION

FUNCTION _FileExplorer::GetSaveAsName
  VAR_OUTPUT
    retcode : ^char;
  END_VAR
  VAR
  	pos : uint;
  END_VAR

  retcode := "[NewFileName]";
  
  // sa27246 begin
  GetAsciiText(#TmpName[0], ActFileName.pCmd, sizeof(TmpName));
  if(TmpName[0] <> 0) then
    if(CheckName(#TmpName[0]) = true) then // is valid filename
      pos := StrChr(#TmpName[0], '.', sizeof(char));
      if(pos < StrLen(#TmpName[0], sizeof(char))) then
        TmpName[pos] := 0; // kill extention
      end_if;
      retcode := #TmpName[0];
      AcknowledgeFlag(1); // sa27246: activate acknowledgeflag
    end_if;
  end_if;
  // sa27246 end
 
END_FUNCTION

FUNCTION _FileExplorer::InitiateNameInput
	VAR_INPUT
		dpne 	: ^CHAR;
		selis 	: _SELIS;
		linepos 	: DINT;
		cmd 	: UDINT;
		txtid 	: UDINT;
	END_VAR
  VAR
    txt : ^char;
    chrsize : uint;
    oldname : ^char;
  END_VAR

  InLine    := linepos;
  InSelIs   := selis;
  InCmd     := cmd;

  AcknowledgeFlag(0); // sa27246: deactivate acknowledgeflag

  // vorsicht: reihenfolge der einzelnen zeilen beibehalten
  StrCpy(#InDPNE[0], sizeof(char), dpne, sizeof(char));
  if(cmd = FEXEC_MAKEDIR1) then
    oldname := "[NewDirName]";
  elsif(cmd = FEXEC_SAVE1) then
    oldname := GetSaveAsName();//"[NewFileName]"; 
  else
    oldname := GetPathName(linepos, #selis);
    oldname := GetLastToken(oldname);
    if((oldname = NIL) | (oldname^ = 0)) then
      oldname := "[NoName]";
    end_if;
  end_if;
  
  GetDescriptionText(#txt, #chrsize, txtid);
  SetStringText(DescriptionText.pCmd, txt, chrsize);
  SetStringText(NameInput.pCmd, oldname, sizeof(char));
  InNameCrc := NameInput.GetCRC();
  
//  GetDescriptionText(#txt, #chrsize, txtid);
//  SetStringText(DescriptionText.pCmd, txt, chrsize);
//  SetStringText(NameInput.pCmd, "NoName", sizeof(char));
//  InNameCrc := NameInput.GetCRC();
//  StrCpy(#InDPNE[0], sizeof(char), dpne, sizeof(char));
//  InLine    := linepos;
//  InSelIs   := selis;
//  InCmd     := cmd;
  
  ExecuteCmd  := FEXEC_IDLE;
  ExecuteLine := linepos;
  
  InsertCmd(CMD_EDITSERVER_HID_WIN_EDITOR, VarNoName$dint, _WIN_EDITOR_ANUMFILEX);

END_FUNCTION

FUNCTION _FileExplorer::GetPathNameCut
	VAR_INPUT
		line 	: DINT;
		pselis 	: ^_SELIS;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^CHAR;
	END_VAR

  retcode := GetPathName(line, pselis);
  if(retcode <> NIL) then
    if(pselis^ = SELIS_FILE) then
      StrCutLastTokenAndReturn(retcode, retcode);
    end_if;
    return;
  end_if;

  retcode := NIL;

END_FUNCTION

FUNCTION _FileExplorer::GetPathName
	VAR_INPUT
		line 	: DINT;
		pselis 	: ^_SELIS;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^CHAR;
	END_VAR

  retcode := filexplo_path(Pex, pselis, line, false);
  if(retcode <> NIL) then
    if(retcode^ <> 0) then
      return;
    end_if;
  end_if;

  retcode := NIL;

END_FUNCTION

FUNCTION _FileExplorer::CheckName
	VAR_INPUT
		txt 	: ^char;
	END_VAR
  VAR_OUTPUT
    retcode : bool;
  END_VAR
  VAR
  	len : uint;
  END_VAR

  retcode := true;
  
  len := Strlen(txt, sizeof(char));
  while len do
    if(txt^ < 46)|(txt^ > 127)|(txt^ = '?') then
      if(txt^ <> 32) then // sa27246
        txt^:= 'x';
        retcode := false;
      end_if;
    end_if;
    txt += 1;
    len -= 1;
  end_while;

END_FUNCTION

FUNCTION _FileExplorer::MakeName
  VAR_INPUT
    name : ^char;
    filefilter : ^char;
  END_VAR
  VAR_OUTPUT
    retcode : bool;
  END_VAR
  VAR
    pos : uint;
    ph : ^char;
  END_VAR
  
  retcode := false;
  
  if(name^ <> 0) then
    if(filefilter <> NIL) then
      if(StrCmp(filefilter, sizeof(_ASCII), "*.*", sizeof(_ASCII)) <> 0) then
        // nur wenn nicht *.*
        pos := StrChr(name, '.', sizeof(char));
        if(pos < Strlen(name, sizeof(char))) then
          ph := name + pos;
          ph^:= 0;
        end_if;
      end_if;
         
      pos := StrChr(filefilter, '.', sizeof(char));
      if(pos >= StrLen(filefilter, sizeof(char))) then
        pos := 0;
      end_if;
      ph := filefilter + pos;
      if((ph$^uint^ <> 16#2A2E) & (ph$^uint^ <> 16#3F2E)) then // ".*" & ".?"
        StrCat(name, sizeof(char), ph, sizeof(char));
      end_if;
    end_if;

    retcode := CheckName(name);
  end_if;

END_FUNCTION

FUNCTION _FileExplorer::ExecuteRenameIntern
	VAR_INPUT
		stp 	: dint;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    selis : _SELIS;
    dpne : ^char;
    tmpnam : array[0.._MAX_PATHLENGTH] of char;
  END_VAR

  retcode := false;

  if(stp = 0) then // input name
    dpne := GetPathNameCut(ExecuteLine, #selis);
    if(dpne <> NIL) then
      InitiateNameInput(dpne, SELIS_DIRECTORY, ExecuteLine, FEXEC_RENAME1, INPUT_NEWFILENAME);
    end_if;
  else
    if(InSelIs = SELIS_DIRECTORY) then
      GetAsciiText(#tmpnam[0], NameInput.pCmd, sizeof(tmpnam));
      if(MakeName(#tmpnam[0], Pex^.FileFilter) = true) then
        StrCat(#InDPNE[0], sizeof(char), #tmpnam[0], sizeof(char));
        if(FileExist(#InDPNE[0]) = true) then
          InitiateErrorConfirm(ERROR_RENAME_NAMEALREADYEXIST, #InDPNE[0], sizeof(_ASCII));
        else    
          retcode := ExecuteRename(#InDPNE[0], true, InLine);
        end_if;
      else
        InitiateErrorConfirm(ERROR_RENAME_INVALIDNAME, NIL, 0);
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION _FileExplorer::ExecuteSaveIntern
	VAR_INPUT
		stp 	: dint;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    selis : _SELIS;
    tmpnam : array[0.._MAX_PATHLENGTH] of char;
    dpne : ^char;
  END_VAR

  retcode := false;

  if(stp = 0) then // input name
    dpne := GetPathNameCut(ExecuteLine, #selis);
    if(dpne <> NIL) then
      InitiateNameInput(dpne, SELIS_DIRECTORY, ExecuteLine, FEXEC_SAVE1, INPUT_NEWFILENAME);
    end_if;
  elsif(stp = 1) then
    if(InSelIs = SELIS_DIRECTORY) then
      GetAsciiText(#tmpnam[0], NameInput.pCmd, sizeof(tmpnam));
      if(MakeName(#tmpnam[0], Pex^.FileFilter) = true) then
        StrCat(#InDPNE[0], sizeof(char), #tmpnam[0], sizeof(char));
        if(FileExist(#InDPNE[0]) = true) then
          //InitiateQuestionConfirm(#tmpnam[0], SELIS_FILE, InLine, FEXEC_SAVE2, CONFIRM_ALREADYEXIST_OVERWRITE);
          InitiateQuestionConfirm(#InDPNE[0], SELIS_FILE, InLine, FEXEC_SAVE2, CONFIRM_ALREADYEXIST_OVERWRITE);
        else    
          retcode := ExecutePreSave(#InDPNE[0], true, InLine);
        end_if;
      else
        InitiateErrorConfirm(ERROR_SAVE_INVALIDNAME, NIL, 0);
      end_if;
    end_if;
  elsif(InSelIs = SELIS_FILE) then
    retcode := ExecutePreSave(#InDPNE[0], true, InLine);
  end_if;

  if(retcode = true) then
    ExecuteUpdate(InLine);
  end_if;
  
END_FUNCTION


FUNCTION _FileExplorer::ExecuteOverwriteIntern
	VAR_INPUT
		stp 	: dint;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    selis : _SELIS;
    dpne : ^char;
  END_VAR

  retcode := false;

  if(stp = 0) then
    dpne := GetPathName(ExecuteLine, #selis);
    if((dpne <> NIL) & (selis = SELIS_FILE)) then
      if(FileExist(dpne) = true) then
        InitiateQuestionConfirm(dpne, SELIS_FILE, ExecuteLine, FEXEC_OVERWRITE1, CONFIRM_ALREADYEXIST_OVERWRITE);
      end_if;
    end_if;
  elsif(InSelIs = SELIS_FILE) then
    if(ExecutePreSave(#InDPNE[0], true, InLine) = true) then
      retcode := true;
      ExecuteUpdate(InLine);
    end_if;
  end_if;

END_FUNCTION

FUNCTION _FileExplorer::ExecuteMarkIntern
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    selis : _SELIS;
		dpne 	: ^CHAR;
  END_VAR
  
  retcode := false;
  if(IsFocusGiven() = true) then
    dpne := GetPathName(ExecuteLine, #selis);
    if(dpne <> NIL) then
      retcode := ExecuteMark(dpne, selis, ExecuteLine);
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION _FileExplorer::ExecuteMakeDirectoryIntern
	VAR_INPUT
    stp : dint;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    selis : _SELIS;
    dpne : ^char;
    tmpnam : array[0.._MAX_PATHLENGTH] of char;
    tmpstr : array[0.._MAX_PATHLENGTH] of char;
  END_VAR

  retcode := false;

  if(stp = 0) then // input name
    if(IsFocusGiven() = true) then
      dpne := GetPathNameCut(ExecuteLine, #selis);
      if(dpne <> NULL) then
        InitiateNameInput(dpne, SELIS_DIRECTORY, ExecuteLine, FEXEC_MAKEDIR1, INPUT_NEWDIRECTORYNAME);
      end_if;
    end_if;
  elsif(InSelIs = SELIS_DIRECTORY) then
    GetAsciiText(#tmpnam[0], NameInput.pCmd, sizeof(tmpnam));
    CheckName(#tmpnam[0]);
    if(tmpnam[0] <> 0) then
      StrCpy(#tmpstr[0], sizeof(char), #InDPNE[0], sizeof(char));
      StrCat(#tmpstr[0], sizeof(char), #tmpnam[0], sizeof(char));
      retcode := ExecuteMakeDirectory(#tmpstr[0], false, InLine);
    else
      InitiateErrorConfirm(ERROR_DELETE_INVALIDNAME, NIL, 0);
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION _FileExplorer::ExecuteDeleteIntern
	VAR_INPUT
		stp 	: dint;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	dpne : ^char;
    selis : _SELIS;
    att : udint;
  END_VAR

  retcode := false;

  if(stp = 0) then
    if(IsFocusGiven() = true) then
      dpne := GetPathName(ExecuteLine, #selis);
      if(dpne <> NIL) then
        if(selis = SELIS_FILE) then
          att := filexplo_getattrib(Pex, ExecuteLine);
          if(att and (_DDE_HIDDEN or _DDE_RDLY or _DDE_SYSTEM)) then
            InitiateErrorConfirm(ERROR_DELETE_NOTRDLY, NIL, 0);
          else
            InitiateQuestionConfirm(dpne, SELIS_FILE, ExecuteLine, FEXEC_DELETE1, CONFIRM_DELETEFILE);
          end_if;
        elsif(selis = SELIS_DIRECTORY) then
          InitiateQuestionConfirm(dpne, SELIS_DIRECTORY, ExecuteLine, FEXEC_DELETE1, CONFIRM_DELETEDIR);
        else
          InitiateErrorConfirm(ERROR_DELETE_NOTPOSSIBLE, NIL, 0);
        end_if;
      end_if;
    end_if;
  elsif((InSelIs = SELIS_FILE) | (InSelIs = SELIS_DIRECTORY)) then
    retcode := ExecuteDelete(#InDPNE[0], InSelIs, InLine);
  end_if;
  
END_FUNCTION

FUNCTION _FileExplorer::ExecuteLoadIntern
	VAR_INPUT
		stp 	: dint;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	dpne : ^char;
    selis : _SELIS;
  END_VAR

  retcode := false;

  if(stp = 0) then
    if(IsFocusGiven() = true) then
      dpne := GetPathName(ExecuteLine, #selis);
      if(dpne <> NIL) then
        if(selis = SELIS_FILE) then
          InitiateQuestionConfirm(dpne, SELIS_FILE, ExecuteLine, FEXEC_LOAD1, CONFIRM_LOADFILE);
        else
          InitiateErrorConfirm(ERROR_LOAD_NOTAFILE, NIL, 0);
        end_if;
      end_if;
    end_if;
  elsif(InSelIs = SELIS_FILE) then
    retcode := ExecutePreLoad(#InDPNE[0], true, InLine);
  end_if;

END_FUNCTION

FUNCTION _FileExplorer::ExecutePasteIntern
	VAR_INPUT
		stp 	: dint;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	dpne : ^char;
    selis : _SELIS;
  END_VAR

  retcode := false;

  if(stp = 0) then
    if(IsFocusGiven() = true) then
      if(Pex^.Tree.markedlines <> 0) then
        dpne := GetPathNameCut(ExecuteLine, #selis);
        if(dpne <> NIL) then
          if(filexplo_file_dir_copy_check(Pex, dpne) = true) then
            InitiateQuestionConfirm(dpne, SELIS_NONE, ExecuteLine, FEXEC_PASTE1, CONFIRM_COPYITEM);
          else
            InitiateErrorConfirm(ERROR_SRCDST_INTERSECT, NIL, 0);
          end_if;
        end_if;
      else
        InitiateErrorConfirm(ERROR_PASTE_NOITEMSELECTED, NIL, 0);
      end_if;
    end_if;
  elsif(InSelIs = SELIS_NONE) then
    retcode := ExecutePaste(#InDPNE[0], InLine);
  end_if;
  
END_FUNCTION

FUNCTION _FileExplorer::ExecuteUpdateIntern
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := ExecuteUpdate(InLine);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecuteMark
	VAR_INPUT
		dpne 	: ^CHAR;
		selis 	: _SELIS;
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	dom : bool;
  END_VAR

  retcode := false;
  if((selis = SELIS_FILE) | (selis = SELIS_DIRECTORY)) then
  
    dom := filexplo_is_marked(Pex, linepos);
  
    // delete possibly previous done mark
    if(ExecuteUnMark() = true) then
      retcode := true;
    end_if;
    
    if(dom = false) then
      // mark line
      if(filexplo_ctrlc(Pex, linepos) = true) then
        retcode := true;
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecuteUnMark
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := filexplo_xctrlc(Pex);

END_FUNCTION

FUNCTION _FileExplorer::BusyPush

  Mux.SectionStart(); // *************************************************************
   IsBusy       += 1;
   IsBusySignal := 1;
  Mux.SectionStop(); // **************************************************************

END_FUNCTION

FUNCTION _FileExplorer::BusyPop

  Mux.SectionStart(); // *************************************************************
   if(IsBusy > 0) then
     IsBusy -= 1;
     if(IsBusy = 0) then
       IsBusySignal := 0;
     end_if;
   end_if;
  Mux.SectionStop(); // **************************************************************
  
END_FUNCTION

FUNCTION GLOBAL _FileExplorer::ExecuteAsyncDeleteCallBack
	VAR_INPUT
		pline 	: ^_Thread2CmdLine;
		result 	: BOOL;
	END_VAR

  BusyPop(); // reset busy
  if(result = false) then
    InitiateErrorConfirm(ERROR_DELETE_FAILED, #pline^.op1[0], sizeof(_ASCII));
    ExecuteCmd := FEXEC_PANIC;
    // update geht nicht weil die aktuelle zeile bereits gelscht ist
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecuteDelete
	VAR_INPUT
		dpne 	: ^CHAR;
		selis 	: _SELIS;
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	cmd : _Thread2CmdLine;
  END_VAR

  retcode := false;
  if((selis = SELIS_FILE) | (selis = SELIS_DIRECTORY)) then
  
    init_Thread2CmdLine(#cmd);
    
    if(selis = SELIS_FILE) then
      cmd.cmd := T2_DELETE_FILE;
    elsif(selis = SELIS_DIRECTORY) then
      cmd.cmd := T2_DELETE_DIRECTORY;
    end_if;
    
    StrCpy(#cmd.op1[0], sizeof(_ASCII), dpne, sizeof(_ASCII));
    cmd.pthis     := this;
    cmd.pcallback := #ExecuteAsyncDeleteCallBack();
    cmd.user1     := Scroll.position.pos;
    
    BusyPush(); // set busy
    if(Thread2_AddCmd(#cmd) = true) then // async kommando absetzen
      retcode := filexplo_delete_treeentry(Pex, #Scroll.position); // eintrag nur aus liste lschen
    else
      BusyPop(); // reset busy
      retcode := filexplo_delete(Pex, #Scroll.position); // file/direct und eintrag aus liste lschen
    end_if;
    
  end_if;
  
END_FUNCTION

FUNCTION __CDECL GLOBAL _FileExplorer::ExecuteAsyncPasteCallBack
	VAR_INPUT
		pline 	: ^_Thread2CmdLine;
		result 	: BOOL;
	END_VAR

  BusyPop(); // reset busy
  if(result = false) then
    InitiateErrorConfirm(ERROR_PASTE_FAILED, #pline^.op2[0], sizeof(_ASCII));
    ExecuteCmd := FEXEC_PANIC;
  else
    ExecuteLine := pline^.user1;
    ExecuteCmd  := FEXEC_UPDT;
  end_if;

END_FUNCTION

FUNCTION __CDECL GLOBAL ExePst
  VAR_INPUT
    dst : ^char;
    pdstselis : ^_SELIS;
    dpne : ^char;
    selis : _SELIS;
    user : udint;
  END_VAR
  VAR_OUTPUT
    retcode : bool;
  END_VAR

  if(pdstselis^ =  SELIS_NONE) then
    pdstselis^ := selis;
    StrCpy(dst, sizeof(_ASCII), dpne, sizeof(_ASCII));
  end_if;  

  retcode := true;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecutePaste
	VAR_INPUT
		dpne 	: ^CHAR;
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    selis : _SELIS;
    tmp : array[0.._MAX_PATHLENGTH] of char;
    cmd : _Thread2CmdLine;
    ne : ^char;
  END_VAR

  retcode := false;
  
  selis := SELIS_NONE;
  if(filexplo_scanmarked(Pex, #ExePst(), #tmp[0], #selis) = true) then
    init_Thread2CmdLine(#cmd);

    StrCpy(#cmd.op1[0], sizeof(_ASCII), dpne, sizeof(_ASCII));
    StrCpy(#cmd.op2[0], sizeof(_ASCII), #tmp[0], sizeof(_ASCII));
   
    if(selis = SELIS_FILE) then
      cmd.cmd := T2_COPY_FILE;
      DelTokenEnd(#cmd.op2[0]);
      ne := GetLastToken(#cmd.op2[0]);
      AddTokenEnd(#cmd.op1[0]);
      StrCat(#cmd.op1[0], sizeof(_ASCII), ne, sizeof(_ASCII));
    elsif(selis = SELIS_DIRECTORY) then
      if(Pex^.FileFilter <> NIL) then
        AddTokenEnd(#cmd.op2[0]);
        StrCat(#cmd.op2[0], sizeof(_ASCII), Pex^.FileFilter, sizeof(_ASCII));
      end_if; 
      cmd.cmd := T2_COPY_DIRECTORY;
    end_if;
  
    cmd.pthis     := this;
    cmd.pcallback := #ExecuteAsyncPasteCallBack();
    cmd.user1     := Scroll.position.pos;
    
    BusyPush(); // set busy
    if(Thread2_AddCmd(#cmd) = true) then // async kommando absetzen
      retcode := ExecuteUnMark(); // markierung aufheben
      return;
    end_if;
    BusyPop(); // reset busy
  end_if;
  
  if(filexplo_ctrlv(Pex, dpne) = true) then // copy file
    ExecuteUnMark(); // unmark
    ExecuteUpdate(linepos); // update
    retcode := true;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecuteMakeDirectory
	VAR_INPUT
		dpne 	: ^CHAR;
		isfile 	: bool;
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;
  
  if(isfile = false) then
    if(CheckCreateDirectory(dpne) = true) then
      retcode := ExecuteUpdate(linepos);
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecuteUpdate
	VAR_INPUT
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	st : bool;
  END_VAR

  retcode := false;
  
  st := false;
  if(filexplo_can_open(Pex, linepos) = true) then
    st := true;
  end_if;
  
  if(filexplo_update(Pex, #Scroll.position) = true) then
    if(st = true) then
      filexplo_enter(Pex, #Scroll.position);
    end_if;
    retcode := true;
  end_if;
  
END_FUNCTION

#pragma warning (disable: 73)
FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecuteLoad
	VAR_INPUT
		dpne 	: ^CHAR;
		isfile 	: bool;
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecuteSave
	VAR_INPUT
		dpne 	: ^CHAR;
		isfile 	: bool;
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;

END_FUNCTION
#pragma warning (default: 73)

FUNCTION VIRTUAL _FileExplorer::ExecutePreLoad
	VAR_INPUT
		dpne 	: ^CHAR;
		isfile 	: BOOL;
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := ExecuteLoad(dpne, isfile, linepos);
  if(retcode = true) then
    SetStringText(ActFileName.pCmd, GetLastToken(dpne), sizeof(char));  
  end_if;

END_FUNCTION

FUNCTION VIRTUAL _FileExplorer::ExecutePreSave
	VAR_INPUT
		dpne 	: ^CHAR;
		isfile 	: BOOL;
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := ExecuteSave(dpne, isfile, linepos);
  if(retcode = true) then
    SetStringText(ActFileName.pCmd, GetLastToken(dpne), sizeof(char));  
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecuteRename
	VAR_INPUT
		newname 	: ^CHAR;
		isfile 	: BOOL;
		linepos 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	selis : _SELIS;
    oldname : ^char;
  END_VAR

  retcode := false;
  if(isfile = true) then
    oldname := GetPathName(linepos, #selis);
    if(selis = SELIS_FILE) then
      retcode := filexplo_rename(Pex, oldname, newname, linepos);
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::ExecutePanic
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  Pex := filexplo_end(Pex);
  PerformInit();
  ActPos := Scroll.position.pos; // actualize server
  retcode := true;
//  _ScrollArea2::OutPage();       // out page      
  
END_FUNCTION

FUNCTION _FileExplorer::IsFocusGiven
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := Focus;
  if(retcode = false) then
    InitiateErrorConfirm(ERROR_FOCUSNOTGIVEN, NIL, 0);
  end_if;

END_FUNCTION

FUNCTION __CDECL GLOBAL _FileExplorer::MessageBoxResultIntern
	VAR_INPUT
		messboxres 	: _MESSAGEBOXRESULT;
	END_VAR
  
  MessageBoxResult(messboxres);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::MessageBoxResult
	VAR_INPUT
		messboxres 	: _MESSAGEBOXRESULT;
	END_VAR

  if(messboxres = MESSAGEBOXRESULT_OK) | (messboxres = MESSAGEBOXRESULT_YES) then
    ConfirmYes := 1;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _FileExplorer::GetDescriptionText
	VAR_INPUT
		ptxt 	: ^pVoid;
		pchrsize 	: ^UINT;
		txtid 	: UDINT;
	END_VAR
  VAR
    alanguage : _LOCAL;
  END_VAR
 
  ptxt^     := NIL;
  pchrsize^ := 1;
  alanguage := Language_GetActualLocal();
 
  if(alanguage = LOCAL_GERMAN) then
    case txtid of
      ERROR_SAVE_INVALIDNAME :
        ptxt^ := "Ungltiger Name|File kann nicht gespeichert werden!";
      ERROR_RENAME_INVALIDNAME :
        ptxt^ := "Ungltiger Name|File kann nicht umbenannt werden!";
      ERROR_RENAME_NAMEALREADYEXIST :
        ptxt^ := "Name bereits vorhanden|File kann nicht umbenannt werden!";
      ERROR_DELETE_INVALIDNAME :
        ptxt^ := "Ungltiger Name|Verzeichnis kann nicht erstellt werden!";
      ERROR_DELETE_NOTPOSSIBLE :
        ptxt^ := "Es knnen nur Files oder|Verzeichnisse gelscht werden!";
      ERROR_DELETE_NOTRDLY :
        ptxt^ := "Geschtztes File kann nicht gelscht werden!";
      ERROR_LOAD_NOTAFILE :
        ptxt^ := "Es knnen nur Files geladen werden!";
      ERROR_SRCDST_INTERSECT :
        ptxt^ := "Kopiervorgang kann nicht ausgefhrt werden,|berschneidung von Source und Destination!";
      ERROR_PASTE_NOITEMSELECTED :
        ptxt^ := "Keine Selektion zum Kopieren vorhanden!";
      ERROR_FOCUSNOTGIVEN :
        ptxt^ := "Aktion kann nicht ausgefhrt werden,|keine Selektion vorhanden!";
      ERROR_DELETE_FAILED :
        ptxt^ := "Kann nicht gelscht werden!";
      ERROR_PASTE_FAILED :
        ptxt^ := "Kann nicht kopiert werden!";
        
      CONFIRM_ALREADYEXIST_OVERWRITE :
        ptxt^ := "File existiert bereits!|Soll bestehendes File berschrieben werden?|";
      CONFIRM_DELETEFILE :
        ptxt^ := "Soll File gelscht werden?|";
      CONFIRM_DELETEDIR :
        ptxt^ := "Soll Verzeichnis samt allen|Unterverzeichnissen gelscht werden?|";
      CONFIRM_LOADFILE :
        ptxt^ := "Soll File geladen werden?|";
      CONFIRM_COPYITEM :
        ptxt^ := "Soll Selektion kopiert werden nach|";
      
      INPUT_NEWFILENAME :
        ptxt^ := "Neuer Filename:";
      INPUT_NEWDIRECTORYNAME :
        ptxt^ := "Neuer Verzeichnisname:";
    end_case;
  elsif(alanguage = LOCAL_DUTCH) then
    case txtid of
      ERROR_SAVE_INVALIDNAME :
        ptxt^ := "Kan bestand niet opslaan,|ongeldige naam gebruikt!";
      ERROR_RENAME_INVALIDNAME :
        ptxt^ := "Kan bestand niet hernoemen,| ongeldige naam gebruikt!";
      ERROR_RENAME_NAMEALREADYEXIST :
        ptxt^ := "Kan bestand niet hernoemen,|naam is reeds ingebruik!";
      ERROR_DELETE_INVALIDNAME :
        ptxt^ := "Kan folder niet aanmaken,|ongeldige naam gegeven!";
      ERROR_DELETE_NOTPOSSIBLE :
        ptxt^ := "Kan niet wissen,|selectie is geen bestand of folder!";
      ERROR_DELETE_NOTRDLY :
        ptxt^ := "Bestand is beveiligd kan niet worden gewist!";
      ERROR_LOAD_NOTAFILE :
        ptxt^ := "Kan niet worden geladen,|selectie is geen bestand!";
      ERROR_SRCDST_INTERSECT :
        ptxt^ := "Geen onderwerp geselecteerd,|bron en doel overlappen!";
      ERROR_PASTE_NOITEMSELECTED :
        ptxt^ := "Geen onderwerp om in te voegen gegeven!";
      ERROR_FOCUSNOTGIVEN :
        ptxt^ := "Kan actie niet uitvoeren,|niets geselecteerd!";
      ERROR_DELETE_FAILED : 
        ptxt^ := "Kan niet wissen!";
      ERROR_PASTE_FAILED :
        ptxt^ := "Kan niet toevoegen!";
        
      CONFIRM_ALREADYEXIST_OVERWRITE :
        ptxt^ := "Bestand bestaat al!|Wilt U overschrijven?|";
      CONFIRM_DELETEFILE :
        ptxt^ := "Wilt U bestand wissen?|";
      CONFIRM_DELETEDIR :
        ptxt^ := "Wilt U folder wissen|inclusief alle onderliggende folders?|";
      CONFIRM_LOADFILE :
        ptxt^ := "Wilt U bestand laden?|";
      CONFIRM_COPYITEM :
        ptxt^ := "Wilt U selectie toevoegen bij|";
      
      INPUT_NEWFILENAME :
        ptxt^ := "Voer naam van nieuw bestand in:";
      INPUT_NEWDIRECTORYNAME :
        ptxt^ := "Voer naam van nieuwe folder in:";
    end_case;
  elsif(alanguage = LOCAL_SPANISH) then
    case txtid of
      ERROR_SAVE_INVALIDNAME :
        ptxt^ := "Nombre no valido|Archivo no puede ser grabado!";
      ERROR_RENAME_INVALIDNAME :
        ptxt^ := "Nombre no valido|Archivo no puede ser renombrado!";
      ERROR_RENAME_NAMEALREADYEXIST :
        ptxt^ := "Nombre ya existe|Archivo no puede ser renombrado!";
      ERROR_DELETE_INVALIDNAME :
        ptxt^ := "Nombre no valido|Directorio no puede ser creado!";
      ERROR_DELETE_NOTPOSSIBLE :
        ptxt^ := "Solo se pueden borrar Archivos|o Directorios!";
      ERROR_DELETE_NOTRDLY :
        ptxt^ := "Archivos protegidos no pueden ser borrados!";
      ERROR_LOAD_NOTAFILE :
        ptxt^ := "Solo se pueden cargar Archivos!";
      ERROR_SRCDST_INTERSECT :
        ptxt^ := "Operacin de copiado no puede ser realizado,|superposicin de la fuente y el destino!";
      ERROR_PASTE_NOITEMSELECTED :
        ptxt^ := "Ninguna seleccin para copiar!";
      ERROR_FOCUSNOTGIVEN :
        ptxt^ := "La Acccin no puede ser realizada,|no hay ninguna seleccin!";
      ERROR_DELETE_FAILED :
        ptxt^ := "No se puede borrar!";
      ERROR_PASTE_FAILED :
        ptxt^ := "No se puede copiar!";
        
      CONFIRM_ALREADYEXIST_OVERWRITE :
        ptxt^ := "El archivo ya existe!.|Tiene que ser el actual Archivo reescrito?|";
      CONFIRM_DELETEFILE :
        ptxt^ := "Quiere borrar el Archivo?|";
      CONFIRM_DELETEDIR :
        ptxt^ := "Quiere borrar el Directorio, asi como|los subdirectorios?|";
      CONFIRM_LOADFILE :
        ptxt^ := "quiere cargar los Archivos?|";
      CONFIRM_COPYITEM :
        ptxt^ := "Lo seleccionado va ha ser copiado despues|";
      
      INPUT_NEWFILENAME :
        ptxt^ := "Nuevo Nombre de Archivo:";
      INPUT_NEWDIRECTORYNAME :
        ptxt^ := "Nuevo Directorio:";
    end_case;
  elsif(alanguage = LOCAL_PORTUGESE) then
    case txtid of
      ERROR_SAVE_INVALIDNAME :
        ptxt^ := "No  possvel salvar o arquivo.|O nome fornecido  invlido!";
      ERROR_RENAME_INVALIDNAME :
        ptxt^ := "No  possvel renomear o arquivo.|O nome fornecido  invlido!";
      ERROR_RENAME_NAMEALREADYEXIST :
        ptxt^ := "No  possvel renomear o arquivo.|O nome fornecido j existe!";
      ERROR_DELETE_INVALIDNAME :
        ptxt^ := "No  possvel criar o diretrio.|O nome fornecido  invlido!";
      ERROR_DELETE_NOTPOSSIBLE :
        ptxt^ := "No  possvel eliminar este item|pois no  um arquivo ou diretrio!";
      ERROR_DELETE_NOTRDLY :
        ptxt^ := "No  possvel eliminar um arquivo protegido!";
      ERROR_LOAD_NOTAFILE :
        ptxt^ := "No  possvel carregar este item.|O item selecionado no  um arquivo!";
      ERROR_SRCDST_INTERSECT :
        ptxt^ := "No  possvel colar a seleo.|H sobreposio entre a origem e o destino!";
      ERROR_PASTE_NOITEMSELECTED :
        ptxt^ := "No h contedo a ser colado!";
      ERROR_FOCUSNOTGIVEN :
        ptxt^ := "A operao no  possvel.|Nenhum item foi selecionado!";
      ERROR_DELETE_FAILED :
        ptxt^ := "No  possvel deletar!";
      ERROR_PASTE_FAILED :
        ptxt^ := "No  possvel colar!";
        
      CONFIRM_ALREADYEXIST_OVERWRITE :
        ptxt^ := "O arquivo j existe!|Deseja sobrescrev-lo?|";
      CONFIRM_DELETEFILE :
        ptxt^ := "Deseja eliminar o arquivo?|";
      CONFIRM_DELETEDIR :
        ptxt^ := "Deseja eliminar o diretrio|incluindo todo o seu contedo?|";
      CONFIRM_LOADFILE :
        ptxt^ := "Deseja carregar o arquivo?|";
      CONFIRM_COPYITEM :
        ptxt^ := "Deseja colar a seleo|";
      
      INPUT_NEWFILENAME :
        ptxt^ := "Digite o nome do arquivo:";
      INPUT_NEWDIRECTORYNAME :
        ptxt^ := "Digite o nome do diretrio:";    
    end_case;
  end_if;
  
  if(ptxt^ = NIL) then // LOCAL_ENGLISH
    case txtid of
      ERROR_SAVE_INVALIDNAME :
        ptxt^ := "Can't save File,|Invalid Name is given!";
      ERROR_RENAME_INVALIDNAME :
        ptxt^ := "Can't rename File,|Invalid Name is given!";
      ERROR_RENAME_NAMEALREADYEXIST :
        ptxt^ := "Can't rename File,|Name is already in use!";
      ERROR_DELETE_INVALIDNAME :
        ptxt^ := "Can't create Directory,|Invalid Name is given!";
      ERROR_DELETE_NOTPOSSIBLE :
        ptxt^ := "Can't delete,|Item is not a File or Directory!";
      ERROR_DELETE_NOTRDLY :
        ptxt^ := "Can't delete protected File!";
      ERROR_LOAD_NOTAFILE :
        ptxt^ := "Can't load,|selected Item is not a File!";
      ERROR_SRCDST_INTERSECT :
        ptxt^ := "Can't paste Selection,|Source and Destination intersects!";
      ERROR_PASTE_NOITEMSELECTED :
        ptxt^ := "No Item to paste is given!";
      ERROR_FOCUSNOTGIVEN :
        ptxt^ := "Can't perform Action,|no Item selected!";
      ERROR_DELETE_FAILED :
        ptxt^ := "Can't delete!";
      ERROR_PASTE_FAILED :
        ptxt^ := "Can't paste!";
        
      CONFIRM_ALREADYEXIST_OVERWRITE :
        ptxt^ := "File already exists!|Do you want to overwrite?|";
      CONFIRM_DELETEFILE :
        ptxt^ := "Do you want to delete File?|";
      CONFIRM_DELETEDIR :
        ptxt^ := "Do you want to delete Directory|including all Subdirectories?|";
      CONFIRM_LOADFILE :
        ptxt^ := "Do you want to load File?|";
      CONFIRM_COPYITEM :
        ptxt^ := "Do you want to paste Selection to|";
      
      INPUT_NEWFILENAME :
        ptxt^ := "Insert Name of new File:";
      INPUT_NEWDIRECTORYNAME :
        ptxt^ := "Insert Name of new Directory:";
    end_case;
  end_if;
  
END_FUNCTION

FUNCTION _FileExplorer::CheckDrivelist
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;

  if(filexplo_drivelist(Pex, false) <> 0) then
    if(RunExecute(FEXEC_PANIC) = true) then
      DoActPath(true);
      _ScrollArea2::OutPage();
    end_if;
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _FileExplorer::Draw
	VAR_INPUT
		pio 	: ^_IO;
		pr 	: ^_RESULT;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR

  retcode := _ScrollArea2::Draw(pio, pr, pv, input);

END_FUNCTION

FUNCTION _FileExplorer::UpdateWholeTree

  Pex := filexplo_updatetree(Pex, #Scroll.position);

END_FUNCTION

FUNCTION VIRTUAL _FileExplorer::CheckUpdate
  VAR
  	soc : udint;
  END_VAR

  if(Pex <> nil) then
    soc := to_udint(SortCriteria.Read());
    if(Pex^.SortCriteria <> soc) then
      if(filexplo_sort(Pex, soc) = _TRUE) then
        filexplo_xctrlc(Pex);
        _ScrollArea2::OutPage();
        DoActPath(true);
      end_if;
    end_if;
  end_if;

END_FUNCTION
