//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
TYPE
#pragma pack(push, 1)
  _11CameraStr : STRUCT
    Optie : DINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _00ProductStr : STRUCT
    _11Camera : _11CameraStr;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _Diag_ClsVersCRC : STRUCT
    ClsName : ARRAY [0..49] OF CHAR;
    ClsRevision : ARRAY [0..9] OF CHAR;
    ClsCRC : UDINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _Diag_IPInfo : STRUCT
    IPAdress : HDINT;
    Subnet : HDINT;
    Gateway : HDINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _Diag_LoaderStruct : STRUCT
    usLoRev : USINT;
    usHiRev : USINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _Diag_ProjectInfo : STRUCT
    ProjectName : ARRAY [0..49] OF CHAR;
    ProjectCRC : UDINT;
    ClassAmount : DINT;
    ClsVersCRC : ARRAY [0..500] OF _Diag_ClsVersCRC;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _Diag_SystemInfo : STRUCT
    PLCType : ARRAY [0..19] OF CHAR;
    OSVersion : ARRAY [0..19] OF CHAR;
    LoaderVersion : _Diag_LoaderStruct;
    SerialNumber : ARRAY [0..19] OF CHAR;
    IPInfo : _Diag_IPInfo;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _DiagErrorCode : STRUCT
    ErrorNr : DINT;
    ErrorCode : DINT;
  END_STRUCT;
#pragma pack(pop)
  _DiagString : ARRAY [0..Diagnostic_MAX_FileFolderString] OF CHAR;
  _FSM_TCP_USER :  //! <Type Comment="stepping switch for TCP/IP connection" Name="_FSM_TCP_USER"/>
  (
    _STATE_INIT_SERVER,
    _STATE_IDLE,  //! <Type Comment="allocate main socket" Name="_FSM_TCP_USER._STATE_IDLE"/>
    _STATE_MAIN_SOCK,  //! <Type Comment="listen for an incoming connection" Name="_FSM_TCP_USER._STATE_MAIN_SOCK"/>
    _STATE_LISTEN,  //! <Type Comment="allocate the send/receive socket" Name="_FSM_TCP_USER._STATE_LISTEN"/>
    _STATE_ACCEPT,  //! <Type Comment="general send and receive state" Name="_FSM_TCP_USER._STATE_ACCEPT"/>
    _STATE_CONNECT,  //! <Type Comment="close main socket" Name="_FSM_TCP_USER._STATE_CONNECT"/>
    _STATE_RECV,  //! <Type Comment="close send/receive socket" Name="_FSM_TCP_USER._STATE_RECV"/>
    _STATE_SHUTDOWN,  //! <Type Comment="ERROR state" Name="_FSM_TCP_USER._STATE_SHUTDOWN"/>
    _STATE_CLOSE_MAIN_SOCK,
    _STATE_CLOSE_SOCK,
    _STATE_ERROR,
    _STATE_ERROR_ALLOCATING_MEMORY,
    _STATE_ERROR_CREATING_MUTEX,
    _STATE_SEND,
    _STATE_READ_RINGBUFFER
  )$UDINT;
  _LMC_DYN_SWLIMITS :  //! <Type Comment="Dynamic software end positions" Name="_LMC_DYN_SWLIMITS"/>
  (
    _LMC_DynSWLimitMin,  //! <Type Comment="Choose minimum dynamic SW end position" Name="_LMC_DYN_SWLIMITS._LMC_DynSWLimitMin"/>
    _LMC_DynSWLimitMax  //! <Type Comment="Choose maximum dynamic SW end position" Name="_LMC_DYN_SWLIMITS._LMC_DynSWLimitMax"/>
  )$UDINT;
  _LMCAXIS_CMDERROR : BDINT  //! <Type Comment="Status flags" Name="_LMCAXIS_CMDERROR"/>
  [
    1 PowerOff,  //! <Type Comment="1 --&gt; Position controller is off" Name="_LMCAXIS_CMDERROR.PowerOff"/>
    2 NoReference,  //! <Type Comment="1 --&gt; The axis is not referenced" Name="_LMCAXIS_CMDERROR.NoReference"/>
    3 HWError,  //! <Type Comment="1 --&gt; Servo hardware error" Name="_LMCAXIS_CMDERROR.HWError"/>
    4 ActPosError,  //! <Type Comment="1 --&gt; Invalid position of the hardware" Name="_LMCAXIS_CMDERROR.ActPosError"/>
    5 ContouringError,  //! <Type Comment="1 --&gt; Tracking limit exceeded" Name="_LMCAXIS_CMDERROR.ContouringError"/>
    6 CommandError,  //! <Type Comment="1 --&gt; Command not allowed or &#13;&#10;within the CNC RTWork cycle more than one command has been set&#13;&#10;" Name="_LMCAXIS_CMDERROR.CommandError"/>
    7 SWMinError,  //! <Type Comment="1 --&gt; Software endswitch minimum active" Name="_LMCAXIS_CMDERROR.SWMinError"/>
    8 SWMaxError,  //! <Type Comment="1 --&gt; Software endswitch maximum active" Name="_LMCAXIS_CMDERROR.SWMaxError"/>
    9 vError,  //! <Type Comment="1 --&gt; Selected speed too high" Name="_LMCAXIS_CMDERROR.vError"/>
    10 aError,  //! <Type Comment="1 --&gt; Selected acceleration / deceleration too high" Name="_LMCAXIS_CMDERROR.aError"/>
    11 HWMinError,  //! <Type Comment="1 --&gt; Hardware endswitch minimum active" Name="_LMCAXIS_CMDERROR.HWMinError"/>
    12 HWMaxError,  //! <Type Comment="1 --&gt; Hardware endswitch maximum active" Name="_LMCAXIS_CMDERROR.HWMaxError"/>
    13 DirError,  //! <Type Comment="1 --&gt; The direction of motion is not allowed" Name="_LMCAXIS_CMDERROR.DirError"/>
    14 EmergencyError,  //! <Type Comment="when Client _LMCSafety.Emergency goes to 1&#13;&#10; 0 -&gt; StopMove&#13;&#10; 1 -&gt; PowerOff" Name="_LMCAXIS_CMDERROR.EmergencyError"/>
    15 ResolutionError,  //! <Type Comment="1 -&gt; An overflow by multiplication with the value of the server: Resolution occurred&#13;&#10;" Name="_LMCAXIS_CMDERROR.ResolutionError"/>
    16 GlobalError,  //! <Type Comment="1 --&gt; Global error" Name="_LMCAXIS_CMDERROR.GlobalError"/>
    17 JError,  //! <Type Comment="1--&gt; Selected jerk is too high or low." Name="_LMCAXIS_CMDERROR.JError"/>
  ];
  _LMCAXIS_CONTROLBITS : BDINT  //! <Type Comment="Control-Bits" Name="_LMCAXIS_CONTROLBITS"/>
  [
    1 SetPowerOn,  //! <Type Comment="Set if the clients &quot;LMCController&quot; and &quot;ActPosition&quot; are not connected or &#13;&#10;the axis is active" Name="_LMCAXIS_CONTROLBITS.SetPowerOn"/>
    2 SetFollowMode,  //! <Type Comment="Set if the axis is in operationmode: &quot;FOLLOW_LMCAXIS&quot;" Name="_LMCAXIS_CONTROLBITS.SetFollowMode"/>
    3 ReadActPosFromController,
    4 CallReadPDO,
  ];
  _LMCAXIS_COUPLE_GEAR_MODE :  //! <Type Comment="Parameter of the methods &quot;CoupleUserPos&quot; and &quot;CoupleProfilePos&quot;" Name="_LMCAXIS_COUPLE_GEAR_MODE"/>
  (
    LMCAXIS_COUPLE_PROFILE_GEAR,  //! <Type Comment="Couple to master with user supplied gearfactor" Name="_LMCAXIS_COUPLE_GEAR_MODE.LMCAXIS_COUPLE_PROFILE_GEAR"/>
    LMCAXIS_COUPLE_PROFILE_NO_GEAR  //! <Type Comment="Couple to master with gearfactor := 1" Name="_LMCAXIS_COUPLE_GEAR_MODE.LMCAXIS_COUPLE_PROFILE_NO_GEAR"/>
  )$UDINT;
  _LMCAXIS_COUPLEERROR :  //! <Type Comment="Errorlist returned by the function: &quot;CoupleGearPolynom&quot;" Name="_LMCAXIS_COUPLEERROR"/>
  (
    LMCAXIS_NO_ERROR_OCCURED,  //! <Type Comment="No Error Occured" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_NO_ERROR_OCCURED"/>
    LMCAXIS_MASTERPOINTER_INVALID,  //! <Type Comment="Pointer to Master-Axis is invalid" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_MASTERPOINTER_INVALID"/>
    LMCAXIS_SELFCOUPLING,  //! <Type Comment="Master-Axis and Slave-Axis are identically - Selfcoupling is not allowed" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_SELFCOUPLING"/>
    LMCAXIS_SOFTWARE_ERROR,  //! <Type Comment="Pointer to Velocity in Data of Master-Axis is invalid" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_SOFTWARE_ERROR"/>
    LMCAXIS_VEL_MASTER_NOT_POSITIVE,  //! <Type Comment="Velocity of Master-Axis is zero or negative" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MASTER_NOT_POSITIVE"/>
    LMCAXIS_PATH_MASTER_NOT_POSITIVE,  //! <Type Comment="Path of Master is zero or negative" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_MASTER_NOT_POSITIVE"/>
    LMCAXIS_PATH_SLAVE_NOT_POSITIVE,  //! <Type Comment="Path of Slave is zero or negative" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SLAVE_NOT_POSITIVE"/>
    LMCAXIS_VEL_MASTER_DEFINITION_ERROR,  //! <Type Comment="Master overrides his maximal allowed velocity (Input-Error)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MASTER_DEFINITION_ERROR"/>
    LMCAXIS_JERK_MAX_DEFINITION_ERROR,  //! <Type Comment="Maximal allowed Jerk of Slave is negative or zero" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_JERK_MAX_DEFINITION_ERROR"/>
    LMCAXIS_ACC_ANNIHILATION_FAILED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: The initial-acceleration / initial-deceleration can not be recuced &#13;&#10;to zero without the fact, that the maximal allowed velocity of the slave is exceeded or the velocitiy of the slave &#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_ANNIHILATION_FAILED_3_5"/>
    LMCAXIS_PATH_SX_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the path of the Spline of 3rd order becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SX_NEGATIVE_3_5"/>
    LMCAXIS_VEL_COUPLE_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the coupling-velocity becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_NEGATIVE_3_5"/>
    LMCAXIS_VEL_COUPLE_EXCEED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the couple-velocity exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_EXCEED_3_5"/>
    LMCAXIS_PATH_SZ_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the path of the spline of 5th order becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SZ_NEGATIVE_3_5"/>
    LMCAXIS_TIME_SZ_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the duration of the spline of 5th order becomes negative (mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TIME_SZ_NEGATIVE_3_5"/>
    LMCAXIS_VEL_MIN_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the minimal velocitiy of the spline of 5th order becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MIN_NEGATIVE_3_5"/>
    LMCAXIS_VEL_MAX_EXCEED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the velocitiy of the spline of 5th order exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MAX_EXCEED_3_5"/>
    LMCAXIS_ACC_MAX_EXCEED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the acceleration of the spline of 5th order exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_MAX_EXCEED_3_5"/>
    LMCAXIS_JERK_MAX_SLAVE_EXCEED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the jerk of the spline of 5th order exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_JERK_MAX_SLAVE_EXCEED_3_5"/>
    LMCAXIS_ACC_ANNIHILATION_FAILED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: The initial-acceleration / initial-deceleration can not &#13;&#10;be recuced to zero without the fact, that the maximal allowed velocity of the slave is exceeded or the velocitiy of the slave &#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_ANNIHILATION_FAILED_4_1_4"/>
    LMCAXIS_VEL_ACCNIHIL_NEGATIVE,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the coupling-velocity of the&#13;&#10;spline of 3rd order with the spline of 4th order becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_ACCNIHIL_NEGATIVE"/>
    LMCAXIS_VEL_ACCNIHIL_EXCEED,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the coupling-velocity of the&#13;&#10;spline of 3rd order with the spline of 4th order exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_ACCNIHIL_EXCEED"/>
    LMCAXIS_ACC_MAX_DEFINITION_ERROR,  //! <Type Comment="Maximal allowed acceleration is negative (input-error)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_MAX_DEFINITION_ERROR"/>
    LMCAXIS_VEL_COUPLE_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the velocity of the linear spline&#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_NEGATIVE_4_1_4"/>
    LMCAXIS_VEL_COUPLE_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the velocity of the linear spline&#13;&#10;exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_EXCEED_4_1_4"/>
    LMCAXIS_PATH_SX_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the path of the first spline of 4t order&#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SX_NEGATIVE_4_1_4"/>
    LMCAXIS_PATH_SY_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the path of the linear spline&#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SY_NEGATIVE_4_1_4"/>
    LMCAXIS_PATH_SZ_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the path of the second spline of 4th order&#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SZ_NEGATIVE_4_1_4"/>
    LMCAXIS_VEL_MIN_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the velocity of the first spline of 4th order&#13;&#10;becomes negative (has a negative extremum - backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MIN_NEGATIVE_4_1_4"/>
    LMCAXIS_VEL_MAX_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the velocity of the first spline of 4th order&#13;&#10;overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MAX_EXCEED_4_1_4"/>
    LMCAXIS_ACC_MAX_1_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the acceleration of the first spline of 4th order&#13;&#10;overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_MAX_1_EXCEED_4_1_4"/>
    LMCAXIS_ACC_MAX_2_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the acceleration of the second &#13;&#10;spline of 4th order overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_MAX_2_EXCEED_4_1_4"/>
    LMCAXIS_JERK_MAX_1_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the jerk of the first&#13;&#10;spline of 4th order overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_JERK_MAX_1_EXCEED_4_1_4"/>
    LMCAXIS_JERK_MAX_2_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the jerk of the second &#13;&#10;spline of 4th order overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_JERK_MAX_2_EXCEED_4_1_4"/>
    LMCAXIS_TRAPEZOIDSPLINE_DISABLED,  //! <Type Comment="Trapezoid-Spline is disabled (by user of by default-value)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TRAPEZOIDSPLINE_DISABLED"/>
    LMCAXIS_VEL_COUPLE_NO_SOLUTION,  //! <Type Comment="No real solution for the coupling-velocity exist (math.: is a complex number)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_NO_SOLUTION"/>
    LMCAXIS_VEL_COUPLE_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the coupling-velocity becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_NEGATIVE_2_1_2"/>
    LMCAXIS_VEL_COUPLE_EXCEED_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the velocity of the linear spline&#13;&#10;exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_EXCEED_2_1_2"/>
    LMCAXIS_TIME_SX_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the duration of the first spline of 2nd order becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TIME_SX_NEGATIVE_2_1_2"/>
    LMCAXIS_TIME_SY_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the duration of the lineare spline becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TIME_SY_NEGATIVE_2_1_2"/>
    LMCAXIS_TIME_SZ_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the duration of the 3rd spline of 2nd order becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TIME_SZ_NEGATIVE_2_1_2"/>
    LMCAXIS_PATH_SX_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the path of the first spline of 2nd order becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SX_NEGATIVE_2_1_2"/>
    LMCAXIS_PATH_SY_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the path of the lineare spline becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SY_NEGATIVE_2_1_2"/>
    LMCAXIS_PATH_SZ_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the path of the 3rd spline of 2nd order becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SZ_NEGATIVE_2_1_2"/>
    LMCAXIS_DURATION_ERROR  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the duration of spline is zero&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_DURATION_ERROR"/>
  )$UDINT;
#pragma pack(push, 1)
  CurveTable : STRUCT  //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="CurveTable"/>
    MasterPos : DINT;  //! <Type Comment="Master axis position [Application units]" Name="CurveTable.MasterPos"/>
    SlavePos : DINT;  //! <Type Comment="Slave axis position [Application units]" Name="CurveTable.SlavePos"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _LMCAXIS_CURVE : STRUCT  //! <Type Comment="Motion type curve data" Name="_LMCAXIS_CURVE"/>
    modulo : DINT;  //! <Type Comment="Lead axis modulo value" Name="_LMCAXIS_CURVE.modulo"/>
    points : DINT;  //! <Type Comment="number of curve points" Name="_LMCAXIS_CURVE.points"/>
    mul : DINT;  //! <Type Comment="Numerator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="_LMCAXIS_CURVE.mul"/>
    div : DINT;  //! <Type Comment="Denominator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="_LMCAXIS_CURVE.div"/>
    offset : DINT;  //! <Type Comment="Position offset in the slave axis of the cam definition [Internal units].&#13;&#10;Added to the slave value of the cam table." Name="_LMCAXIS_CURVE.offset"/>
    table : ARRAY [0..1023] OF CurveTable;  //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="_LMCAXIS_CURVE.table"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCAXIS_CURVETABMODE : BDINT  //! <Type Comment="Slave axis operating mode" Name="_LMCAXIS_CURVETABMODE"/>
  [
    1 bStopAxisNoMod,  //! <Type Comment="Parameter of the function &quot;CoupleCurveTab&quot;&#13;&#10;0 --&gt; Normal operation. Slave follows the master over the curve definition, including a master axis position overflow.&#13;&#10;1 --&gt; Stop slave axis immediately when master axis position overflows." Name="_LMCAXIS_CURVETABMODE.bStopAxisNoMod"/>
  ];
  _LMCAXIS_ERROR : BDINT  //! <Type Comment="Error-Bits" Name="_LMCAXIS_ERROR"/>
  [
    1 HwError,  //! <Type Comment="Set if a general Hardware-Error occured" Name="_LMCAXIS_ERROR.HwError"/>
    2 SwMinError,  //! <Type Comment="Set if the Software-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.SwMinError"/>
    3 SwMaxError,  //! <Type Comment="Set if the Software-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.SwMaxError"/>
    4 HwMinError,  //! <Type Comment="Set if the Hardware-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.HwMinError"/>
    5 HwMaxError,  //! <Type Comment="Set if the Hardware-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.HwMaxError"/>
    6 ReferenceError,  //! <Type Comment="Set if an error occured during the reference-run" Name="_LMCAXIS_ERROR.ReferenceError"/>
    7 ContouringError,  //! <Type Comment="Set if a tracking-error occured" Name="_LMCAXIS_ERROR.ContouringError"/>
    8 ActPosError,  //! <Type Comment="Set if the Hardware-Position is invalid" Name="_LMCAXIS_ERROR.ActPosError"/>
    9 AbsOffsetError,  //! <Type Comment="Set if an Offset-Error occured" Name="_LMCAXIS_ERROR.AbsOffsetError"/>
    10 OverFlowError,  //! <Type Comment="Set if a Position-Overflow occured" Name="_LMCAXIS_ERROR.OverFlowError"/>
    11 EmergencyError,  //! <Type Comment="Set if the _LMCSafety.Emergency is active" Name="_LMCAXIS_ERROR.EmergencyError"/>
    12 ResolutionError,  //! <Type Comment="Set if the Resolution causes an overflow error&#13;&#10;" Name="_LMCAXIS_ERROR.ResolutionError"/>
    13 PowerOnError,  //! <Type Comment="Set, if the enable signal of the hardware was cleared during operation, or if after calling PowerOn() the axis has not been enabled before a timeout of 30 seconds occured." Name="_LMCAXIS_ERROR.PowerOnError"/>
    16 GlobErr,  //! <Type Comment="Set if a global error is active" Name="_LMCAXIS_ERROR.GlobErr"/>
  ];
  _LMCAXIS_ERROR_CONFIG : BDINT  //! <Type Comment="Error-Config Bits" Name="_LMCAXIS_ERROR_CONFIG"/>
  [
    1 vError,  //! <Type Comment="when programmed speed is too high:&#13;&#10; 0 ... the speed will be limited (default)&#13;&#10; 1 ... set the vError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.vError"/>
    2 aError,  //! <Type Comment="when programmed acceleration is too high:&#13;&#10; 0 ... the acceleration will be limited (default)&#13;&#10; 1 ... set the aError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.aError"/>
    3 SWMinError,  //! <Type Comment="when position would be smaller than SWMinPos:&#13;&#10; 0 ... position will be limited (default)&#13;&#10; 1 ... set the SWMinError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.SWMinError"/>
    4 SWMaxError,  //! <Type Comment="when position would be bigger than SWMaxPos:&#13;&#10; 0 ... position will be limited (default)&#13;&#10; 1 ... set the SWMaxError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.SWMaxError"/>
    5 CommandError,  //! <Type Comment="when the deltaposition is bigger than the&#13;&#10;MaxModulo during coupling:&#13;&#10; 0 ... no check (default)&#13;&#10; 1 ... set the CommandError flag in the command result" Name="_LMCAXIS_ERROR_CONFIG.CommandError"/>
    6 EmergencyError,  //! <Type Comment="when Emergency goes to 1:&#13;&#10; 0 ... StopMove() (default)&#13;&#10; 1 ... PowerOff()&#13;&#10;" Name="_LMCAXIS_ERROR_CONFIG.EmergencyError"/>
    7 CoupleMonitoring,  //! <Type Comment="0: Monitoring the coupled axes is disabled. This axis does not recognise an error of its master axis and also does not report its own errors to the master. Furthermore, there is no reaction on errors of its slaves.&#13;&#10;1: Monitoring of all coupled master and slave axes for errors is enabled. The error handling can be configured with SetParameter with modes LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR, LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR, and LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG." Name="_LMCAXIS_ERROR_CONFIG.CoupleMonitoring"/>
    8 JError,  //! <Type Comment="when programmed jerk is too high or low:&#13;&#10; 0 ... the acceleration will be limited (default)&#13;&#10; 1 ... set the JError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.JError"/>
  ];
  _LMCAXIS_FOLLOW_MODE :  //! <Type Comment="Parameter of the function &quot;SetFollowMode&quot;" Name="_LMCAXIS_FOLLOW_MODE"/>
  (
    LMCAXIS_DEACTIVATE_FOLLOW_MODE,  //! <Type Comment="Parameter of the function &quot;SetFollowMode&quot;:&#13;&#10;Deactivate the operationmode &quot;FOLLOW_LMCAXIS&quot;" Name="_LMCAXIS_FOLLOW_MODE.LMCAXIS_DEACTIVATE_FOLLOW_MODE"/>
    LMCAXIS_ACTIVATE_FOLLOW_MODE  //! <Type Comment="Parameter of the function &quot;SetFollowMode&quot;:&#13;&#10;Activate the operationmode &quot;FOLLOW_LMCAXIS&quot;" Name="_LMCAXIS_FOLLOW_MODE.LMCAXIS_ACTIVATE_FOLLOW_MODE"/>
  )$UDINT;
  _LMCAXIS_MOVE_RELATIVE_MODE :  //! <Type Comment="Parameter of the function &quot;MoveRelative&quot;" Name="_LMCAXIS_MOVE_RELATIVE_MODE"/>
  (
    LMCAXIS_MOVE_RELATIVE_TO_DESTINATION,  //! <Type Comment="Parameter of the function &quot;MoveRelative&quot;:&#13;&#10;Move relative to destination" Name="_LMCAXIS_MOVE_RELATIVE_MODE.LMCAXIS_MOVE_RELATIVE_TO_DESTINATION"/>
    LMCAXIS_MOVE_RELATIVE_TO_POSITION  //! <Type Comment="Parameter of the function &quot;MoveRelative&quot;:&#13;&#10;Move relative to position" Name="_LMCAXIS_MOVE_RELATIVE_MODE.LMCAXIS_MOVE_RELATIVE_TO_POSITION"/>
  )$UDINT;
  _LMCAXIS_MOVEDIRECTION :  //! <Type Comment="Set direction of movement for the axis&#13;&#10;" Name="_LMCAXIS_MOVEDIRECTION"/>
  (
    LMCAXIS_MOVE_ANY_WAY,  //! <Type Comment="The axis can move in any direction." Name="_LMCAXIS_MOVEDIRECTION.LMCAXIS_MOVE_ANY_WAY"/>
    LMCAXIS_MOVE_NEG_DIR,  //! <Type Comment="The axis can move in the negative direction only." Name="_LMCAXIS_MOVEDIRECTION.LMCAXIS_MOVE_NEG_DIR"/>
    LMCAXIS_MOVE_SHORTEST_WAY,  //! <Type Comment="The axis moves over the shortest distance (both directions)" Name="_LMCAXIS_MOVEDIRECTION.LMCAXIS_MOVE_SHORTEST_WAY"/>
    LMCAXIS_MOVE_POS_DIR  //! <Type Comment="The axis can move in the positive direction only." Name="_LMCAXIS_MOVEDIRECTION.LMCAXIS_MOVE_POS_DIR"/>
  )$UDINT;
  _LMCAXIS_MOVEPROFILE :  //! <Type Comment="Velocity-profile" Name="_LMCAXIS_MOVEPROFILE"/>
  (
    _RAMP_PROFILE,  //! <Type Comment="Velocity-profile resembles a linear ramp" Name="_LMCAXIS_MOVEPROFILE._RAMP_PROFILE"/>
    _SCURVE_PROFILE,  //! <Type Comment="Velocity-profile resembles a sigmoide (S-Curve)&#13;&#10;using a position filtering." Name="_LMCAXIS_MOVEPROFILE._SCURVE_PROFILE"/>
    _JERK_PROFILE:=10  //! <Type Comment="Velocity-profile resembles a sigmoide (S-Curve)&#13;&#10;using exact calculation of a trapezoide acceleration/deceleration" Name="_LMCAXIS_MOVEPROFILE._JERK_PROFILE"/>
  )$UDINT;
  _LMCAXIS_MOVINGTIMEERROR :  //! <Type Comment="Errorlist returned by the function: &quot;CalcMovingTime&quot;" Name="_LMCAXIS_MOVINGTIMEERROR"/>
  (
    LMCAXIS_NO_ERROR_,  //! <Type Comment="No Error occured - a solution is found" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_NO_ERROR_"/>
    LMCAXIS_MAXVEL_NOT_POSITIV,  //! <Type Comment="Input-Error: Maximal allowed velocity &lt;= 0" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_MAXVEL_NOT_POSITIV"/>
    LMCAXIS_STARTVEL_TO_BIG,  //! <Type Comment="Input-Error: Velocitiy at Startposition &gt; Maximal allowed velocity" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_STARTVEL_TO_BIG"/>
    LMCAXIS_ENDVEL_TO_BIG,  //! <Type Comment="Input-Error: Velocitiy at Endposition &gt; Maximal allowed velocity" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_ENDVEL_TO_BIG"/>
    LMCAXIS_PATH_IS_ZERO,  //! <Type Comment="Input-Error: Startposition is identically equal to Endposition but one velocity &lt;&gt; 0" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_PATH_IS_ZERO"/>
    LMCAXIS_STARTVEL_NEGATIVE,  //! <Type Comment="Start-Velocity is negative" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_STARTVEL_NEGATIVE"/>
    LMCAXIS_OVERFLOW_ERROR,  //! <Type Comment="Overflow-Error during calculation occured" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_OVERFLOW_ERROR"/>
    LMCAXIS_TIME_ERROR_1,  //! <Type Comment="Time of first part of triangel/trapez is negative " Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_TIME_ERROR_1"/>
    LMCAXIS_TIME_ERROR_2,  //! <Type Comment="Time of second part of trapez is negative" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_TIME_ERROR_2"/>
    LMCAXIS_TIME_ERROR_3,  //! <Type Comment="Time of third part of triangel/trapez is negative" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_TIME_ERROR_3"/>
    LMCAXIS_POINTER_ERROR,  //! <Type Comment="Pointer to Parameter is NIL " Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_POINTER_ERROR"/>
    LMCAXIS_ENDVEL_NEGATIVE,  //! <Type Comment="End-Velocity is negative" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_ENDVEL_NEGATIVE"/>
    LMCAXIS_ACCEL_NOT_POSITIV,  //! <Type Comment="Start-Acceleration is not positive" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_ACCEL_NOT_POSITIV"/>
    LMCAXIS_DECEL_NOT_POSITIV,  //! <Type Comment="End-Deceleration is not positive" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_DECEL_NOT_POSITIV"/>
    LMCAXIS_PATH_ERROR,  //! <Type Comment="Endposition cannot be reached - Parameter inconsitent" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_PATH_ERROR"/>
    LMCAXIS_GLOBAL_ERROR  //! <Type Comment="The resulting time is negative - Parameter inconsitent" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_GLOBAL_ERROR"/>
  )$UDINT;
  _LMCAXIS_OPMODE :  //! <Type Comment="Current state of the axis" Name="_LMCAXIS_OPMODE"/>
  (
    PASSIVE_LMCAXIS,  //! <Type Comment="The axis is in passive hibernation" Name="_LMCAXIS_OPMODE.PASSIVE_LMCAXIS"/>
    WAITIDLE_LMCAXIS,  //! <Type Comment="The axis is in passive waiting state until the hardware reports" Name="_LMCAXIS_OPMODE.WAITIDLE_LMCAXIS"/>
    IDLE_LMCAXIS,  //! <Type Comment="The axis is in active waiting state" Name="_LMCAXIS_OPMODE.IDLE_LMCAXIS"/>
    MOVE_LMCAXIS,  //! <Type Comment="The axis is in movement state" Name="_LMCAXIS_OPMODE.MOVE_LMCAXIS"/>
    FOLLOW_LMCAXIS,  //! <Type Comment="The axis is in state &quot;FOLLOW_LMCAXIS&quot;:&#13;&#10;Axis follows the actual position (defaulted by a controller) passively&#13;&#10;" Name="_LMCAXIS_OPMODE.FOLLOW_LMCAXIS"/>
    STOPED_LMCAXIS,  //! <Type Comment="The axis is stopping the movement (braking)" Name="_LMCAXIS_OPMODE.STOPED_LMCAXIS"/>
    LOCKED_LMCAXIS,  //! <Type Comment="The axis is coupled to a master-axis" Name="_LMCAXIS_OPMODE.LOCKED_LMCAXIS"/>
    REFRUN_LMCAXIS,  //! <Type Comment="The axis is performing a reference run" Name="_LMCAXIS_OPMODE.REFRUN_LMCAXIS"/>
    TUNEPOS_LMCAXIS,  //! <Type Comment="Movement for the purpose of optimization of the control parameters in positive direction" Name="_LMCAXIS_OPMODE.TUNEPOS_LMCAXIS"/>
    TUNENEG_LMCAXIS,  //! <Type Comment="Movement for the purpose of optimization of the control parameters in negative direction" Name="_LMCAXIS_OPMODE.TUNENEG_LMCAXIS"/>
    ERROR_LMCAXIS  //! <Type Comment="An error occurred" Name="_LMCAXIS_OPMODE.ERROR_LMCAXIS"/>
  )$UDINT;
  _LMCAXIS_POSMODE :  //! <Type Comment="Positionmode" Name="_LMCAXIS_POSMODE"/>
  (
    _Positioning,  //! <Type Comment="The axis is not coupled" Name="_LMCAXIS_POSMODE._Positioning"/>
    _NCPositioning,  //! <Type Comment="The axis is controlled by a NCController" Name="_LMCAXIS_POSMODE._NCPositioning"/>
    _StdSyncPositioning,  //! <Type Comment="The axis is coupled by calling one of this functions:&#13;&#10;CoupleDeltaPos, CoupleGearAbsolute or CoupleGearRelative" Name="_LMCAXIS_POSMODE._StdSyncPositioning"/>
    _UserSyncPositioning,  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleUserPos" Name="_LMCAXIS_POSMODE._UserSyncPositioning"/>
    _CAMSyncPositioning,  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleCurveTab" Name="_LMCAXIS_POSMODE._CAMSyncPositioning"/>
    _ProfileSyncPositioning,  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleProfilePos" Name="_LMCAXIS_POSMODE._ProfileSyncPositioning"/>
    _SyncVelocity,  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleGearVelocity" Name="_LMCAXIS_POSMODE._SyncVelocity"/>
    _StartPolynomPositioning,  //! <Type Comment="The axis is coupling by calling the function: &#13;&#10;CoupleGearPolynom" Name="_LMCAXIS_POSMODE._StartPolynomPositioning"/>
    _SyncPolynomPositioning  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleGearPolynom" Name="_LMCAXIS_POSMODE._SyncPolynomPositioning"/>
  )$UDINT;
  _LMCAXIS_POWER_OFF_MODE :  //! <Type Comment="Parameter of the function: &quot;PowerOff&quot;" Name="_LMCAXIS_POWER_OFF_MODE"/>
  (
    LMCAXIS_IMMEDIATE_STOPP,  //! <Type Comment="&quot;PowerOff(IMMEDIATE_STOPP)&quot; stopps the controller by the moment&#13;&#10;" Name="_LMCAXIS_POWER_OFF_MODE.LMCAXIS_IMMEDIATE_STOPP"/>
    LMCAXIS_SMOOTH_STOPP  //! <Type Comment="&quot;PowerOff(SMOOTH_STOPP)&quot;    stopps the controller smoothly by a ramp" Name="_LMCAXIS_POWER_OFF_MODE.LMCAXIS_SMOOTH_STOPP"/>
  )$UDINT;
  _LMCAXIS_QUERY_POSITION_MODE :  //! <Type Comment="Parameter of the function &quot;InPosition&quot;" Name="_LMCAXIS_QUERY_POSITION_MODE"/>
  (
    LMCAXIS_NO_JERK_FILTER:=4294967294,  //! <Type Comment="Parameter of the function &quot;InPosition&quot;&#13;&#10;Jerkfilter remains unconsidered" Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_NO_JERK_FILTER"/>
    LMCAXIS_NO_POSITIONWINDOW:=4294967295,  //! <Type Comment="Parameter of the function &quot;InPosition&quot;:&#13;&#10;Positionwindow remains unconsidered&#13;&#10;" Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_NO_POSITIONWINDOW"/>
    LMCAXIS_POSITIONWINDOW_APP_UNITS,  //! <Type Comment="Parameter of the function &quot;InPosition&quot;:&#13;&#10;Positionwindow in application units" Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_POSITIONWINDOW_APP_UNITS"/>
    LMCAXIS_POSITIONWINDOW_INT_UNITS,  //! <Type Comment="Parameter of the function &quot;InPosition&quot;:&#13;&#10;Positionwindow in intern units" Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_POSITIONWINDOW_INT_UNITS"/>
    LMCAXIS_SETPOS_IN_WINDOW_APP_UNITS:=2,  //! <Type Comment="Checks if the distance between the set position and the target position is within the position window.&#13;&#10;The position window is given in application units." Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_SETPOS_IN_WINDOW_APP_UNITS"/>
    LMCAXIS_SETPOS_IN_WINDOW_INT_UNITS:=3,  //! <Type Comment="Checks if the distance between the set position and the target position is within the position window.&#13;&#10;The position window is given in internal units." Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_SETPOS_IN_WINDOW_INT_UNITS"/>
    LMCAXIS_ACTPOS_IN_WINDOW_APP_UNITS:=4,  //! <Type Comment="Checks if the distance between the actual position and the target position is within the position window.&#13;&#10;The position window is given in application units." Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_ACTPOS_IN_WINDOW_APP_UNITS"/>
    LMCAXIS_ACTPOS_IN_WINDOW_INT_UNITS:=5  //! <Type Comment="Checks if the distance between the actual position and the target position is within the position window.&#13;&#10;The position window is given in internal units." Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_ACTPOS_IN_WINDOW_INT_UNITS"/>
  )$DINT;
  _LMCAXIS_READPARAMETER :  //! <Type Comment="Parameter-ID" Name="_LMCAXIS_READPARAMETER"/>
  (
    LMCAXIS_PAR_RD_V_MAX,  //! <Type Comment="Read maximum axis velocity [Application units/s] or [Internal units/s] depending on mode" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_V_MAX"/>
    LMCAXIS_PAR_RD_A_MAX,  //! <Type Comment="Read maximum axis acceleration / deceleration [Application units/s²] or [Internal units/s²] depending on mode" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_A_MAX"/>
    LMCAXIS_PAR_RD_EXTUNITS,  //! <Type Comment="Read value of server ExUnit [Increments]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_EXTUNITS"/>
    LMCAXIS_PAR_RD_RESFACT,  //! <Type Comment="Read the value of server Resolution" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_RESFACT"/>
    LMCAXIS_PAR_RD_INTUNITS,  //! <Type Comment="Read value of server IntUnit" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_INTUNITS"/>
    LMCAXIS_PAR_RD_SEMAPHOR,  //! <Type Comment="Read the value of the command semaphore" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_SEMAPHOR"/>
    LMCAXIS_PAR_RD_REFPOS,  //! <Type Comment="Read the reference position [Application units] or [Internal units] depending on mode" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_REFPOS"/>
    LMCAXIS_PAR_RD_MODULO,  //! <Type Comment="Read the value of the server Modulo [Application units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MODULO"/>
    LMCAXIS_PAR_RD_MASTERLOCK_12,  //! <Type Comment="If the axis is not coupled, 0 is returned. Otherwise the value of MasterLock is returned (see parameter LMCAXIS_PAR_RD_MASTERLOCK_11)" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MASTERLOCK_12"/>
    LMCAXIS_PAR_RD_MASTERLOCK_11,  //! <Type Comment="Read MasterLock, 0 = not locked to master, 1 = synchronized with master" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MASTERLOCK_11"/>
    LMCAXIS_PAR_RD_MAX_MODULO,  //! <Type Comment="Read the internal overflow position [internal units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MAX_MODULO"/>
    LMCAXIS_PAR_RD_BINOFFSET,  //! <Type Comment="Read the binary position offset [external units] ([encoder increments])" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_BINOFFSET"/>
    LMCAXIS_PAR_RD_CONTROLLERTYPE,  //! <Type Comment="Read which type of controller is connected to client LMCController" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_CONTROLLERTYPE"/>
    LMCAXIS_PAR_RD_POSMODE,  //! <Type Comment="Read the type of the currently active positioning (see server PosMode)" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_POSMODE"/>
    LMCAXIS_PAR_RD_TIMEBASE,  //! <Type Comment="Read the RtWork() cycle time&#13;&#10;in [microseconds] if the most significant bit is set&#13;&#10;or in [milliseconds] otherwise" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_TIMEBASE"/>
    LMCAXIS_PAR_RD_CONTROLLERPAR,  //! <Type Comment="Read a parameter value from the controller connected to client LMCController.&#13;&#10;If no controller is connected, then -1 is returned.&#13;&#10;Mode contains the number of the controller parameter that should be read." Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_CONTROLLERPAR"/>
    LMCAXIS_PAR_RD_J_MAX,  //! <Type Comment="Read the maximum jerk [Application units / s² / ms] = [Application units / s^3 * 1000]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_J_MAX"/>
    LMCAXIS_PAR_RD_MOVETYPE,  //! <Type Comment="Read moving profile of the axis&#13;&#10;====================&#13;&#10; 0 = _RAMP_PROFILE - axis moves without jerk limitation&#13;&#10; 1 = _SCURVE_PROFILE - axis moves with jerk filter (jerk limitation through position filter)&#13;&#10;10 = _JERK_PROFILE - axis moves with jerk limitation (calculated limitation)" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MOVETYPE"/>
    LMCAXIS_PAR_RD_T_JERK,  //! <Type Comment="Read the jerk time (server Tjerk) [ms].&#13;&#10;This is the time for the acceleration to attain its maximum value." Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_T_JERK"/>
    LMCAXIS_PAR_RD_HARDLOCK,  //! <Type Comment="Read the HardLock flag.&#13;&#10;0: the slave always adheres to its speed, acceleration and deceleration limits&#13;&#10;1: when the slave is synchronized with the master, it may exceed its acceleration and deceleration limits but not the speed limit" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_HARDLOCK"/>
    LMCAXIS_PAR_RD_SHAPE_SPLINE,  //! <Type Comment="Parameter of the function &quot;ReadParameter&quot;:&#13;&#10;Read spline-configuration (See function &quot;ReadParameter&quot;)" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_SHAPE_SPLINE"/>
    LMCAXIS_PAR_RD_MOVEDIRECTION,  //! <Type Comment="Read direction of movement for the axis&#13;&#10;0 = AXIS_MOVE_ANY_WAY axis may move in any direction&#13;&#10;1 = AXIS_MOVE_NEG_DIR axis may only move in the negative direction&#13;&#10;3 = AXIS_MOVE_POS_DIR axis may only move in the positive direction&#13;&#10;2 = AXIS_MOVE_SHORTEST_WAY axis takes the shortest way to the destination" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MOVEDIRECTION"/>
    LMCAXIS_PAR_RD_COUPLE_ERROR,  //! <Type Comment="Parameter of the function &quot;ReadParameter&quot;:&#13;&#10;Read the last Couping-Error that occured by calling &quot;CoupleGearPolynom&quot;&#13;&#10;" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_COUPLE_ERROR"/>
    LMCAXIS_PAR_RD_SWLIMWINDOW,  //! <Type Comment="Read Endpostion-Tolerance-Window [application units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_SWLIMWINDOW"/>
    LMCAXIS_PAR_RD_MASTER_DELAY,  //! <Type Comment="Read the max Delay of the MasterPointer [ticks]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MASTER_DELAY"/>
    LMCAXIS_PAR_RD_DEC,  //! <Type Comment="Read deceleration [Application units/s²] or [Internal units/tick²] depending on mode" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_DEC"/>
    LMCAXIS_PAR_RD_DYN_SW_LIMIT,  //! <Type Comment="Is a min/max dynamic software limit monitored?" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_DYN_SW_LIMIT"/>
    LMCAXIS_PAR_RD_MAX_OVERRIDE,  //! <Type Comment="Reads the maximal allowed value for the override&#13;&#10;&#13;&#10;Mode=0: absolute max override value&#13;&#10;Mode=1: max override value in a tenth of percent" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MAX_OVERRIDE"/>
    LMCAXIS_PAR_RD_NORM_OVERRIDE,  //! <Type Comment="Reads the override value, which represents 100%." Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_NORM_OVERRIDE"/>
    LMCAXIS_PAR_RD_OVERRIDE,  //! <Type Comment="Reads the actual override value.&#13;&#10;&#13;&#10;Mode=0: absolute override value&#13;&#10;Mode=1: override value in a tenth of percent" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_OVERRIDE"/>
    LMCAXIS_PAR_RD_DELAYEDMASTERLOCK,  //! <Type Comment="Read DelayedMasterLock, 0 = not locked to master, 1 = synchronized with master" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_DELAYEDMASTERLOCK"/>
    LMCAXIS_PAR_RD_OVERFLOW_POS,  //! <Type Comment="read the internal position overflow limit [Internal units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_OVERFLOW_POS"/>
    LMCAXIS_PAR_RD_MIN_POSITION,  //! <Type Comment="read the minimum internal end position  [Internal units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MIN_POSITION"/>
    LMCAXIS_PAR_RD_MAX_POSITION,  //! <Type Comment="read the maximum internal end position [Internal units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MAX_POSITION"/>
    LMCAXIS_PAR_RD_ZPULSE_DIST,  //! <Type Comment="read the distance from refswitch to zpulse [application units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_ZPULSE_DIST"/>
    LMCAXIS_PAR_RD_ALLOWED_ACC_JUMP,  //! <Type Comment="Read the maximal allowed accel jump for the slave. [application units / sec^2 / tick]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_ALLOWED_ACC_JUMP"/>
    LMCAXIS_PAR_RD_SIMULATE_MODE
  )$UDINT;
  _LMCAXIS_READPOS :  //! <Type Comment="Type of the position that should be read" Name="_LMCAXIS_READPOS"/>
  (
    LMCAXIS_SETPOS_APPUNIT,  //! <Type Comment="Set position with or without jerk limitation (depending on coupler mode), bounded by Modulo [Application units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_APPUNIT"/>
    LMCAXIS_SETPOS_INTUNIT,  //! <Type Comment="Set position with or without jerk limitation (depending on coupler mode), bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_INTUNIT"/>
    LMCAXIS_SETPOS_INTUNIT_WO_MOD,  //! <Type Comment="Set position without jerk limitation, NOT bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_INTUNIT_WO_MOD"/>
    LMCAXIS_DESTPOS_INTUNIT,  //! <Type Comment="Actual target position [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_DESTPOS_INTUNIT"/>
    LMCAXIS_SETPOS_INTUNIT_JERK_WO_MOD,  //! <Type Comment="Set position with or without jerk limitation (depending on coupler mode), NOT bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_INTUNIT_JERK_WO_MOD"/>
    LMCAXIS_SETPOS_INTUNIT_JERK,  //! <Type Comment="Set position with jerk limitation, bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_INTUNIT_JERK"/>
    LMCAXIS_SETPOS_APPUNIT_JERK,  //! <Type Comment="Set position with jerk limitation, bounded by Modulo [Application units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_APPUNIT_JERK"/>
    LMCAXIS_SETPOS_APPUNIT_SPEC1,  //! <Type Comment="Set position with or without jerk limitation (see parameter LMCAXIS_PAR_SET_JERK_LIMITATION), bounded by Modulo [Application units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_APPUNIT_SPEC1"/>
    LMCAXIS_ACTPOS_APPUNIT,  //! <Type Comment="Actual position, bounded by Modulo [Application units]" Name="_LMCAXIS_READPOS.LMCAXIS_ACTPOS_APPUNIT"/>
    LMCAXIS_ACTPOS_INTUNIT,  //! <Type Comment="Actual position, bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_ACTPOS_INTUNIT"/>
    LMCAXIS_ACTPOS_INTUNIT_WO_MOD,  //! <Type Comment="Actual position, NOT bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_ACTPOS_INTUNIT_WO_MOD"/>
    LMCAXIS_BRAKEPOS_APPUNIT,  //! <Type Comment="the position, where the axis can stop, if it starts braking immediately.[application units]" Name="_LMCAXIS_READPOS.LMCAXIS_BRAKEPOS_APPUNIT"/>
    LMCAXIS_MASTERPOS_INTUNIT,  //! <Type Comment="current position of the master axis [internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_MASTERPOS_INTUNIT"/>
    LMCAXIS_XW_TO_DESTPOS_INTUNIT  //! <Type Comment="internal mode for _LMCProfile." Name="_LMCAXIS_READPOS.LMCAXIS_XW_TO_DESTPOS_INTUNIT"/>
  )$UDINT;
  _LMCAXIS_READSWENDPOS :  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;" Name="_LMCAXIS_READSWENDPOS"/>
  (
    LMCAXIS_RD_SWMAX_APPUNIT,  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;:&#13;&#10;Read the maximal software-endposition in application units" Name="_LMCAXIS_READSWENDPOS.LMCAXIS_RD_SWMAX_APPUNIT"/>
    LMCAXIS_RD_SWMIN_APPUNIT,  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;:&#13;&#10;Read the minimal software-endposition in application units" Name="_LMCAXIS_READSWENDPOS.LMCAXIS_RD_SWMIN_APPUNIT"/>
    LMCAXIS_RD_SWMAX_INTUNIT,  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;:&#13;&#10;Read the maximal software-endposition in intern units" Name="_LMCAXIS_READSWENDPOS.LMCAXIS_RD_SWMAX_INTUNIT"/>
    LMCAXIS_RD_SWMIN_INTUNIT  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;:&#13;&#10;Read the minimal software-endposition in intern units" Name="_LMCAXIS_READSWENDPOS.LMCAXIS_RD_SWMIN_INTUNIT"/>
  )$UDINT;
  _LMCAXIS_READVELOCITY :  //! <Type Comment="Type of the axis velocity that should be read" Name="_LMCAXIS_READVELOCITY"/>
  (
    LMCAXIS_SETVEL_APPUNIT_SEC,  //! <Type Comment="Set velocity without jerk limitation [Application units/s]&#13;&#10;" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_APPUNIT_SEC"/>
    LMCAXIS_SETVEL_INTUNIT_SEC,  //! <Type Comment="Set velocity without jerk limitation [Internal units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_INTUNIT_SEC"/>
    LMCAXIS_SETVEL_APPUNIT_NCMODE,  //! <Type Comment="Set velocity + start velocity in NC mode [Application units/tick]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_APPUNIT_NCMODE"/>
    LMCAXIS_SETVEL_INTUNIT_NCMODE,  //! <Type Comment="Set velocity + start velocity in NC mode [Internal units/tick]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_INTUNIT_NCMODE"/>
    LMCAXIS_ACTVEL_APPUNIT_MS,  //! <Type Comment="Unfiltered actual velocity [Application units/ms]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_APPUNIT_MS"/>
    LMCAXIS_ACTVEL_INTUNIT_MS,  //! <Type Comment="Unfiltered actual velocity [Internal units/ms]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_INTUNIT_MS"/>
    LMCAXIS_SETVEL_INTUNIT_TICK_JERK,  //! <Type Comment="Set velocity with jerk limitation [Internal units/tick]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_INTUNIT_TICK_JERK"/>
    LMCAXIS_SETVEL_APPUNIT_SEC_JERK,  //! <Type Comment="Set velocity with jerk limitation [Application units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_APPUNIT_SEC_JERK"/>
    LMCAXIS_SETVEL_INTUNIT_TICK,  //! <Type Comment="Set velocity without jerk limitation [Internal units/tick]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_INTUNIT_TICK"/>
    LMCAXIS_ACTVEL_APPUNIT_SEC,  //! <Type Comment="Unfiltered actual velocity [Application units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_APPUNIT_SEC"/>
    LMCAXIS_ACTVEL_INTUNIT_SEC,  //! <Type Comment="Unfiltered actual velocity [Internal units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_INTUNIT_SEC"/>
    LMCAXIS_ACTVEL_APPUNIT_SEC_FILT,  //! <Type Comment="Filtered actual velocity [Application units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_APPUNIT_SEC_FILT"/>
    LMCAXIS_ACTVEL_INTUNIT_SEC_FILT,  //! <Type Comment="Filtered actual velocity [Internal units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_INTUNIT_SEC_FILT"/>
    LMCAXIS_CMDVEL_APPUNIT  //! <Type Comment="Maximal " Name="_LMCAXIS_READVELOCITY.LMCAXIS_CMDVEL_APPUNIT"/>
  )$UDINT;
#pragma pack(push, 1)
  _LMCAXIS_REFDATA : STRUCT  //! <Type Comment="Parameters of the functions: &#13;&#10;&quot;MoveReference&quot;, &quot;ReferenceAxis&quot; and &quot;_LMCAxisRef::control&quot;" Name="_LMCAXIS_REFDATA"/>
    Status : iprStates;
    Velocity : DINT;  //! <Type Comment="Velocity during the refernce run" Name="_LMCAXIS_REFDATA.Velocity"/>
    Acc : DINT;  //! <Type Comment="Acceleration during the refernce run" Name="_LMCAXIS_REFDATA.Acc"/>
    vSetRef1 : DINT;  //! <Type Comment="Velocity during the movement to the refernce-switch" Name="_LMCAXIS_REFDATA.vSetRef1"/>
    vSetRef2 : DINT;  //! <Type Comment="Velocity during the movement away from the refernce-switch" Name="_LMCAXIS_REFDATA.vSetRef2"/>
    PosWindow : DINT;  //! <Type Comment="Position window for the Z-Impuls" Name="_LMCAXIS_REFDATA.PosWindow"/>
    LatchPosRef : DINT;  //! <Type Comment="External position used in mode &quot;RefLatchPos&quot;" Name="_LMCAXIS_REFDATA.LatchPosRef"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCAXIS_REFMODE : BDINT  //! <Type Comment="Reference mode" Name="_LMCAXIS_REFMODE"/>
  [
    1 NoZImpulse,  //! <Type Comment="0 --&gt; Referencing with referencing impulse&#13;&#10;1 --&gt; Referencing without referencing impulse" Name="_LMCAXIS_REFMODE.NoZImpulse"/>
    2 NoEndSwitch,  //! <Type Comment="0 --&gt; Referencing with endswitches&#13;&#10;1 --&gt; Referencing without endswitches" Name="_LMCAXIS_REFMODE.NoEndSwitch"/>
    3 RefDirection,  //! <Type Comment="1 --&gt; Referencing on positive direction&#13;&#10;0 --&gt; Referencing on negative direction" Name="_LMCAXIS_REFMODE.RefDirection"/>
    4 NoTurnOnSwitch,  //! <Type Comment="0 --&gt; Reverse direction at the reference switch&#13;&#10;1 --&gt; Do not reverse direction at the reference switch" Name="_LMCAXIS_REFMODE.NoTurnOnSwitch"/>
    5 ESEqualRef,  //! <Type Comment="1 --&gt; Hardware end switch is used as reference switch" Name="_LMCAXIS_REFMODE.ESEqualRef"/>
    6 NoSet,  //! <Type Comment="0 --&gt; The transmitted position is the reference position&#13;&#10;1 --&gt; The actual position is the reference position" Name="_LMCAXIS_REFMODE.NoSet"/>
    7 RefLatchPos,  //! <Type Comment="1 --&gt; Read reference position from client cLatchPos. If value changes, do a MoveAbsolute(cLatchPos) and set cLatchPos as current position." Name="_LMCAXIS_REFMODE.RefLatchPos"/>
    8 RefFirstEdge,  //! <Type Comment="1 --&gt; Go back to first edge of ref.switch or end switch" Name="_LMCAXIS_REFMODE.RefFirstEdge"/>
  ];
  _LMCAXIS_SETPARAMETER :  //! <Type Comment="Parameter-ID" Name="_LMCAXIS_SETPARAMETER"/>
  (
    LMCAXIS_PAR_SET_COUPLING_MODE,  //! <Type Comment="Changes the coupling mode" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_COUPLING_MODE"/>
    LMCAXIS_PAR_SET_DESTINATION,  //! <Type Comment="Sets new target position&#13;&#10;mode  = 0: [Application units]&#13;&#10;mode &lt;&gt; 0: [Internal units]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_DESTINATION"/>
    LMCAXIS_PAR_SET_OVERRIDE,  //! <Type Comment="Set new override value [0.1%]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_OVERRIDE"/>
    LMCAXIS_PAR_SET_LOGMODE,  //! <Type Comment="Changes data logger settings" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_LOGMODE"/>
    LMCAXIS_PAR_RESET_REF_STATE,  //! <Type Comment="The reference status is reset" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_RESET_REF_STATE"/>
    LMCAXIS_PAR_SET_CHANGE_SW_LIMITS,  //! <Type Comment="Change how the software limits check works" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_CHANGE_SW_LIMITS"/>
    LMCAXIS_PAR_SET_JERK_LIMITATION,  //! <Type Comment="Activates / deactivates jerk filter" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_JERK_LIMITATION"/>
    LMCAXIS_PAR_SET_SHIFT_BREAKPOS,  //! <Type Comment="Brake point shift for NC mode" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SHIFT_BREAKPOS"/>
    LMCAXIS_PAR_SET_OVERFLOW_POS,  //! <Type Comment="Sets a new internal position overflow limit [Internal units]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_OVERFLOW_POS"/>
    LMCAXIS_PAR_SET_MIN_POSITION,  //! <Type Comment="Sets a new minimum internal end position  [Internal units]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MIN_POSITION"/>
    LMCAXIS_PAR_SET_MAX_POSITION,  //! <Type Comment="Sets a new maximum internal end position [Internal units]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MAX_POSITION"/>
    LMCAXIS_PAR_SET_HARDLOCK,  //! <Type Comment="Change monitoring slave acceleration, deceleration, and jerk." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_HARDLOCK"/>
    LMCAXIS_PAR_SET_SWLIM_STANDSTILL,  //! <Type Comment="Activate/deactivate the SW end position monitor during standstill" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SWLIM_STANDSTILL"/>
    LMCAXIS_PAR_SET_SWLIM_DIR_CHANGE,  //! <Type Comment="Enable/disable SW end position monitor with direction reversal" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SWLIM_DIR_CHANGE"/>
    LMCAXIS_PAR_SET_SWLIM_MOVING,  //! <Type Comment="Enable/disable the set position monitor during movement toward the SW end positions" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SWLIM_MOVING"/>
    LMCAXIS_PAR_SET_INIT_JERK_FILTER,  //! <Type Comment="Initialize the jerk filter with ControllerOn" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_INIT_JERK_FILTER"/>
    LMCAXIS_PAR_SET_BINOFFSET,  //! <Type Comment="Set BinOffset [Increments] to a new value and update the position" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_BINOFFSET"/>
    LMCAXIS_PAR_SET_VJUMP,  //! <Type Comment="Enable/disable a jump in speed" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_VJUMP"/>
    LMCAXIS_PAR_SET_SW_LIMIT_FLAGS,  //! <Type Comment="Defines when AxisError.SwMinError and SwMaxError is set" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SW_LIMIT_FLAGS"/>
    LMCAXIS_PAR_SET_SW_LIM_WINDOW,  //! <Type Comment="Set tolerance window to set the SW end position monitor to idle mode" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SW_LIM_WINDOW"/>
    LMCAXIS_PAR_SET_MOVE_DIR,  //! <Type Comment="Set direction of movement for the axis" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MOVE_DIR"/>
    LMCAXIS_PAR_SET_TIMEBASE,  //! <Type Comment="Set RtWork cycle time of the axis and make it callable from outside the class" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_TIMEBASE"/>
    LMCAXIS_PAR_SET_CONTROLLERPAR,  //! <Type Comment="Set the parameters of the connected controller" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_CONTROLLERPAR"/>
    LMCAXIS_PAR_SET_ACTVELFILTER,  //! <Type Comment="Set whether the server ActVelocity displays the filtered or unfiltered actual velocity" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_ACTVELFILTER"/>
    LMCAXIS_PAR_SET_SHAPE_SPLINE,  //! <Type Comment="Modify the shapes of the splines used in CoupleGearPolynom" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SHAPE_SPLINE"/>
    LMCAXIS_PAR_SET_NO_OVERFLOWERROR,  //! <Type Comment="Suppress OverflowError when a slave axis cannot follow its master axis" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_NO_OVERFLOWERROR"/>
    LMCAXIS_PAR_SET_MASTERPOS_OLD,  //! <Type Comment="For internal use only." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MASTERPOS_OLD"/>
    LMCAXIS_PAR_SET_MASTER_DELAY,  //! <Type Comment="Set the max Delay of the MasterPointer &#13;&#10;default = 0&#13;&#10;max = 6" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MASTER_DELAY"/>
    LMCAXIS_PAR_SET_MAXMODULO,  //! <Type Comment="Set the MaxModule value&#13;&#10;default = 16#06000000" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MAXMODULO"/>
    LMCAXIS_PAR_SET_MAX_OVERRIDE:=29,  //! <Type Comment="Set the maximal allowed Override value." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MAX_OVERRIDE"/>
    LMCAXIS_PAR_SET_NORM_OVERRIDE,  //! <Type Comment="Norm. override value. Default value = 1000" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_NORM_OVERRIDE"/>
    LMCAXIS_PAR_SET_MASTERLOCK_DELAYCYCLES,  //! <Type Comment="set the amount of cycles for the delayed MasterLock&#13;&#10;default = 0" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MASTERLOCK_DELAYCYCLES"/>
    LMCAXIS_PAR_SET_ALLOWED_ACC_JUMP,  //! <Type Comment="Set the maximal allowed accel jump for the slave. [application units / sec^2 / tick]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_ALLOWED_ACC_JUMP"/>
    LMCAXIS_PAR_SET_SIMULATE_MODE,  //! <Type Comment="Value=1: Set the simulation mode&#13;&#10;Value=0: Disable the simulation mode" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SIMULATE_MODE"/>
    LMCAXIS_PAR_SET_DEACTIVATE_CALC_BRAKEPOS,  //! <Type Comment="1: Deactivates the computation of the master brake position. Software limit violations of the coupled axis may not be averted.&#13;&#10;0: Enables computation of the master brake position. Upcoming software limit violations may be detected and averted." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_DEACTIVATE_CALC_BRAKEPOS"/>
    LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR,  //! <Type Comment="Defines the reaction of this axis in case of an error of a coupled slave axis&#13;&#10;0: ignores the error. &#13;&#10;1: stops the axis with maximal deceleration, but does not disable it (like StopMove())&#13;&#10;2: (DEFAULT) stops with maximal deceleration and disables the axis (like PowerOff(LMCAXIS_SMOOTH_STOP))&#13;&#10;3: disables the axis immediately (like PowerOff(LMCAXIS_IMMEDIATE_STOP))&#13;&#10;&#13;&#10;" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR"/>
    LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR,  //! <Type Comment="Defines the reaction of this axis in case of an error of its MASTER axis or some axis coupled with the master.&#13;&#10;0: ignores the error. &#13;&#10;1: stops the axis with maximal deceleration, but does not disable it (like StopMove())&#13;&#10;2: (DEFAULT) stops with maximal deceleration and disables the axis (like PowerOff(LMCAXIS_SMOOTH_STOP))&#13;&#10;3: disables the axis immediately (like PowerOff(LMCAXIS_IMMEDIATE_STOP))&#13;&#10;&#13;&#10;" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR"/>
    LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG  //! <Type Comment="Extended configuration for couple monitoring&#13;&#10;Bit 1: ReportErrorToMaster&#13;&#10;Bit 2: ReportSlaveErrorToMaster&#13;&#10;Bit 3: ReportMasterErrorToSlave&#13;&#10;Bit 4: ReportSlaveErrorToSlave&#13;&#10;Bit 5: SwLimitMonitoringForMyMaster&#13;&#10;Bit 6: PowerOffMonitoringForMySlave" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG"/>
  )$UDINT;
  _LMCAXIS_SETPOSITION :  //! <Type Comment="Type of the position that should be set" Name="_LMCAXIS_SETPOSITION"/>
  (
    LMCAXIS_SET_ACTPOS_APPUNIT,  //! <Type Comment="Sets the external position (actual position value) to the specified position. &#13;&#10;This value is set based on &quot;Resolution&quot;, &quot;Modulo&quot; and the software limits. (New position = position * Resolution)" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_APPUNIT"/>
    LMCAXIS_SET_SETPOS_APPUNIT,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on &quot;Resolution&quot; ,&quot;Modulo&quot; and the software limits. (New position = position * Resolution)&#13;&#10;" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_APPUNIT"/>
    LMCAXIS_SET_ACTPOS_INTUNIT,  //! <Type Comment="Sets the external position (actual position value) to the specified position. &#13;&#10;This value is set based on &quot;Modulo&quot; and the software limits. (New position = position)" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_INTUNIT"/>
    LMCAXIS_SET_SETPOS_INTUNIT,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on &quot;Modulo&quot; and the software limits. (New position = position)&#13;&#10;" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_INTUNIT"/>
    LMCAXIS_SET_SETPOS_INTUNIT_SPEC,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on &quot;Modulo&quot; and the software limits. &#13;&#10;With this variation, the MasterPosition is also reset. (New position = position)" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_INTUNIT_SPEC"/>
    LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD,  //! <Type Comment="Sets the external position (actual position value) to the specified position.&#13;&#10;This value is set based on the software limits. (New position = position)&#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD"/>
    LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on the software limits.(New position = position)&#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD"/>
    LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD_SW,  //! <Type Comment="Sets the external position (actual position value) to the specified position (New position = position).&#13;&#10;Here, no difference is made regarding modulo axes and the software limits are not checked." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD_SW"/>
    LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD_SW,  //! <Type Comment="Sets the internal position (set position value) to the specified position (New position = position).&#13;&#10;Here, no difference is made regarding modulo axes and the software limits are not checked." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD_SW"/>
    LMCAXIS_SET_ACTPOS_APPUNIT_DEST,  //! <Type Comment="Sets the external position (actual position value) to the specified position. &#13;&#10;This value is set based on &quot;Resolution&quot;, &quot;Modulo&quot; and the software limits. (New position = position * Resolution)&#13;&#10;Sets also the destination to the specified position." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_APPUNIT_DEST"/>
    LMCAXIS_SET_SETPOS_APPUNIT_DEST,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on &quot;Resolution&quot; ,&quot;Modulo&quot; and the software limits. (New position = position * Resolution)&#13;&#10;Sets also the destination to the specified position." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_APPUNIT_DEST"/>
    LMCAXIS_SET_ACTPOS_APPUNIT_WO_MOD_SW,  //! <Type Comment="Sets the external position (actual position value) to the specified position. &#13;&#10;This value is set based on &quot;Resolution&quot; and &quot;Modulo&quot;.(New position = position * Resolution)&#13;&#10;Here, no difference is made regarding modulo axes and the software limits are not checked." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_APPUNIT_WO_MOD_SW"/>
    LMCAXIS_SET_SETPOS_APPUNIT_WO_MOD_SW  //! <Type Comment="Sets the internal position (set position value) to the specified position. &#13;&#10;This value is set based on &quot;Resolution&quot; and &quot;Modulo&quot;.(New position = position * Resolution)&#13;&#10;Here, no difference is made regarding modulo axes and the software limits are not checked." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_APPUNIT_WO_MOD_SW"/>
  )$UDINT;
  _LMCAXIS_SETSERVER :  //! <Type Comment="Server-ID" Name="_LMCAXIS_SETSERVER"/>
  (
    LMCAXIS_SET_EXUNIT,  //! <Type Comment="Set new value for server ExUnit [Increments]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_EXUNIT"/>
    LMCAXIS_SET_INTUNIT,  //! <Type Comment="Set new value for server IntUnit [Application units]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_INTUNIT"/>
    LMCAXIS_SET_VMAX,  //! <Type Comment="Set new value for server VMax [Application units/s]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_VMAX"/>
    LMCAXIS_SET_AMAX,  //! <Type Comment="Set new value for server AMax [Application units/s²]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_AMAX"/>
    LMCAXIS_SET_SWMINPOS,  //! <Type Comment="Set new value for server SWMinPos [Application units]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_SWMINPOS"/>
    LMCAXIS_SET_SWMAXPOS,  //! <Type Comment="Set new value for server SWMaxPos [Application units]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_SWMAXPOS"/>
    LMCAXIS_SET_MODULO,  //! <Type Comment="Set new value for server Modulo [Application units]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_MODULO"/>
    LMCAXIS_SET_T_JERK,  //! <Type Comment="Set new value for server Tjerk [ms]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_T_JERK"/>
    LMCAXIS_SET_MOVETYPE,  //! <Type Comment="Set new value for server MoveType" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_MOVETYPE"/>
    LMCAXIS_SET_AEMERGENCY,  //! <Type Comment="Set new value for the server AEmergency [application units / sec²]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_AEMERGENCY"/>
    LMCAXIS_SET_JMAX  //! <Type Comment="Set a new value for server JMax [ApplicationUnits/sec²/ms]&#13;&#10;for MoveType = _JERK_PROFILE only." Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_JMAX"/>
  )$UDINT;
  _LMCAXIS_SETSWENDPOS :  //! <Type Comment="LMCAXIS_SET_SWMAX_APPUNIT&#13;&#10;New SW max end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_APPUNIT&#13;&#10;New SW min end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMAX_INTUNIT&#13;&#10;New SW max end position = Position&#13;&#10;This value is set based on Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_INTUNIT&#13;&#10;New SW min end position = Position &#13;&#10;This value is set based on Modulo.(new SW min end position = Position)&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD&#13;&#10;New SW Max end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD&#13;&#10;New SW min end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETSWENDPOS"/>
  (
    LMCAXIS_SET_SWMAX_APPUNIT,  //! <Type Comment="New SW max end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMAX_APPUNIT"/>
    LMCAXIS_SET_SWMIN_APPUNIT,  //! <Type Comment="New SW min end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMIN_APPUNIT"/>
    LMCAXIS_SET_SWMAX_INTUNIT,  //! <Type Comment="New SW max end position = Position&#13;&#10;This value is set based on Modulo." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMAX_INTUNIT"/>
    LMCAXIS_SET_SWMIN_INTUNIT,  //! <Type Comment="New SW min end position = Position &#13;&#10;This value is set based on Modulo.(new SW min end position = Position)" Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMIN_INTUNIT"/>
    LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD,  //! <Type Comment="New SW Max end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD"/>
    LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD  //! <Type Comment="New SW min end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD"/>
  )$UDINT;
  _LMCAXIS_STATUS : BDINT  //! <Type Comment="Status-Bits of the axis" Name="_LMCAXIS_STATUS"/>
  [
    1 PowerOn,  //! <Type Comment="Set if axis is activated" Name="_LMCAXIS_STATUS.PowerOn"/>
    2 IsReferenced,  //! <Type Comment="Set if axis is referenced" Name="_LMCAXIS_STATUS.IsReferenced"/>
    3 InPosition,  //! <Type Comment="Set if axis is in correct position" Name="_LMCAXIS_STATUS.InPosition"/>
    4 FiltRdy,  //! <Type Comment="Set if axis is in correct position an the jerkfilter is ready" Name="_LMCAXIS_STATUS.FiltRdy"/>
    5 Decell,  //! <Type Comment="Set if axis is braking" Name="_LMCAXIS_STATUS.Decell"/>
    6 PosLimActive,  //! <Type Comment="Set if axis has reached one of its endpositions" Name="_LMCAXIS_STATUS.PosLimActive"/>
    7 SetFlg,  //! <Type Comment="Set by calling one of the functions: SetPosition or ReferenceAxis&#13;&#10;Reset if the axis is activated" Name="_LMCAXIS_STATUS.SetFlg"/>
    8 EnLesFlg,  //! <Type Comment="Set if the axis moves endless / infinitely" Name="_LMCAXIS_STATUS.EnLesFlg"/>
    9 DirFlg,  //! <Type Comment="Set if the axis moves in negative direction - speed is negative" Name="_LMCAXIS_STATUS.DirFlg"/>
    10 EmergStop,  //! <Type Comment="Set if the axis stops because an error occured or the axis is deactivated" Name="_LMCAXIS_STATUS.EmergStop"/>
    11 Overflow,  //! <Type Comment="Set if a position-overflow occured" Name="_LMCAXIS_STATUS.Overflow"/>
    12 MasterLock,  //! <Type Comment="Set if the slave-axis is coupled onto a master-axis" Name="_LMCAXIS_STATUS.MasterLock"/>
    13 DirLock,  //! <Type Comment="the direction is locked&#13;&#10;(because of HWMin, HWMax&#13;&#10; or by PowerOnMode)" Name="_LMCAXIS_STATUS.DirLock"/>
    14 DynSwLimit,
    15 ActDirFlg,  //! <Type Comment="Set if the speed of the axis is negative" Name="_LMCAXIS_STATUS.ActDirFlg"/>
    16 HandFlg,  //! <Type Comment="Set if one of the functions: PowerOff or MoveHand is called" Name="_LMCAXIS_STATUS.HandFlg"/>
    17 ModuloFlg,  //! <Type Comment="Set if the axis is defined as a modulo-axis" Name="_LMCAXIS_STATUS.ModuloFlg"/>
    18 NCMotion,  //! <Type Comment="Set if the axis is in NC postion mode: &quot;_NCPositioning&quot;" Name="_LMCAXIS_STATUS.NCMotion"/>
    19 NoActPosMeth,  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoActPosMeth"/>
    20 NoControlMeth,  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;LMCController&quot; is not connected" Name="_LMCAXIS_STATUS.NoControlMeth"/>
    21 NoRefMeth,  //! <Type Comment="Set if the client &quot;LMCReference&quot; is not connected or&#13;&#10;the function &quot;CheckConnection&quot; returns &quot;FALSE&quot; or&#13;&#10;the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoRefMeth"/>
    22 NoActPosChk,  //! <Type Comment="Set if the client LMCSafety is connected and the function &quot;ChkHWReadyConnect&quot; returns &quot;FALSE&quot; or&#13;&#10;the client LMCSafety is not connected or&#13;&#10;the SimulateMode is active" Name="_LMCAXIS_STATUS.NoActPosChk"/>
    23 NoPreRtWork,  //! <Type Comment="Set if the client &quot;LMCPreRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPreRtWork"/>
    24 NoPostRtWork,  //! <Type Comment="Set if the client &quot;LMCPostRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPostRtWork"/>
    25 DelayedMasterLock,  //! <Type Comment="Set if the slave-axis is coupled onto a master-axis&#13;&#10;and reset when the MasterLock is 0 a configurable&#13;&#10;amount of cycles" Name="_LMCAXIS_STATUS.DelayedMasterLock"/>
    26 Standstill,  //! <Type Comment="Set if axis is not moving." Name="_LMCAXIS_STATUS.Standstill"/>
    27 BrakeForPowerOff,  //! <Type Comment="Set, if the axis is currently stoping for power off." Name="_LMCAXIS_STATUS.BrakeForPowerOff"/>
    28 MasterError,  //! <Type Comment="Set, if some error of the master axis occured." Name="_LMCAXIS_STATUS.MasterError"/>
    29 SlaveError,  //! <Type Comment="Set, if some error of a coupled slave axis occured." Name="_LMCAXIS_STATUS.SlaveError"/>
  ];
  _LMCAXIS_TUNE_MODE :  //! <Type Comment="Parameter of the function: &quot;TuneAxis&quot;&#13;&#10;Movement for the purpose of optimization of the control parameters" Name="_LMCAXIS_TUNE_MODE"/>
  (
    LMCAXIS_TUNE_POSITON_IN_NEGATIVE_DIRECTION:=4294967294,  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Relative movement in negative direction" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_POSITON_IN_NEGATIVE_DIRECTION"/>
    LMCAXIS_TUNE_ZERO_TO_NEGATIVE_POSITION:=4294967295,  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Movement in negative direction between position-input and zero-position" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_ZERO_TO_NEGATIVE_POSITION"/>
    LMCAXIS_TUNE_ACTPOSITION_POSITION,  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Movement between the current position and the position added to the current one" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_ACTPOSITION_POSITION"/>
    LMCAXIS_TUNE_ZERO_TO_POSITIVE_POSITION,  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Movement in positive direction between position-input and zero-position" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_ZERO_TO_POSITIVE_POSITION"/>
    LMCAXIS_TUNE_POSITON_IN_POSITIVE_DIRECTION  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Relative movement in positiv direction" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_POSITON_IN_POSITIVE_DIRECTION"/>
  )$DINT;
#pragma pack(push, 1)
  _LMCCommonCalcParas : STRUCT  //! <Type Comment="Common calculation parameters." Name="_LMCCommonCalcParas"/>
    ResolutionInt : DINT;  //! <Type Comment="Internal scale factor" Name="_LMCCommonCalcParas.ResolutionInt"/>
    Hires : UDINT;  //! <Type Comment="Number of RtWork() cycles per second." Name="_LMCCommonCalcParas.Hires"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCCONTROLLERTYPE :
  (
    _LMCNOCONTROLLER,  //! <Type Comment="no controller" Name="_LMCCONTROLLERTYPE._LMCNOCONTROLLER"/>
    _LMCUSERCONTROLLER,  //! <Type Comment="user defined controller" Name="_LMCCONTROLLERTYPE._LMCUSERCONTROLLER"/>
    _LMCDUMMYCONTROLLER,  //! <Type Comment="DummyController" Name="_LMCCONTROLLERTYPE._LMCDUMMYCONTROLLER"/>
    _LMCHYDROCONTROLLER,  //! <Type Comment="HydroController" Name="_LMCCONTROLLERTYPE._LMCHYDROCONTROLLER"/>
    _LMCKV_CONTROLLER,  //! <Type Comment="KV_Controller" Name="_LMCCONTROLLERTYPE._LMCKV_CONTROLLER"/>
    _LMCNCCONTROLLER,  //! <Type Comment="NCController" Name="_LMCCONTROLLERTYPE._LMCNCCONTROLLER"/>
    _LMCPOSCONTROLLER,  //! <Type Comment="PosController" Name="_LMCCONTROLLERTYPE._LMCPOSCONTROLLER"/>
    _LMCDRIVEPOSONTROL,  //! <Type Comment="DrivePosController" Name="_LMCCONTROLLERTYPE._LMCDRIVEPOSONTROL"/>
    _LMCKV_CONTROLLER_NEW:=104,  //! <Type Comment="_LMCKVController" Name="_LMCCONTROLLERTYPE._LMCKV_CONTROLLER_NEW"/>
    _LMCUSERCONTROLLER_NEW:=101,
    _LMCPOSCONTROLLER_NEW:=106,  //! <Type Comment="_LMCPosController" Name="_LMCCONTROLLERTYPE._LMCPOSCONTROLLER_NEW"/>
    _LMCSIGMATEKCONTROLLER:=107,  //! <Type Comment="_LMCSigController" Name="_LMCCONTROLLERTYPE._LMCSIGMATEKCONTROLLER"/>
    _LMCCALCMODEL_CONTROLLER  //! <Type Comment="_LMCVirtualPosController" Name="_LMCCONTROLLERTYPE._LMCCALCMODEL_CONTROLLER"/>
  )$UDINT;
  _LMCPROF_ACTUALVALUES :
  (
    _LMCPROF_ACTUALPATH,  //! <Type Comment="Path length already travelled within the current internal move segment [internal units].&#13;&#10;" Name="_LMCPROF_ACTUALVALUES._LMCPROF_ACTUALPATH"/>
    _LMCPROF_PATHLENGTH,  //! <Type Comment="Path length of currently travelled internal move segment [internal units]" Name="_LMCPROF_ACTUALVALUES._LMCPROF_PATHLENGTH"/>
    _LMCPROF_V_PATH,  //! <Type Comment="Path speed [internal units/tick]" Name="_LMCPROF_ACTUALVALUES._LMCPROF_V_PATH"/>
    _LMCPROF_ACTUALPATH_ORIG,  //! <Type Comment="Path length already travelled within an NC-block [internal units].&#13;&#10;Starts with 0 at the beginning of an NC-block." Name="_LMCPROF_ACTUALVALUES._LMCPROF_ACTUALPATH_ORIG"/>
    _LMCPROF_PATHLENGTH_ORIG,  //! <Type Comment="Path length of currently travelled NC-block [internal units]" Name="_LMCPROF_ACTUALVALUES._LMCPROF_PATHLENGTH_ORIG"/>
    _LMCPROF_DELTA_S  //! <Type Comment="Path length travelled within the last tick [internal units]." Name="_LMCPROF_ACTUALVALUES._LMCPROF_DELTA_S"/>
  )$UDINT;
#pragma pack(push, 1)
  _LMCPROF_CIRCLEPOINT : STRUCT  //! <Type Comment="Absolute Position of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT"/>
    Point1 : DINT;  //! <Type Comment="Absolute 1st coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point1"/>
    Point2 : DINT;  //! <Type Comment="Absolute 2nd coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point2"/>
    Point3 : DINT;  //! <Type Comment="Absolute 3rd coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point3"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCPROF_CMDINDEX :
  (
    _LMCPROF_LASTLOADED,  //! <Type Comment="Last loaded command" Name="_LMCPROF_CMDINDEX._LMCPROF_LASTLOADED"/>
    _LMCPROF_ACTCMD,  //! <Type Comment="Actual command" Name="_LMCPROF_CMDINDEX._LMCPROF_ACTCMD"/>
    _LMCPROF_VORANZ,  //! <Type Comment="Commands that are not executeted now" Name="_LMCPROF_CMDINDEX._LMCPROF_VORANZ"/>
    _LMCPROF_SUMINDEX,  //! <Type Comment="Number of entries in the UserBuffer remaining to be traversed." Name="_LMCPROF_CMDINDEX._LMCPROF_SUMINDEX"/>
    _LMCPROF_LASTLOADED_I,  //! <Type Comment="Last loaded command" Name="_LMCPROF_CMDINDEX._LMCPROF_LASTLOADED_I"/>
    _LMCPROF_ACTCMD_I  //! <Type Comment="Actual command" Name="_LMCPROF_CMDINDEX._LMCPROF_ACTCMD_I"/>
  )$UDINT;
  _LMCPROF_EXECUTE :  //! <Type Comment="Time of command execution" Name="_LMCPROF_EXECUTE"/>
  (
    LMCPROF_BUFFERED,  //! <Type Comment="The command is placed into the internal buffer.&#13;&#10;It is executed when all buffered motion commands before it are finished." Name="_LMCPROF_EXECUTE.LMCPROF_BUFFERED"/>
    LMCPROF_IMMEDIATE  //! <Type Comment="The command is executed immediately." Name="_LMCPROF_EXECUTE.LMCPROF_IMMEDIATE"/>
  )$UDINT;
  _LMCPROFCMDTYPES :  //! <Type Comment="Move command type" Name="_LMCPROFCMDTYPES"/>
  (
    CMD_Nothing,  //! <Type Comment="Empty buffer entry / no movement" Name="_LMCPROFCMDTYPES.CMD_Nothing"/>
    CMD_Linear:=2,  //! <Type Comment="Linear movement" Name="_LMCPROFCMDTYPES.CMD_Linear"/>
    CMD_CircleCW:=5,  //! <Type Comment="Circular movement clockwise" Name="_LMCPROFCMDTYPES.CMD_CircleCW"/>
    CMD_CircleCCW:=4,  //! <Type Comment="Circular movement counter clockwise" Name="_LMCPROFCMDTYPES.CMD_CircleCCW"/>
    CMD_MoveCurve:=12,  //! <Type Comment="Evasive movement with MoveCurve()" Name="_LMCPROFCMDTYPES.CMD_MoveCurve"/>
    CMD_Circle3D:=13,  //! <Type Comment="Circular movement in 3 dimensions" Name="_LMCPROFCMDTYPES.CMD_Circle3D"/>
    CMD_SetProfPos:=20  //! <Type Comment="Set profile positions command" Name="_LMCPROFCMDTYPES.CMD_SetProfPos"/>
  )$UDINT;
  _LMCPROFINTCMDCONFIG : BDINT  //! <Type Comment="Move command flags" Name="_LMCPROFINTCMDCONFIG"/>
  [
    1 CmdActive,  //! <Type Comment="1: the movement calculations are finished." Name="_LMCPROFINTCMDCONFIG.CmdActive"/>
    2 RapidTraverse,  //! <Type Comment="1: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFINTCMDCONFIG.RapidTraverse"/>
    3 FeedRateInterpolation,  //! <Type Comment="1: feed rate interpolation selected" Name="_LMCPROFINTCMDCONFIG.FeedRateInterpolation"/>
    4 SecondTransition,  //! <Type Comment="0: this is the first transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected&#13;&#10;1: this is the second transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected" Name="_LMCPROFINTCMDCONFIG.SecondTransition"/>
    5 IsProgrammedExactStop,  //! <Type Comment="this path segment was programmed with TransitionMode:=_LMCPROF_EXACT_STOP" Name="_LMCPROFINTCMDCONFIG.IsProgrammedExactStop"/>
    6 AfterSetPosCmd,  //! <Type Comment="The command before this one is a SetProfilePositions(). This command maybe needs to be recomputed." Name="_LMCPROFINTCMDCONFIG.AfterSetPosCmd"/>
    7 MoveCurveSplineInserted,
    8 MoveCurveSplineExecuting,
    9 MoveCurvePathPerThousand,
    17 PathLenReduced,  //! <Type Comment="The pathlength was reduced when inserting a transition movement (spline etc.).&#13;&#10;The attainable entry speed must be calculated new." Name="_LMCPROFINTCMDCONFIG.PathLenReduced"/>
    25 Activated,
    26 WaitFinish,
  ];
  _LMCPROFTRANSMODES :  //! <Type Comment="Transition type between path segments" Name="_LMCPROFTRANSMODES"/>
  (
    _LMCPROF_EXACT_STOP:=0,  //! <Type Comment="There is an exact stop after this movement" Name="_LMCPROFTRANSMODES._LMCPROF_EXACT_STOP"/>
    _LMCPROF_CONT_DIRECT:=2,  //! <Type Comment="The transition between path segments is executed in the smooth rounding mode." Name="_LMCPROFTRANSMODES._LMCPROF_CONT_DIRECT"/>
    _LMCPROF_SMOOTH_CUBIC,  //! <Type Comment="The transition between path segments is executed with a cubic spline." Name="_LMCPROFTRANSMODES._LMCPROF_SMOOTH_CUBIC"/>
    _LMCPROF_SMOOTH_PARAB,  //! <Type Comment="The transition between path segments is executed in the rounding mode with tolerance sphere." Name="_LMCPROFTRANSMODES._LMCPROF_SMOOTH_PARAB"/>
    _LMCPROF_SMOOTH_QUINT
  )$UDINT;
  _LMCPROFCIRCLEDEF : BDINT  //! <Type Comment="Circle axes definition" Name="_LMCPROFCIRCLEDEF"/>
  [
    1 Axis1,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis1"/>
    2 Axis2,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis2"/>
    3 Axis3,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis3"/>
    4 Axis4,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis4"/>
    5 Axis5,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis5"/>
    6 Axis6,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis6"/>
    7 Axis7,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis7"/>
    8 Axis8,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis8"/>
    9 Axis9,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis9"/>
  ];
#pragma pack(push, 1)
  _LMCPROF_POSITIONS : STRUCT  //! <Type Comment="Start and end positions of an axis [Internal units]" Name="_LMCPROF_POSITIONS"/>
    start : DINT;  //! <Type Comment="[Internal units]" Name="_LMCPROF_POSITIONS.start"/>
    end : DINT;  //! <Type Comment="[Internal units]" Name="_LMCPROF_POSITIONS.end"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _LMCPROF_MoveData : STRUCT  //! <Type Comment="Element of the profile buffer " Name="_LMCPROF_MoveData"/>
    index : UDINT;  //! <Type Comment="Index in the profile buffer" Name="_LMCPROF_MoveData.index"/>
    enCmdType : _LMCPROFCMDTYPES;  //! <Type Comment="Move command type" Name="_LMCPROF_MoveData.enCmdType"/>
    bsCmdFlags : _LMCPROFINTCMDCONFIG;  //! <Type Comment="Move command flags" Name="_LMCPROF_MoveData.bsCmdFlags"/>
    enTransitionMode : _LMCPROFTRANSMODES;  //! <Type Comment="Type of transition between path segments" Name="_LMCPROF_MoveData.enTransitionMode"/>
    dTransitionRadius : DINT;  //! <Type Comment="Radius of the tolerance sphere. Used for the smooth rounding mode, the rounding mode with tolerance sphere and for the rounding mode with cubic spline." Name="_LMCPROF_MoveData.dTransitionRadius"/>
    bdCirAxis : _LMCPROFCIRCLEDEF;  //! <Type Comment="Defines the circle axes." Name="_LMCPROF_MoveData.bdCirAxis"/>
    stPositions : ARRAY [0.._LMC_MAX_AXIS-1] OF _LMCPROF_POSITIONS;  //! <Type Comment="Start and end positions of all axes [Internal units]" Name="_LMCPROF_MoveData.stPositions"/>
    xMp : DINT;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the first circle axis [Internal units]" Name="_LMCPROF_MoveData.xMp"/>
    yMp : DINT;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the second circle axis [Internal units]" Name="_LMCPROF_MoveData.yMp"/>
    PathLength : DINT;  //! <Type Comment="Path length [Internal units]" Name="_LMCPROF_MoveData.PathLength"/>
    vMax : DINT;  //! <Type Comment="Max. allowed path speed [Internal units/tick]" Name="_LMCPROF_MoveData.vMax"/>
    aMax : DINT;  //! <Type Comment="Max. allowed path acceleration [Internal units/tick²]" Name="_LMCPROF_MoveData.aMax"/>
    dMax : DINT;  //! <Type Comment="Max. allowed path deceleration [Internal units/tick²]" Name="_LMCPROF_MoveData.dMax"/>
    jMax : DINT;  //! <Type Comment="Max. allowed path jerk [Internal units/tick²/sec]" Name="_LMCPROF_MoveData.jMax"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _LMCPROF_OBSTACLE : STRUCT  //! <Type Public="true" Comment="Data for MoveCurve definition" Name="_LMCPROF_OBSTACLE"/>
    PathPerThousand : BOOL;  //! <Type Comment="FALSE: The distances Obstacle.PathStart and Obstacle.PathEnd are given in application units.&#13;&#10;TRUE: The distances Obstacle.PathStart and Obstacle.PathEnd are given in parts per thousand of the path length." Name="_LMCPROF_OBSTACLE.PathPerThousand"/>
    HeightStart_relativ : DINT;  //! <Type Comment="The evasive movement starts with an &quot;linear up movement&quot;. This value defines its height. &#13;&#10;distance in [application units]" Name="_LMCPROF_OBSTACLE.HeightStart_relativ"/>
    AxisNr : DINT;  //! <Type Comment="Number of axis, in which direction the evasive movement should be performed [1-9]." Name="_LMCPROF_OBSTACLE.AxisNr"/>
    HeightEnd_relativ : DINT;  //! <Type Comment="The evasive movement ends with a &quot;linear down movement&quot;. This value defines its height. &#13;&#10;distance in [application units]" Name="_LMCPROF_OBSTACLE.HeightEnd_relativ"/>
    PathStart : DINT;  //! <Type Comment="position, where the HeightStart_absolute should be reached.&#13;&#10;&#13;&#10;Depending on the _LMCPROF_OBSTACLE struct element PathPerThousand the length is given in application units or in parts per thousand of the length of the &quot;vertical&quot; movement." Name="_LMCPROF_OBSTACLE.PathStart"/>
    HeightStart_absolut : DINT;  //! <Type Comment="position of the evasive axis at PathStart [application units]" Name="_LMCPROF_OBSTACLE.HeightStart_absolut"/>
    PathEnd : DINT;  //! <Type Comment="position, where the HeightEnd_absolute should be reached. The distance is measured from the end of the vertical movement.&#13;&#10;&#13;&#10;Depending on the _LMCPROF_OBSTACLE struct element PathPerThousand the length is given in application units or in parts per thousand of the length of the &quot;vertical&quot; movement.&#13;&#10;&#13;&#10;This value is ignored, if PathEnd + PathStart is longer then the vertical distance." Name="_LMCPROF_OBSTACLE.PathEnd"/>
    HeightEnd_absolut : DINT;  //! <Type Comment="position of the evasive axis at PathEnd [application units]&#13;&#10;&#13;&#10;This value is ignored, if PathEnd + PathStart is longer then the vertical distance." Name="_LMCPROF_OBSTACLE.HeightEnd_absolut"/>
    VelStart_relativ_ppT : DINT;  //! <Type Comment="value &gt; 0: maximal velocity of the starting linear up movement in parts per thousand of the programmed Velocity value.&#13;&#10;&#13;&#10;value &lt;= 0: maximal velocity of the starting linear up movement equals the programmed Velocity." Name="_LMCPROF_OBSTACLE.VelStart_relativ_ppT"/>
    VelEnd_relativ_ppT : DINT;  //! <Type Comment="value &gt; 0: maximal velocity of the ending linear down movement in parts per thousand of the programmed Velocity value.&#13;&#10;&#13;&#10;value &lt;= 0: maximal velocity of the ending linear down movement equals the programmed Velocity." Name="_LMCPROF_OBSTACLE.VelEnd_relativ_ppT"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCPROF_OPMODE :  //! <Type Comment="Operating mode" Name="_LMCPROF_OPMODE"/>
  (
    _LMC_AUTOMATIC,  //! <Type Comment="The loaded sequences are started automatically." Name="_LMCPROF_OPMODE._LMC_AUTOMATIC"/>
    _LMC_MANUAL  //! <Type Comment="The loaded sequences are not started automatically. Server &apos;Start&apos; must be set to 1." Name="_LMCPROF_OPMODE._LMC_MANUAL"/>
  )$UDINT;
#pragma pack(push, 1)
  _LMCPROF_POS : STRUCT  //! <Type Comment="Absolute Endpositions / relative distances of all Axes [Application Units]" Name="_LMCPROF_POS"/>
    Pos1 : DINT;  //! <Type Comment="Absolute Endposition of Axis1 [Application Units]" Name="_LMCPROF_POS.Pos1"/>
    Pos2 : DINT;  //! <Type Comment="Absolute Endposition of Axis2 [Application Units]" Name="_LMCPROF_POS.Pos2"/>
    Pos3 : DINT;  //! <Type Comment="Absolute Endposition of Axis3 [Application Units]" Name="_LMCPROF_POS.Pos3"/>
    Pos4 : DINT;  //! <Type Comment="Absolute Endposition of Axis4 [Application Units]" Name="_LMCPROF_POS.Pos4"/>
    Pos5 : DINT;  //! <Type Comment="Absolute Endposition of Axis5 [Application Units]" Name="_LMCPROF_POS.Pos5"/>
    Pos6 : DINT;  //! <Type Comment="Absolute Endposition of Axis6 [Application Units]" Name="_LMCPROF_POS.Pos6"/>
    Pos7 : DINT;  //! <Type Comment="Absolute Endposition of Axis7 [Application Units]" Name="_LMCPROF_POS.Pos7"/>
    Pos8 : DINT;  //! <Type Comment="Absolute Endposition of Axis8 [Application Units]" Name="_LMCPROF_POS.Pos8"/>
    Pos9 : DINT;  //! <Type Comment="Absolute Endposition of Axis9 [Application Units]" Name="_LMCPROF_POS.Pos9"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCPROF_RECOUPLEMODE :
  (
    _LMCPROF_RECOUPLE_TO_PROFILE:=0,  //! <Type Comment="recouple the axis to the Profile position" Name="_LMCPROF_RECOUPLEMODE._LMCPROF_RECOUPLE_TO_PROFILE"/>
    _LMCPROF_RECOUPLE_TO_ACTPOS:=1  //! <Type Comment="recouple the axis to the actual position" Name="_LMCPROF_RECOUPLEMODE._LMCPROF_RECOUPLE_TO_ACTPOS"/>
  )$UDINT;
  _LMCPROF_RESTIME_CALCMODE :  //! <Type Comment="Modus of calculation of the Residualtime" Name="_LMCPROF_RESTIME_CALCMODE"/>
  (
    LMCPROF_TONEXT_STOPP,  //! <Type Comment="The remaining way and the actual velocity of the acting record-set is employed for calculation of the remaining time" Name="_LMCPROF_RESTIME_CALCMODE.LMCPROF_TONEXT_STOPP"/>
    LMCPROF_TO_NEXT_PATH_SEGMENT,
    LMCPROF_TO_NEXT_PATH_SEGMENT_ORIG
  )$UDINT;
  _LMCPROF_SETPOS_MODE :  //! <Type Comment="Mode defines how we get the set positions." Name="_LMCPROF_SETPOS_MODE"/>
  (
    _LMCPROF_SETPOS_TO_AXES_POS,  //! <Type Comment="The profile positions will be set to the master position of the LMCAxis object.&#13;&#10;&#13;&#10;E.g. This mode may be used to set the profile back to the correct position after adding some discrepancy with CoupleAdditivePosDiff" Name="_LMCPROF_SETPOS_MODE._LMCPROF_SETPOS_TO_AXES_POS"/>
    _LMCPROF_SETPOS_TO_USER_POS,  //! <Type Comment="The profile positions will be set to the positions, which are returned from the methode SetProfPosCallback(). Please overwrite this private methode.&#13;&#10;&#13;&#10;The _LMCAxis objects may move to this new position in the fastest possible way." Name="_LMCPROF_SETPOS_MODE._LMCPROF_SETPOS_TO_USER_POS"/>
    _LMCPROF_SETPOS_TO_USER_POS_NO_AX_TRAVEL  //! <Type Comment="The profile positions will be set to the positions, which are returned from the methode SetProfPosCallback(). Please overwrite this private methode.&#13;&#10;&#13;&#10;The _LMCAxis objects will ignore this position jump. They will move relative to the new profile positions, but the position discrepancy may last." Name="_LMCPROF_SETPOS_MODE._LMCPROF_SETPOS_TO_USER_POS_NO_AX_TRAVEL"/>
  )$UDINT;
  _LMCPROFCMDCONFIG : BDINT  //! <Type Comment="Move command flags" Name="_LMCPROFCMDCONFIG"/>
  [
    1 RapidTraverse,  //! <Type Comment="True: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFCMDCONFIG.RapidTraverse"/>
    2 CircleCW,  //! <Type Comment="True: circular movement clockwise in case of a 2-dimensional movement&#13;&#10;True: circular movement dromic in case of a 3-dimensional movement" Name="_LMCPROFCMDCONFIG.CircleCW"/>
    3 CircleCCW,  //! <Type Comment="True: circular movement counter clockwise in case of a 2-dimensional movement&#13;&#10;True: circular movement antidromic in case of a 3-dimensional movement" Name="_LMCPROFCMDCONFIG.CircleCCW"/>
    4 FeedRateInterpolation,  //! <Type Comment="True: feed rate interpolation selected. The feedrate changes linearly over the path length." Name="_LMCPROFCMDCONFIG.FeedRateInterpolation"/>
  ];
  _LMCPROFCMDTYPES_INTERN :  //! <Type Comment="Move command type" Name="_LMCPROFCMDTYPES_INTERN"/>
  (
    _LMCPROF_CMD_Nothing,  //! <Type Comment="Empty buffer entry" Name="_LMCPROFCMDTYPES_INTERN._LMCPROF_CMD_Nothing"/>
    _LMCMT_NoPosChange,  //! <Type Comment="Move command with zero path length, i.e. a linear movement where the end positions are equal to the start positions." Name="_LMCPROFCMDTYPES_INTERN._LMCMT_NoPosChange"/>
    _LMCMT_Linear,  //! <Type Comment="Linear movement" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Linear"/>
    _LMCMT_SpeedLimit,  //! <Type Comment="This command reduces the path speed so that the speed jump or acceleration jump is not exceeded." Name="_LMCPROFCMDTYPES_INTERN._LMCMT_SpeedLimit"/>
    _LMCMT_CircleCCW,  //! <Type Comment="Circle Movement Counter-Clockwise in case of 2-dimensional Movement&#13;&#10;Circle Movement antidromic in case of 3-dimensional Movement" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_CircleCCW"/>
    _LMCMT_CircleCW,  //! <Type Comment="Circle Movement Clockwise in case of 2-dimensional Movement&#13;&#10;Circle Movement dromic in case of 3-dimensional Movement" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_CircleCW"/>
    _LMCMT_Round_All,  //! <Type Comment="A linear-linear transition when _LMCPROF_SMOOTH_PARAB is selected" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Round_All"/>
    _LMCMT_Lin_Round_Aux,  //! <Type Comment="The linear part of a linear-circular or circular-linear transition when _LMCPROF_SMOOTH_PARAB is selected" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Lin_Round_Aux"/>
    _LMCMT_Circle_Lin_Round_Aux,  //! <Type Comment="The circular part of a linear-circular or circular-linear transition when _LMCPROF_SMOOTH_PARAB is selected" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Circle_Lin_Round_Aux"/>
    _LMCMT_SplineCub,  //! <Type Comment="Transition formed by a cubic spline" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_SplineCub"/>
    _LMCMT_SplineQuint,  //! <Type Comment="Transition formed by a 5th order spline" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_SplineQuint"/>
    _LMCMT_Fourier,
    _LMCMT_MoveCurve,  //! <Type Comment="Evasive movement with MoveCurve()&#13;&#10;ONLY USED FOR INSERTING INTO USERBUFFER." Name="_LMCPROFCMDTYPES_INTERN._LMCMT_MoveCurve"/>
    _LMCMT_Circle3D,  //! <Type Comment="circle in 3 dimensions&#13;&#10;ONLY USED FOR INSERTING INTO USERBUFFER." Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Circle3D"/>
    _LMCMT_SetProfPos:=20  //! <Type Comment="Set profile positions command" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_SetProfPos"/>
  )$UDINT;
  _LMCPROFERRORTYPES :  //! <Type Comment="Error numbers" Name="_LMCPROFERRORTYPES"/>
  (
    _LMCPROF_NoError,  //! <Type Comment="No error occured" Name="_LMCPROFERRORTYPES._LMCPROF_NoError"/>
    _LMCPROF_INIT_ERROR,  //! <Type Comment="Not enough memory for the profile buffer&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_INIT_ERROR"/>
    _LMCPROF_MOVECMD_ERROR,  //! <Type Comment="Unknown move command" Name="_LMCPROFERRORTYPES._LMCPROF_MOVECMD_ERROR"/>
    _LMCPROF_INT_POINTER_ERROR,  //! <Type Comment="Internal pointer error" Name="_LMCPROFERRORTYPES._LMCPROF_INT_POINTER_ERROR"/>
    _LMCPROF_JUMP_CMD_ERROR,  //! <Type Comment="After a jump active command there is no active entry in the buffer&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_JUMP_CMD_ERROR"/>
    _LMCPROF_POS_OVERRUN_ERROR,  //! <Type Comment="Set position overrun" Name="_LMCPROFERRORTYPES._LMCPROF_POS_OVERRUN_ERROR"/>
    _LMCPROF_AXIS_ERROR,  //! <Type Comment="One of the coupled axes has an error" Name="_LMCPROFERRORTYPES._LMCPROF_AXIS_ERROR"/>
    _LMCPROF_SWE_ERROR,  //! <Type Comment="SW end position violation while loading the command&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_SWE_ERROR"/>
    _LMCPROF_CIRDEF_ERROR,  //! <Type Comment="The circle definition is wrong" Name="_LMCPROFERRORTYPES._LMCPROF_CIRDEF_ERROR"/>
    _LMCPROF_NO_POS_CHANGE,  //! <Type Comment="Move command without any axes travel" Name="_LMCPROFERRORTYPES._LMCPROF_NO_POS_CHANGE"/>
    _LMCPROF_GROUP_ERROR,  //! <Type Comment="Change Command to this Group is not possible because the Set Group has no Distance / SubError: Set GroupNr" Name="_LMCPROFERRORTYPES._LMCPROF_GROUP_ERROR"/>
    _LMCPROF_KOFAC_ERROR,  //! <Type Comment="Division error in the calculation of the coupling factors / Sub error shows the axis number&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_KOFAC_ERROR"/>
    _LMCPROF_VEL_CMD_ERROR,  //! <Type Comment="Movement speed &lt; 1" Name="_LMCPROFERRORTYPES._LMCPROF_VEL_CMD_ERROR"/>
    _LMCPROF_ACC_CMD_ERROR,  //! <Type Comment="Movement acceleration / deceleration &lt; 1&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_ACC_CMD_ERROR"/>
    _LMCPROF_JERK_CMD_ERROR,  //! <Type Comment="Movement jerk &lt; 1" Name="_LMCPROFERRORTYPES._LMCPROF_JERK_CMD_ERROR"/>
    _LMCPROF_RESOLUTION_ERROR,  //! <Type Comment="Error occured while loading the command,the entries are bigger than 2^31 when multiplied by the resolution factor." Name="_LMCPROFERRORTYPES._LMCPROF_RESOLUTION_ERROR"/>
    _LMCPROF_SAFETY_ZONES_REACHED,  //! <Type Comment="User has reached a safety zone" Name="_LMCPROFERRORTYPES._LMCPROF_SAFETY_ZONES_REACHED"/>
    _LMCPROF_INSERT_ERROR,  //! <Type Comment="The profile buffer is full" Name="_LMCPROFERRORTYPES._LMCPROF_INSERT_ERROR"/>
    _LMCPROF_AXIS_NOT_CONNECTED,  //! <Type Comment="Selected axis was not found or is not connected." Name="_LMCPROFERRORTYPES._LMCPROF_AXIS_NOT_CONNECTED"/>
    _LMCPROF_GROUP_NOT_FOUND,  //! <Type Comment="Selected group is not configured in the system" Name="_LMCPROFERRORTYPES._LMCPROF_GROUP_NOT_FOUND"/>
    _LMCPROF_PARAMETER_NOT_FOUND,  //! <Type Comment="Selected parameter was not found in the settings" Name="_LMCPROFERRORTYPES._LMCPROF_PARAMETER_NOT_FOUND"/>
    _LMCPROF_PARAMETER_ERROR,  //! <Type Comment="Enabling or disabling the selected function is impossible" Name="_LMCPROFERRORTYPES._LMCPROF_PARAMETER_ERROR"/>
    _LMCPROF_ERROR_BUSY,  //! <Type Comment="Changing a parameter is not allowed in the current state" Name="_LMCPROFERRORTYPES._LMCPROF_ERROR_BUSY"/>
    _LMCPROF_OUT_OF_RANGE,  //! <Type Comment="Parameter value is too big or too small" Name="_LMCPROFERRORTYPES._LMCPROF_OUT_OF_RANGE"/>
    _LMCPROF_RADIUS_ERROR,  //! <Type Comment="Circle radius is out of range (radius &gt; 2^31 - 1 [Internal units])." Name="_LMCPROFERRORTYPES._LMCPROF_RADIUS_ERROR"/>
    _LMCPROF_ARCLEN_ERROR,  //! <Type Comment="Circle arc length is out of range (arc length &gt; 2^31 - 1 [Internal units])." Name="_LMCPROFERRORTYPES._LMCPROF_ARCLEN_ERROR"/>
    _LMCPROF_RES_PATHLEN_ERROR:=26,  //! <Type Comment="The residual path length is out of range (residual path length &gt; 2^31 - 1 [Internal units])." Name="_LMCPROFERRORTYPES._LMCPROF_RES_PATHLEN_ERROR"/>
    _LMCPROF_ENDPOS_ERROR,  //! <Type Comment="The end position of a move is out of range (end position &gt; 2^31 - 1 [Internal units]).&#13;&#10;Check SetBasicParameter(.., PosOffseti, ..)" Name="_LMCPROFERRORTYPES._LMCPROF_ENDPOS_ERROR"/>
    _LMCPROF_AXTRAVEL_ERROR,  //! <Type Comment="The axis travel distance is out of range (end position - start position &gt; 2^31 - 1 [Internal units])." Name="_LMCPROFERRORTYPES._LMCPROF_AXTRAVEL_ERROR"/>
    _LMCPROF_AX_COUPLE_ERROR,  //! <Type Comment="Some axis coupling command (CoupleGearAbsolute etc.) returned an error." Name="_LMCPROFERRORTYPES._LMCPROF_AX_COUPLE_ERROR"/>
    _LMCPROF_PLAINEDEF_ERROR,  //! <Type Comment="The Plaine of the Circle is not defined" Name="_LMCPROFERRORTYPES._LMCPROF_PLAINEDEF_ERROR"/>
    _LMCPROF_VEC_ERROR,  //! <Type Comment="Coordinates of vectors used for calcualtion of a circle are out of range" Name="_LMCPROFERRORTYPES._LMCPROF_VEC_ERROR"/>
    _LMCPROF_LOCKGROUP_ERROR,  //! <Type Comment="Slave-Group of an Axis is undefined." Name="_LMCPROFERRORTYPES._LMCPROF_LOCKGROUP_ERROR"/>
    _LMCPROF_LINEDEF_ERROR,  //! <Type Comment="The definition of the endpositions for the linear movement is wrong." Name="_LMCPROFERRORTYPES._LMCPROF_LINEDEF_ERROR"/>
    _LMCPROF_CHORDLEN_ERROR,  //! <Type Comment="The start point or the endpoint of the circle is identical to the center point.&#13;&#10;The circle will be replaced by a line." Name="_LMCPROFERRORTYPES._LMCPROF_CHORDLEN_ERROR"/>
    _LMCPROF_LOCKGROUP_DIFF_RESTART,  //! <Type Comment="Axes group assignment at restart differs from the original axes assignment." Name="_LMCPROFERRORTYPES._LMCPROF_LOCKGROUP_DIFF_RESTART"/>
    _LMCPROF_REFPOINT_DIFF_RESTART,  //! <Type Comment="Axes geometric reference point at restart differs from the original geometric reference point." Name="_LMCPROFERRORTYPES._LMCPROF_REFPOINT_DIFF_RESTART"/>
    _LMCPROF_AXIS_POS_ERROR,  //! <Type Comment="The axis is not at the correct start / restart position." Name="_LMCPROFERRORTYPES._LMCPROF_AXIS_POS_ERROR"/>
    _LMCPROF_INPOSITION_TIMEOUT_ERROR,  //! <Type Comment="After performing an exact stop the actual axis positions have not reached their target position for too long." Name="_LMCPROFERRORTYPES._LMCPROF_INPOSITION_TIMEOUT_ERROR"/>
    _LMCROBOT_REF_ERROR:=1000,
    _LMCROBOT_AX_COUPLING_ERROR,
    _LMCROBOT_BACKUP_POS_ERROR,  //! <Type Comment="The positions stored at the last PowerOff are invalid." Name="_LMCPROFERRORTYPES._LMCROBOT_BACKUP_POS_ERROR"/>
    _LMCROBOT_POWERON_ERROR,  //! <Type Comment="The PowerOn-command failed." Name="_LMCPROFERRORTYPES._LMCROBOT_POWERON_ERROR"/>
    _LMCROBOT_POS_CHECK_ERROR,  //! <Type Comment="There position validation returned an error" Name="_LMCPROFERRORTYPES._LMCROBOT_POS_CHECK_ERROR"/>
    _LMCROBOT_LINEUP_AX_ERROR,  //! <Type Comment="There was an axis error during position lineup" Name="_LMCPROFERRORTYPES._LMCROBOT_LINEUP_AX_ERROR"/>
    _LMCROBOT_COUPLE_TIMEOUT,  //! <Type Comment="The coupling of the motor axes timed out" Name="_LMCPROFERRORTYPES._LMCROBOT_COUPLE_TIMEOUT"/>
    _LMCROBOT_AX_COUPLING_LOST,  //! <Type Comment="The coupling of the motor axes was lost" Name="_LMCPROFERRORTYPES._LMCROBOT_AX_COUPLING_LOST"/>
    _LMCROBOT_AXIS_ERROR,  //! <Type Comment="One of the coupled motor axes has an error" Name="_LMCPROFERRORTYPES._LMCROBOT_AXIS_ERROR"/>
    _LMCROBOT_BELTCOUPLING_ERROR,
    _LMCROBOT_COORDSYSTEM_ERROR,
    _LMCROBOT_AX_CMD_ERROR,
    _LMCROBOT_KINEMATIC_ERROR
  )$UDINT;
#pragma pack(push, 1)
  _LMCPROFERRORDEF : STRUCT  //! <Type Comment="Error information" Name="_LMCPROFERRORDEF"/>
    LineNo : DINT;  //! <Type Comment="Number of the source code line where the error was reported" Name="_LMCPROFERRORDEF.LineNo"/>
    ErrorNo : _LMCPROFERRORTYPES;  //! <Type Comment="Error number" Name="_LMCPROFERRORDEF.ErrorNo"/>
    SubErrorNo : DINT;  //! <Type Comment="Additional error information" Name="_LMCPROFERRORDEF.SubErrorNo"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCPROFERRWARNCONFIG : BDINT  //! <Type Comment="User defined error message configuration" Name="_LMCPROFERRWARNCONFIG"/>
  [
    1 bPosChangeWarning,  //! <Type Comment="FALSE: no warning is issued when a movement with zero path length is encountered &#13;&#10;TRUE : a warning is issued when a movement with zero path length is encountered" Name="_LMCPROFERRWARNCONFIG.bPosChangeWarning"/>
    2 bResolutionError,  //! <Type Comment="FALSE: a warning is issued when a parameter value * resolution does not fit into a 32 bit signed integer.&#13;&#10;TRUE : an error is issued when a parameter value * resolution does not fit into a 32 bit signed integer." Name="_LMCPROFERRWARNCONFIG.bResolutionError"/>
    3 bPosLimitError,  //! <Type Comment="FALSE: a warning is issued when the endpoint of a movement is ouside of the software end position&#13;&#10;TRUE : an error is issued when the endpoint of a movement is ouside of the software end position" Name="_LMCPROFERRWARNCONFIG.bPosLimitError"/>
    4 bCircleError,  //! <Type Comment="FALSE: a warning is issued when the number of circle axes is not equal two.&#13;&#10;TRUE : an error is issued when the number of circle axes is not equal two." Name="_LMCPROFERRWARNCONFIG.bCircleError"/>
    5 bCmdLimitError,  //! <Type Comment="FALSE: a warning is issued when the path speed or path acceleration is less than one due to a limit in an auxiliary axis&#13;&#10;TRUE : an error is issued when the path speed or path acceleration is less than one due to a limit in an auxiliary axis" Name="_LMCPROFERRWARNCONFIG.bCmdLimitError"/>
    6 bKoFacError,  //! <Type Comment="FALSE: a warning is issued when the coupling factor does not fit into a 32 bit signed integer.&#13;&#10;TRUE : an error is issued when the coupling factor does not fit into a 32 bit signed integer." Name="_LMCPROFERRWARNCONFIG.bKoFacError"/>
    7 bSafetyZonesError,  //! <Type Comment="FALSE: a warning is issued when the endpoint of a movement is inside of a safety zone&#13;&#10;TRUE : an error is issued when the endpoint of a movement is inside of a safety zone" Name="_LMCPROFERRWARNCONFIG.bSafetyZonesError"/>
  ];
  _LMCPROFILESTATES : BDINT  //! <Type Comment="Profile States" Name="_LMCPROFILESTATES"/>
  [
    1 bProfileLocked,  //! <Type Comment="TRUE  .. All required axes are coupled to the profile.&#13;&#10;FALSE .. Axes are not coupled." Name="_LMCPROFILESTATES.bProfileLocked"/>
    2 bProfileStoped,  //! <Type Comment="TRUE ... command StopMove() is active and axes are not moving.&#13;&#10;FALSE .. command StopMove() is not active or at least the profile has not stopped now." Name="_LMCPROFILESTATES.bProfileStoped"/>
    3 bProfileBraking,  //! <Type Comment="TRUE ... The profile is reducing its speed.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bProfileBraking"/>
    4 bNoPreRtWork,  //! <Type Comment="TRUE ... LMCPreRtWorkTrigger is not connected&#13;&#10;FALSE .. LMCPreRtWorkTrigger is connected&#13;&#10;" Name="_LMCPROFILESTATES.bNoPreRtWork"/>
    5 bNoPostRtWork,  //! <Type Comment="TRUE ... LMCPostRtWorkTrigger is not connected&#13;&#10;FALSE .. LMCPostRtWorkTrigger is connected" Name="_LMCPROFILESTATES.bNoPostRtWork"/>
    6 bBraketoExactStop,  //! <Type Comment="TRUE ... The profile is reducing its speed due to stoping at an exact stop point.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bBraketoExactStop"/>
    7 bDynSWLimit,  //! <Type Comment="TRUE ... maximumum or minimum dynamic software limit has been reached&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bDynSWLimit"/>
    8 bBraketoDynSWLimit,  //! <Type Comment="TRUE ... The profile is reducing its speed due to a dynamic software limit&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bBraketoDynSWLimit"/>
    9 bDynSWLimitViolation,  //! <Type Comment="TRUE ... The dynamic software limit is violated or we probably cannot stop before violating it.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bDynSWLimitViolation"/>
  ];
  _LMCPROFINPOSTYPES :  //! <Type Comment="Mode" Name="_LMCPROFINPOSTYPES"/>
  (
    _LMCPROF_ProfileInPosition,  //! <Type Comment="Check whether the movement toward an end point has been ended and whether the speed is 0, i.e. read the Profile-In-Position Flag." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileInPosition"/>
    _LMCPROF_ProfileFinished,  //! <Type Comment="Check whether all motion sequences have been completed and that no new move commands are in the internal buffer." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileFinished"/>
    _LMCPROF_ProfileAxisInPos,  //! <Type Comment="Checks whether a movement toward an end point has been ended and whether the path speed is 0 and also whether the actual positions of the coupled axes are within their specified position windows." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileAxisInPos"/>
    _LMCPROF_ProfileAxisFinished,  //! <Type Comment="Check whether all motion sequences have been completed and that no new move commands are in the internal buffer and whether the path speed is 0 and also whether the actual positions of the coupled axes are within their specified position windows.&#13;&#10;" Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileAxisFinished"/>
    _LMCPROF_ProfileInWindow,  //! <Type Comment="Check whether the movement toward an end point is within the defined window." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileInWindow"/>
    _LMCPROF_ProfileInWindowFinished,  //! <Type Comment="Check whether the movement toward an end point is within the defined window and that no new move commands are in the internal buffer." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileInWindowFinished"/>
    _LMCPROF_ProfileAndAxisInWindow,  //! <Type Comment="Check whether the movement toward an end point is within the defined window and also&#13;&#10;check whether the actual positions of the coupled axes are within their specified position windows." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileAndAxisInWindow"/>
    _LMCPROF_ProfileAndAxisInWindowFinished,  //! <Type Comment="Check whether the movement toward an end point is within the defined window and that no new move commands are in the internal buffer and also check whether the actual positions of the coupled axes are within their specified position windows." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileAndAxisInWindowFinished"/>
    _LMCPROF_ProfileStandstill  //! <Type Comment="Check whether the path speed is zero and the coupled axes are not moving." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileStandstill"/>
  )$UDINT;
  _LMCPROFMOVEPROFILE :  //! <Type Comment="Type of profile" Name="_LMCPROFMOVEPROFILE"/>
  (
    RAMP_PROFILE,  //! <Type Comment="The movement is generated using ramp profiles, i.e. the path acceleration is rectangular and the path speed is a trapezoid.&#13;&#10;When braking to a lower path speed is needed, the lower speed is attained before the end of the path segment.&#13;&#10;The jerk is unlimited." Name="_LMCPROFMOVEPROFILE.RAMP_PROFILE"/>
    JERK_PROFILE  //! <Type Comment="Movements with jerk limitation are generated, i.e. the path jerk is rectangular and the path acceleration is a trapezoid." Name="_LMCPROFMOVEPROFILE.JERK_PROFILE"/>
  )$UDINT;
  _LMCPROFPARAMETER :  //! <Type Comment="_LMCProfile parameters" Name="_LMCPROFPARAMETER"/>
  (
    _LMCPROF_MaxOverride,  //! <Type Comment="Max. override value. Default value = 1000" Name="_LMCPROFPARAMETER._LMCPROF_MaxOverride"/>
    _LMCPROF_MinOverride,  //! <Type Comment="Min. override value. Default value = 0" Name="_LMCPROFPARAMETER._LMCPROF_MinOverride"/>
    _LMCPROF_SafetyZones,  //! <Type Comment="FALSE: Default value. The safety zones are not monitored.&#13;&#10;TRUE : the safety zone are monitored." Name="_LMCPROFPARAMETER._LMCPROF_SafetyZones"/>
    _LMCPROF_Max_Entries,  //! <Type Comment="Set the max. number of entries in the probile buffer.&#13;&#10;Can only be set before the last Init cycle." Name="_LMCPROFPARAMETER._LMCPROF_Max_Entries"/>
    _LMCPROF_NoOverrideChange,  //! <Type Comment="FALSE: Default value. When calling the LockProfile() method, the override is set to the 100 percent value automatically.&#13;&#10;TRUE : When calling the LockProfile() method, the override is not changed and therefore remains at the last value set." Name="_LMCPROFPARAMETER._LMCPROF_NoOverrideChange"/>
    _LMCPROF_ChkArcLength:=9,  //! <Type Comment="FALSE: Default value. Whether the arc length is the same as the chord length, is not tested.&#13;&#10;TRUE : If the arc length is the same as the chord length + 1, a linear movement is executed instead of a circular movement." Name="_LMCPROFPARAMETER._LMCPROF_ChkArcLength"/>
    _LMCPROF_NoChkAuxAxis:=10,  //! <Type Comment="FALSE: Default value. Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes and the limit values of the auxiliary axes.&#13;&#10;TRUE : Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes only." Name="_LMCPROFPARAMETER._LMCPROF_NoChkAuxAxis"/>
    _LMCPROF_OverrideType:=11,  //! <Type Comment="0: Default value. The override calculation is always based on the actual path speed of the path segment. &#13;&#10;1: The override calculation is based on the specified path speed of the path segment only. Limits of the path speed by circle limits, maximum speeds, etc. are not included in the override calculation.&#13;&#10;2: The override calculation is based on the actual path speed. Limits of the path speed by circle limits, maximum speeds, etc. are not included in the override calculation.&#13;&#10;" Name="_LMCPROFPARAMETER._LMCPROF_OverrideType"/>
    _LMCPROF_RoundConnectMode:=13,  //! <Type Comment="FALSE: Default value. The single axis movement at the segment transfer with tolerance sphere is always trapezoidal.&#13;&#10;TRUE : The single axis movement at the segment transfer with tolerance sphere is executed with a &quot;softer&quot; movement.&#13;&#10;       As the duration of the movement remains unchanged compared to the trapezoidal movement, temporarily the acceleration is higher than defined but the jerk is minimized." Name="_LMCPROFPARAMETER._LMCPROF_RoundConnectMode"/>
    _LMCPROF_aMinOverride:=14,  //! <Type Comment="The lower limit for the acceleration in [application units/s²]. The lower limit must be greater than null.&#13;&#10;" Name="_LMCPROFPARAMETER._LMCPROF_aMinOverride"/>
    _LMCPROF_ActVel:=15,  //! <Type Comment="Returns the current path speed." Name="_LMCPROFPARAMETER._LMCPROF_ActVel"/>
    _LMCPROF_ActAcc:=16,  //! <Type Comment="Returns the current path acceleration." Name="_LMCPROFPARAMETER._LMCPROF_ActAcc"/>
    _LMCPROF_MoveType:=17,  //! <Type Comment="Set the motion type:&#13;&#10;_RAMP_CURVE -&gt; the motion is defined by a ramp limiting velocity and acceleraation / deceleration&#13;&#10;_JERK_LIMIT -&gt; the motion is defined by a smooth function limiting velocity, acceleraation / deceleration and jerk" Name="_LMCPROFPARAMETER._LMCPROF_MoveType"/>
    _LMCPROF_LockState:=21,  //! <Type Comment="FALSE: Default value. Not all axis are locked.&#13;&#10;TRUE : All axis are locked.&#13;&#10;(just read)" Name="_LMCPROFPARAMETER._LMCPROF_LockState"/>
    _LMCPROF_Window,  //! <Type Comment="Set the window for ProfileInPosition() [application units]" Name="_LMCPROFPARAMETER._LMCPROF_Window"/>
    _LMCPROF_vSTART_F_IPO,  //! <Type Comment="Set the start speed of the feed rate interpolation [Appl.Units/s]." Name="_LMCPROFPARAMETER._LMCPROF_vSTART_F_IPO"/>
    _LMCPROF_CheckAxisGroup,  //! <Type Comment="to deactivate the LockGroup check" Name="_LMCPROFPARAMETER._LMCPROF_CheckAxisGroup"/>
    _LMCPROF_NormOverride,  //! <Type Comment="Norm. override value. Default value = 1000" Name="_LMCPROFPARAMETER._LMCPROF_NormOverride"/>
    _LMCPROF_AxisCount,  //! <Type Comment="defines how many axis are active (must be called when _Firstscan = 0)&#13;&#10;(default 6)" Name="_LMCPROFPARAMETER._LMCPROF_AxisCount"/>
    _LMCPROF_AddOffset,  //! <Type Comment="defines if the offset of the axis is already added to the server for the Position/Destination" Name="_LMCPROFPARAMETER._LMCPROF_AddOffset"/>
    _LMCPROF_Read_Decel,  //! <Type Comment="reads the actual maximal allowed deceleration value of the profile" Name="_LMCPROFPARAMETER._LMCPROF_Read_Decel"/>
    _LMCPROF_Read_Timebase,  //! <Type Comment="Read the RtWork() cycle time [ms]" Name="_LMCPROFPARAMETER._LMCPROF_Read_Timebase"/>
    _LMCPROF_LookAhead,  //! <Type Comment="defines how the profile should work with connected move-commands&#13;&#10;0: Default value. the move-command must calculate a&#13;&#10;   vNext, so it takes a bit more time, but the speed&#13;&#10;   of connected move-commands can be reached exactly at&#13;&#10;   the end of the further command&#13;&#10;1: there is no calculation of vNext, so the velocity&#13;&#10;   reaches the new target-velocity, when it would go&#13;&#10;   down to standstill" Name="_LMCPROFPARAMETER._LMCPROF_LookAhead"/>
    _LMCPROF_HalfCircleTolerance:=31,  //! <Type Comment="Tolerance-Window [application units] of the Endpoint of a Half-Circle. " Name="_LMCPROFPARAMETER._LMCPROF_HalfCircleTolerance"/>
    _LMCPROF_TransRad_ppTh,
    _LMCPROF_Set_LogMode,  //! <Type Comment="Change command logger settings.&#13;&#10;0: logging off&#13;&#10;1: log move commands and write commands&#13;&#10;2: log move commands and write commands plus request commands&#13;&#10;3: log move commands and write commands plus the method parameters (default)&#13;&#10;4: log move commands and write commands plus request commands plus the method parameters" Name="_LMCPROFPARAMETER._LMCPROF_Set_LogMode"/>
    _LMCPROF_ChkEndPosForSwLimit,  //! <Type Comment="1: (default) The Move... methods check its end positions for a violation of the software limits of the axes. In case the command will be rejected with _LMCPROF_SWE_ERROR.&#13;&#10;0: The Move.. methods do not check for software limit violations." Name="_LMCPROFPARAMETER._LMCPROF_ChkEndPosForSwLimit"/>
    _LMCPROF_ProfileInPos,  //! <Type Comment="TRUE ... actual position is used for exact stop&#13;&#10;FALSE ... set position is used for exact stop" Name="_LMCPROFPARAMETER._LMCPROF_ProfileInPos"/>
    _LMCPROF_ProfileInPos_Timeout,  //! <Type Comment="time, how long the _LMCProfile is waiting after an exact stop for the InPosition of the axes. If this time is exceeded a _LMCPROF_INPOSITION_TIMEOUT_ERROR occurs. [milliseconds]&#13;&#10;if Value &lt;= 0: timeout is disabled." Name="_LMCPROFPARAMETER._LMCPROF_ProfileInPos_Timeout"/>
    _LMCPROF_UnlimitCurveSplines,  //! <Type Comment="Disregarde monitoring of maximal jerk and maximal acceleration inside of the transition-sphere for a quint-spline" Name="_LMCPROFPARAMETER._LMCPROF_UnlimitCurveSplines"/>
    _LMCPROF_IncreaseLimit_SpeedWindow,  //! <Type Comment="for faster override control: maximal speed difference, which may be adjusted with higher limits [application units / sec]&#13;&#10;&#13;&#10;The parameters _LMCPROF_IncreaseLimit_FastAccel and/or _LMCPROF_IncreaseLimit_FastJerk have to be set too." Name="_LMCPROFPARAMETER._LMCPROF_IncreaseLimit_SpeedWindow"/>
    _LMCPROF_IncreaseLimit_FastAccel,  //! <Type Comment="for faster override control: maximal allowed acceleration/deceleration for small velocity changes [application units / sec^2]&#13;&#10;&#13;&#10;The parameter _LMCPROF_IncreaseLimit_SpeedWindow has to be set too." Name="_LMCPROFPARAMETER._LMCPROF_IncreaseLimit_FastAccel"/>
    _LMCPROF_IncreaseLimit_FastJerk  //! <Type Comment="for faster override control: maximal allowed acceleration/deceleration for small velocity changes [application units / sec^3 * 1000]&#13;&#10;&#13;&#10;The parameter _LMCPROF_IncreaseLimit_SpeedWindow has to be set too." Name="_LMCPROFPARAMETER._LMCPROF_IncreaseLimit_FastJerk"/>
  )$UDINT;
  _LMCPROFPARAMETERAXIS :  //! <Type Comment="Type of axis parameter" Name="_LMCPROFPARAMETERAXIS"/>
  (
    _LMCPROF_AX_VEL_LIMIT,  //! <Type Comment="Axis velocity limit [Application units/s]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_VEL_LIMIT"/>
    _LMCPROF_AX_ACCEL_LIMIT,  //! <Type Comment="Axis acceleration limit [Application units/s²]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_ACCEL_LIMIT"/>
    _LMCPROF_AX_TJERK,  //! <Type Comment="Jerk time [ms]. The time in which the acceleration increases linearly from null to the maximum." Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_TJERK"/>
    _LMCPROF_AX_UNLOCK_DECEL,  //! <Type Comment="Axis deceleration to be used by UnlockProfile() [Application units/s²]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_UNLOCK_DECEL"/>
    _LMCPROF_AX_MAX_VEL_JUMP,  //! <Type Comment="Axis velocity jump limit [Application units/s]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_MAX_VEL_JUMP"/>
    _LMCPROF_AX_INPOS_WINDOW,  //! <Type Comment="Position window [Application units]. Used by ProfileInPosition()." Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_INPOS_WINDOW"/>
    _LMCPROF_AX_LOCK_GRP,  //! <Type Comment="Number of the group to which the axis belongs" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_LOCK_GRP"/>
    _LMCPROF_AX_MAX_ACCEL_JUMP,  //! <Type Comment="Axis acceleration jump limit [Application units/s²]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_MAX_ACCEL_JUMP"/>
    _LMCPROF_AX_DEC,  //! <Type Comment="Axis deceleration calculated from path [Application units/s²]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_DEC"/>
    _LMCPROF_AX_NOT_CHECK_SWLIMIT,  //! <Type Comment="handling of _LMCAxis.AxisError.SwMinError/SwMaxError&#13;&#10;0 ... the bits will be checked&#13;&#10;1 ... the bits will be ignored" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_NOT_CHECK_SWLIMIT"/>
    _LMCPROF_AX_SW_MIN_LIMIT,  //! <Type Comment="Reads the minimal software limit. [Application units]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_SW_MIN_LIMIT"/>
    _LMCPROF_AX_SW_MAX_LIMIT,  //! <Type Comment="Reads the maximal software limit. [application units]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_SW_MAX_LIMIT"/>
    _LMCPROF_AX_INPOS_WIN_ADDITIVELYCOUPLED,  //! <Type Comment="Position window used, if the axis is additively coupled with CoupleAdditivePosDiff or belt coupling is active [Application units]. Used by ProfileInPosition()." Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_INPOS_WIN_ADDITIVELYCOUPLED"/>
    _LMCPROF_AX_VEL_LIMIT_RAPID_TRAVERSE,
    _LMCPROF_AX_ACCEL_LIMIT_RAPID_TRAVERSE,
    _LMCPROF_AX_TJERK_RAPID_TRAVERSE
  )$UDINT;
  _LMCPROFPARAMETERGROUPS :  //! <Type Comment="Type of axes group parameter" Name="_LMCPROFPARAMETERGROUPS"/>
  (
    _LMCPROF_GRP_VEL_LIMIT,  //! <Type Comment="Path speed limit of an axes group [Application units/s]" Name="_LMCPROFPARAMETERGROUPS._LMCPROF_GRP_VEL_LIMIT"/>
    _LMCPROF_GRP_ACCEL_LIMIT,  //! <Type Comment="Path acceleration limit of an axes group [Application units/s²]" Name="_LMCPROFPARAMETERGROUPS._LMCPROF_GRP_ACCEL_LIMIT"/>
    _LMCPROF_GRP_TJERK  //! <Type Comment="During this time [ms], the acceleration&#13;&#10;increases from null to its maximum value" Name="_LMCPROFPARAMETERGROUPS._LMCPROF_GRP_TJERK"/>
  )$UDINT;
  _LMCPROFSETTINGS : BDINT  //! <Type Comment="Currently active profile settings." Name="_LMCPROFSETTINGS"/>
  [
    1 bInitDone,  //! <Type Comment="Set if the Last Init run was done&#13;&#10;This var is used for lock some SetPar Functions" Name="_LMCPROFSETTINGS.bInitDone"/>
    2 bFirstInitDone,  //! <Type Comment="Set if the first init run was done&#13;&#10;This var is used for lock some SetPar Functions" Name="_LMCPROFSETTINGS.bFirstInitDone"/>
    3 bOverrideTyp,  //! <Type Comment="0: Default value. The type of Override is always based on the actual speed of the path segment. &#13;&#10;1: The type of Override is based on the specified speed of the path segment only. Limits of the path speed by circle limits, maximum speeds, etc. are not included in the override calculation." Name="_LMCPROFSETTINGS.bOverrideTyp"/>
    4 bNoOverrideChange,  //! <Type Comment="0: Default value. When calling the LockProfile() method, the override is set to the maximum value automatically.&#13;&#10;1: When calling the LockProfile() method, the override is not changed and therefore remains at the last values set." Name="_LMCPROFSETTINGS.bNoOverrideChange"/>
    5 bNoChkSWLimit,
    6 LogReadMethods,  //! <Type Comment="Additionally log request method calls" Name="_LMCPROFSETTINGS.LogReadMethods"/>
    7 LogMethodCallPlusParam,  //! <Type Comment="Additionally log the method parameters" Name="_LMCPROFSETTINGS.LogMethodCallPlusParam"/>
    8 bFatalError,  //! <Type Comment="Is set if the Init was not OK ... We have no Buffer memory" Name="_LMCPROFSETTINGS.bFatalError"/>
    9 bExtTrigger,  //! <Type Comment="0: RtWork() is called by the the operating system (default)&#13;&#10;1: RtWork() has to be called by the application" Name="_LMCPROFSETTINGS.bExtTrigger"/>
    10 bAxCount,  //! <Type Comment="This Bit indicates, if the user already set the number of used axis with the methode SetProfileParameter - _LMCPROF_AxisCount." Name="_LMCPROFSETTINGS.bAxCount"/>
    11 bChkArcLength,  //! <Type Comment="0: Default value. Whether the arc length is the same as the chord length, is not tested.&#13;&#10;1: If the arc length is the same as the chord length + 1, a linear movement is executed instead of a circular movement." Name="_LMCPROFSETTINGS.bChkArcLength"/>
    12 bNoChkAuxAxis,  //! <Type Comment="0: Default value. Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes and the limit values of the auxiliary axes.&#13;&#10;1: Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes only." Name="_LMCPROFSETTINGS.bNoChkAuxAxis"/>
    13 bWaitActPosition,  //! <Type Comment="0: the exact stop functions with the set position (default)&#13;&#10;1: the exact stop functions with the actual position" Name="_LMCPROFSETTINGS.bWaitActPosition"/>
    14 bNoLookAhead,  //! <Type Comment="0: Default value. the move-command must calculate a&#13;&#10;   vNext, so it takes a bit more time, but the speed&#13;&#10;   of connected move-commands can be reached exactly at&#13;&#10;   the end of the further command&#13;&#10;1: there is no calculation of vNext, so the velocity&#13;&#10;   reaches the new target-velocity, when it would go&#13;&#10;   down to standstill" Name="_LMCPROFSETTINGS.bNoLookAhead"/>
    15 bOverrideInitialized,
    16 bRoundConnectMode,  //! <Type Comment="FALSE: Default value. The single axis movement at the segment transfer with tolerance sphere is always trapezoidal.&#13;&#10;TRUE : The single axis movement at the segment transfer with tolerance sphere is executed with a &quot;softer&quot; movement.&#13;&#10;       As the duration of the movement remains unchanged compared to the trapezoidal movement, temporarily the acceleration is higher than defined but the jerk is minimized." Name="_LMCPROFSETTINGS.bRoundConnectMode"/>
    17 bCheckAxisGroup,  //! <Type Comment="False: the AxisGroup where checked&#13;&#10;True : no check of the AxisGroup" Name="_LMCPROFSETTINGS.bCheckAxisGroup"/>
    18 bNoOffsetposition,  //! <Type Comment="false = the Offsetposition is added to the server Position/Destination&#13;&#10;true = the Offsetposition is not added to the server Position/Destination" Name="_LMCPROFSETTINGS.bNoOffsetposition"/>
    19 NoLimitCurveAxisSpline,  //! <Type Comment="NoLimitCurveAxisSpline = 1:  &#13;&#10;No monitoring inside of the transition-sphere moving along a quint-spline:&#13;&#10;limitation of jerk to maximal jerk and also &#13;&#10;limitation of acceleration to maximal acceleration is disregarded for the swerve-axis" Name="_LMCPROFSETTINGS.NoLimitCurveAxisSpline"/>
    20 NoLimitAllCurveAxisSplines,  //! <Type Comment="NoLimitAllCurveAxisSplines = 1:  &#13;&#10;No monitoring inside of the transition-sphere moving along a quint-spline:&#13;&#10;limitation of jerk to maximal jerk and also &#13;&#10;limitation of acceleration to maximal acceleration is disregarded for all axis" Name="_LMCPROFSETTINGS.NoLimitAllCurveAxisSplines"/>
    21 bOverrideAxLimit,  //! <Type Comment="just has an effect with bOverrideTyp = 1&#13;&#10;FALSE --&gt; Default: The type of Override is based on the specified speed of the path segment only.&#13;&#10;TRUE  --&gt; The type of Override is based on the actual speed of the path segment." Name="_LMCPROFSETTINGS.bOverrideAxLimit"/>
    22 Axis_1_IsConnected,
    23 Axis_2_IsConnected,
    24 Axis_3_IsConnected,
    25 Axis_4_IsConnected,
    26 Axis_5_IsConnected,
    27 Axis_6_IsConnected,
    28 Axis_7_IsConnected,
    29 Axis_8_IsConnected,
    30 Axis_9_IsConnected,
    31 bLMCCNCIprMode,
  ];
  _POSFLAGS : BDINT
  [
    1 SetSFF,  //! <Type Comment="0 .. the set velocity isn&apos;t written to the drive axis object (SFF)&#13;&#10;1 .. default :the set velocity is written to the drive axis object (SFF)" Name="_POSFLAGS.SetSFF"/>
    2 XWCalcInt,  //! <Type Comment="0 .. default : the contouring error is read directly from the drive axis object&#13;&#10;1 .. the contouring error is calculated in the DrivePosControl object&#13;&#10;" Name="_POSFLAGS.XWCalcInt"/>
  ];
  _SDDISTATE : BDINT
  [
    1 SDD_OnePhase,
    2 SDD_MainError,
    3 SDD_MotorAxisOverCurrent,
    4 SDD_DCOver,
    5 SDD_DCUnder,
    6 SDD_PhaseFailure,
    7 SDD_BrakeError,
    8 SDD_BrakeSwitchError,
    9 SDD_Free3,
    10 SDD_MotorOverTemp,
    11 SDD_AmbientOverTemp,
    12 SDD_HeatSinkOverTemp,
    13 SDD_FeedBackError,
    14 SDD_CommutationError,
    15 SDD_Overspeed,
    16 SDD_PEMax,
    17 SDD_PCmdError,
    18 SDD_HostComError,
    19 SDD_DriveError_E2,
    20 SDD_DriveErrorE1,
    21 SDD_EnableLockedError,
    22 SDD_DriverVoltageError,
    23 SDD_MaxRegenPower,
    24 SDD_Brake24VError,
    25 SDD_BrakeEnableError,
    26 SDD_I2TError,
    27 SDD_MotorTempWarn,
    28 SDD_MotorObjectError,
    29 SDD_MultiPosError,
    30 SDD_MaxSumPowerLimit,
    31 SDD_SpeedControlerSaturation,
    32 SDD_FanError,
  ];
  CncFlags : BDINT
  [
    1 HwError,  //! <Type Comment="Hardware error Flag" Name="CncFlags.HwError"/>
    2 SwMin,  //! <Type Comment="Software endswitch minimum active" Name="CncFlags.SwMin"/>
    3 SwMax,  //! <Type Comment="Software endswitch maximum active" Name="CncFlags.SwMax"/>
    4 v_error,  //! <Type Comment="velocity setting error" Name="CncFlags.v_error"/>
    5 a_error,  //! <Type Comment="Acceleration / deceleration setting error" Name="CncFlags.a_error"/>
    6 ContrOff,  //! <Type Comment="position controller off" Name="CncFlags.ContrOff"/>
    7 NoRef,  //! <Type Comment="no position reference" Name="CncFlags.NoRef"/>
    8 DragLim,  //! <Type Comment="contouring error" Name="CncFlags.DragLim"/>
    9 ComandErr,  //! <Type Comment="Command is not exepted" Name="CncFlags.ComandErr"/>
    10 ActPosError,  //! <Type Comment="invalid position of the hardware" Name="CncFlags.ActPosError"/>
    11 IsNotControlling,  //! <Type Comment="wake and shake is active" Name="CncFlags.IsNotControlling"/>
    12 Follow,
    13 OverFlowError,
    16 GlobErr,  //! <Type Comment="Any other errors is active" Name="CncFlags.GlobErr"/>
  ];
#pragma pack(push, 1)
  CNCInternalStruct : STRUCT
    ptrExt : ^DINT;
    ptrInt : ^DINT;
    ptrBinOffset : ^DINT;
    NowOverflow : DINT;
    OverflowDelta : DINT;
    SetPos : DINT;
  END_STRUCT;
#pragma pack(pop)
  CntrFlgs : BDINT
  [
    1 InPosition,  //! <Type Comment="Axis is in position" Name="CntrFlgs.InPosition"/>
    2 FiltRdy,  //! <Type Comment="Axis is in position and jerk filter is ready" Name="CntrFlgs.FiltRdy"/>
    3 PosLimActive,  //! <Type Comment="Position limit is active, set position is over the SW end position" Name="CntrFlgs.PosLimActive"/>
    4 Decell,  //! <Type Comment="Deceleration is active" Name="CntrFlgs.Decell"/>
    5 bDynSWLimit,  //! <Type Comment="Set if axis has reached one of its dynamic SW endpositions" Name="CntrFlgs.bDynSWLimit"/>
    7 SetFlg,  //! <Type Comment="Set by calling the SetPositon, CNCRefRun and NCRefRun functions Reset after activating the controller." Name="CntrFlgs.SetFlg"/>
    10 EnLesFlg,  //! <Type Comment="Endless positioning is active" Name="CntrFlgs.EnLesFlg"/>
    11 DirFlg,  //! <Type Comment="Commanded axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.DirFlg"/>
    12 ActDirFlg,  //! <Type Comment="Actual axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.ActDirFlg"/>
    13 EmergStop,  //! <Type Comment="Emergency stop is active" Name="CntrFlgs.EmergStop"/>
    14 AutoRun,  //! <Type Comment="Controller output autotuning is running" Name="CntrFlgs.AutoRun"/>
    15 AutoStop,  //! <Type Comment="Controller output autotuning is ready" Name="CntrFlgs.AutoStop"/>
    16 Test,  //! <Type Comment="Is only queried when ControllerOn is set to 0." Name="CntrFlgs.Test"/>
    17 NoActpos,  //! <Type Comment="The Client &quot;iActPosition&quot; is not connected" Name="CntrFlgs.NoActpos"/>
    18 Overflow,  //! <Type Comment="The axis has an internal position overflow." Name="CntrFlgs.Overflow"/>
    19 NoControl,  //! <Type Comment="The axis is not connected to a controller and the CNC therefore operates as a profile generator only." Name="CntrFlgs.NoControl"/>
    20 ModuloFlg,  //! <Type Comment="The axis is defined as a modulo axis." Name="CntrFlgs.ModuloFlg"/>
    21 NoActPosMeth,  //! <Type Comment="The &quot;iActPosition&quot; client is not connected to a server (axis operates without posi-tion feedback)." Name="CntrFlgs.NoActPosMeth"/>
    22 NoRefMeth,  //! <Type Comment="The &quot;iRefChannal&quot; is not connected" Name="CntrFlgs.NoRefMeth"/>
    23 NoControlMeth,  //! <Type Comment="The &quot;oSignalchannal&quot; client is not connected" Name="CntrFlgs.NoControlMeth"/>
    24 NoSpecial,  //! <Type Comment="The &quot;oPrecyclictrigger&quot; client is not connected" Name="CntrFlgs.NoSpecial"/>
    25 NCMotion,  //! <Type Comment="The CNC class is operated in NC mode" Name="CntrFlgs.NCMotion"/>
    26 NoActPosChk,
  ];
#pragma pack(push, 1)
  CntrStr : STRUCT
    MinutsOfRunning : DINT;
    NbrOfPackets : DINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  DataMachineStr : STRUCT
    LineSpeed : DINT;
    TraysPerMinute : DINT;
    TrayLenght : DINT;
  END_STRUCT;
#pragma pack(pop)
  DataRecipeStr : STRUCT
    Name : ARRAY [0..39] OF CHAR;
    Machine : DataMachineStr;
  END_STRUCT;
#pragma pack(push, 1)
  DateTime : STRUCT
    Year : UDINT;
    Month : UDINT;
    Day : UDINT;
    Hour : UDINT;
    Minute : UDINT;
    Str : ARRAY [0..20] OF CHAR;
  END_STRUCT;
#pragma pack(pop)
  DatumEnTijd : STRUCT
    Year : UINT;
    Month : USINT;
    Day : USINT;
    Hour : USINT;
    Minute : USINT;
    Second : USINT;
  END_STRUCT;
  DM_CPU_Types :
  (
    CPUNotIdentified,
    IPC_Text_CPU,
    IPC_800_CPU,
    IPC_1024_CPU,
    PCD_CPU,
    DSE_CPU,
    DCP_CPU,
    DCC080_CPU,
    DCP645_CPU,
    AK500_CPU,
    TSTROM_CPU,
    NoCPU_11,
    NoCPU_12,
    NoCPU_13,
    NoCPU_14,
    NoCPU_15,
    ELAN_CPU,
    ELAN800_CPU,
    WINPC_CPU,
    TERMINAL_CPU,
    DTC281_CPU,
    ELAN_TEXT_CPU,
    ELAN_800_CPU,
    ETT321_CPU,
    HERZ_CPU,
    ETT261_CPU,
    ETT431_CPU,
    WIN_PC98_CPU,
    WINPC_NT_CPU,
    WINIPC_98_CPU,
    WINIPC_NT_CPU,
    IPC_320_CPU,
    C_IPC_CPU,
    NoCPU_33,
    RK500_CPU,
    CCL721_CPU,
    CCL911_CPU,
    BDF2000_CPU,
    StandardPC_CPU,
    CCL081CET_CPU,
    CCL081_CPU,
    CCL722_CPU,
    DCL642_CPU,
    Teachbox_CPU,
    DTC081_CPU,
    DTC081_IP_CPU,
    ETV_CPU,
    HZS511_CPU,
    AUW11X_CPU,
    BDF2000_USB_CPU,
    DTC101_CPU,
    HZS515_CPU,
    CCP511_CPU,
    ETVEDGE_CPU,
    ARM_IMX6_CPU:=65537
  )$UDINT;
  EventModeTxt :
  (
    Event01Log,
    Event1xLog,
    TraceLog
  )$UDINT;
  eVisionStatus :
  (
    eNoVisionInp:=0,
    eVisionOK:=1,
    eVisionNotOK:=2
  )$UDINT;
  eWeightStatus :
  (
    eNoWeightInp:=0,
    eWeightOK:=1,
    eWeightNotOK:=2
  )$UDINT;
  OptiesEnum :
  (
    NietActief,
    Actief
  )$UDINT;
  RunningStateEnum :
  (
    eStopStatus,
    eStartUpStatus,
    eRunStatus,
    eErrorStatus,
    eNoodstop,
    ePauseStatus,
    eCleaningStatus,
    eDriveOffStatus,
    eLockStatus,
    eNoodstopStatus
  )$UDINT;
#pragma pack(push, 1)
  GlobalDataStr : STRUCT
    gGeneralData : STRUCT
      iDrivesOK : DINT;
      iDrivesEnabled : DINT;
      iNoodstopOk : DINT;
      iExternrelease : DINT;
      iJogCleaning : DINT;
      CleaningJogDistance : DINT;
      PauzeOverride : DINT;
      NoError : DINT;
      CleaningMode : DINT;
      CleaningSpeed : DINT;
      CleaningAccDec : DINT;
      CleaningJogOption : OptiesEnum;
      CleaningJog : DINT;
      oResetSignal : DINT;
      oMachineOK : DINT;
      LineSpeed : DINT;
      cleaningOverrule : DINT;
    END_STRUCT;
    gRunStatus : STRUCT
      gRunStatusGlob : RunningStateEnum;
      gRunStatusInfeedBelt : RunningStateEnum;
      gRunStatusRobot : RunningStateEnum;
      gRunStatusStrokeConveyor : RunningStateEnum;
    END_STRUCT;
    StructItem1 : DINT;
    StructItem2 : DINT;
    StructItem3 : DINT;
    StructItem4 : DINT;
    StructItem5 : DINT;
    StructItem6 : DINT;
    StructItem7 : DINT;
    StructItem8 : DINT;
    StructItem9 : DINT;
    StructItem10 : DINT;
    StructItem11 : DINT;
    StructItem12 : DINT;
  END_STRUCT;
#pragma pack(pop)
  HourCntrStr : ARRAY [0..24] OF CntrStr;
#pragma pack(push, 1)
  ImpClkStr : STRUCT
    _Imp10mSec : DINT;
    _Imp100mSec : DINT;
    _Imp500mSec : DINT;
    _Imp1Sec : DINT;
    _Imp10Sec : DINT;
    _Clk10mSec : DINT;
    _Clk100mSec : DINT;
    _Clk500mSec : DINT;
    _Clk1Sec : DINT;
    _Clk10Sec : DINT;
  END_STRUCT;
#pragma pack(pop)
  InvoluteOrbitalENUM :
  (
    Involute,
    Orbital
  )$UDINT;
  IO_FLAG : BINT  //! <Type Comment="Status Flag für IO Daten" Name="IO_FLAG"/>
  [
    1 WrongHW,  //! <Type Comment="Falsche Hardware verbunden" Name="IO_FLAG.WrongHW"/>
    2 NoHW,  //! <Type Comment="Keine Hardware verbunden" Name="IO_FLAG.NoHW"/>
    3 NoCalibration,  //! <Type Comment="Keine Kalibrierungsdaten im Modul-EEPROM" Name="IO_FLAG.NoCalibration"/>
    4 ParaChkWrong,  //! <Type Comment="Die Parameter-Checksumme ist falsch" Name="IO_FLAG.ParaChkWrong"/>
    5 PhysicHiLimit,  //! <Type Comment="IO ist am oberen physikalischen Limit" Name="IO_FLAG.PhysicHiLimit"/>
    6 PhysicLoLimit,  //! <Type Comment="IO ist am unteren physikalischen Limit" Name="IO_FLAG.PhysicLoLimit"/>
    7 Invert,  //! <Type Comment="Daten sind invertiert" Name="IO_FLAG.Invert"/>
    14 OnDummyMode,  //! <Type Comment="1 = Objekt ist im Dummymodus (nicht refreshed)" Name="IO_FLAG.OnDummyMode"/>
    15 NotConnected,  //! <Type Comment="1 = Objekt ist nicht verbunden" Name="IO_FLAG.NotConnected"/>
    16 PhysicAccessOff,  //! <Type Comment="1 = kein physikalischer Zugriff erlaubt" Name="IO_FLAG.PhysicAccessOff"/>
  ];
#pragma pack(push, 1)
  IO_State : STRUCT
    uiIO_Flags : IO_FLAG;
    uiChNo : UINT;
  END_STRUCT;
#pragma pack(pop)
  IpAdrStr : ARRAY [0..15] OF CHAR;
#pragma pack(push, 1)
  LogRecStr : STRUCT
    Stepper : DINT;
    tElapsTime : UDINT;
    tOpsTime : UDINT;
  END_STRUCT;
#pragma pack(pop)
  LseDateStr : BDINT  //! <Type Public="true" Name="LseDateStr"/>
  [
    1 WDayB0,
    2 WDayB1,
    3 WDayB2,
    4 WDayB3,
    5 DayB0,
    6 DayB1,
    7 DayB2,
    8 DayB3,
    9 DayB4,
    10 DayB5,
    11 DayB6,
    12 DayB7,
    13 MonB0,
    14 MonB1,
    15 MonB2,
    16 MonB3,
    17 YearB0,
    18 YearB1,
    19 YearB2,
    20 YearB3,
    21 YearB4,
    22 YearB5,
    23 YearB6,
    24 YearB7,
    25 YearB8,
    26 YearB9,
    27 YearB10,
    28 YearB11,
    29 YearB12,
    30 YearB13,
    31 YearB14,
    32 YearB15,
  ];
  LseTimeStr : BDINT  //! <Type Public="true" Name="LseTimeStr"/>
  [
    9 SecB0,
    10 SecB1,
    11 SecB2,
    12 SecB3,
    13 SecB4,
    14 SecB5,
    15 SecB6,
    16 SecB7,
    17 MinB0,
    18 MinB1,
    19 MinB2,
    20 MinB3,
    21 MinB4,
    22 MinB5,
    23 MinB6,
    24 MinB7,
    25 HourB0,
    26 HourB1,
    27 HourB2,
    28 HourB3,
    29 HourB4,
    30 HourB5,
    31 HourB6,
    32 HourB7,
  ];
  MasterStruct : STRUCT  //! <Type Comment="Pointers to the master axis data" Name="MasterStruct"/>
    pos : ^DINT;  //! <Type Comment="Pointer to the master axis position [internal units]" Name="MasterStruct.pos"/>
    Speed : ^DINT;  //! <Type Comment="Pointer to the master axis speed [internal units / tick]" Name="MasterStruct.Speed"/>
    ModuloMaster : ^DINT;  //! <Type Comment="Pointer to ModuloInt of master axis [internal units]" Name="MasterStruct.ModuloMaster"/>
    PosLREAL : pVoid;  //! <Type Comment="pointer to a LREAL value cointainig the master position [internal units]&#13;&#10;(this pointer is set and used only by _LMCAxis objects with MoveType=_JERK_PROFILE)" Name="MasterStruct.PosLREAL"/>
    SpeedLREAL : pVoid;  //! <Type Comment="pointer to a LREAL value cointainig the master speed [internal units /tick]&#13;&#10;(this pointer is set and used only by _LMCAxis objects with MoveType=_JERK_PROFILE)" Name="MasterStruct.SpeedLREAL"/>
    pMasterThis : pVoid;  //! <Type Comment="pointer to the _LMCAxis master object" Name="MasterStruct.pMasterThis"/>
  END_STRUCT;
  ProfileCommandStatus :
  (
    PassiveProfile,  //! <Type Comment="Axis are unlocked in passive mode" Name="ProfileCommandStatus.PassiveProfile"/>
    IdleProfile,  //! <Type Comment="Axis are locked in idle mode - no motion sequences are available" Name="ProfileCommandStatus.IdleProfile"/>
    RunProfile,  //! <Type Comment="Axes are in motion to generate a profile" Name="ProfileCommandStatus.RunProfile"/>
    EndProfile,  //! <Type Comment="The generated profile is finished now" Name="ProfileCommandStatus.EndProfile"/>
    ErrorProfile,  //! <Type Comment="An error occured" Name="ProfileCommandStatus.ErrorProfile"/>
    IdleProfileRestart,  //! <Type Comment="waiting for end of restart" Name="ProfileCommandStatus.IdleProfileRestart"/>
    WaitProfileRestart,  //! <Type Comment="waiting for end of delay time after calling ContinueNCProg()" Name="ProfileCommandStatus.WaitProfileRestart"/>
    WaitProfileForAxInPos  //! <Type Comment="profile is waiting for the actual axes position to be in position at an exact stop" Name="ProfileCommandStatus.WaitProfileForAxInPos"/>
  )$UDINT;
  RecipeStr : STRUCT
    Name : ARRAY [0..39] OF CHAR;
  END_STRUCT;
#pragma pack(push, 1)
  RobotPosStr : STRUCT
    Xpos : DINT;
    Ypos : DINT;
    Zpos : DINT;
    Rpos : DINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  ScoopChanDataStr : STRUCT
    pScoopData : ^_KOORD;
    Color : _COLOR;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  ScoopGenDataStr : STRUCT
    TrigerFl : DINT;
    AxisXY : DINT;
    AxisDir : DINT;
    MaxOverScale : DINT;
    PixMaxLengthX : _KOORD;
    PixMaxLengthY : _KOORD;
    PixNulX : _KOORD;
    PixNulY : _KOORD;
    ScrollArraySize : UDINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  StepLogStr : STRUCT
    Nr : DINT;  //! <Type Comment="Array offset for the next step.&#13;&#10;So this is the oldest step number in the FIFO." Name="StepLogStr.Nr"/>
    Logger : ARRAY [0..cSCbMaxLogArray] OF LogRecStr;  //! <Type Comment="Step numbers in sequance." Name="StepLogStr.Logger"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  StepperDataStr : STRUCT
    First : DINT;  //! <Type Comment="First time in this step." Name="StepperDataStr.First"/>
    tTime : UDINT;  //! <Type Comment="Time this step is active in mSec." Name="StepperDataStr.tTime"/>
    StepLog : StepLogStr;  //! <Type Comment="Step numbers in sequance of excecution." Name="StepperDataStr.StepLog"/>
    StepperOld : DINT;  //! <Type Comment="Internal, Old stepper value." Name="StepperDataStr.StepperOld"/>
    tMark : UDINT;  //! <Type Comment="Internal, Ops.tAbsolute time when step was enterd for the first time." Name="StepperDataStr.tMark"/>
    OerInit : DINT;  //! <Type Comment="Internal, Detection this function is called for the first time." Name="StepperDataStr.OerInit"/>
    pActLog : ^LogRecStr;
  END_STRUCT;
#pragma pack(pop)
  StringDateTxt :
  (
    DateMode_YYYYMMDD,
    DateMode_YYMMDD,
    DateMode_DD_MM_YYYY,
    DateMode_DD_MM_YY,
    DateMode_D_M_jjjY,
    DateMode_D_M_jY
  )$UDINT;
  StringTimeTxt :
  (
    TimeMode_HHMMSS,
    TimeMode_HH_MM_SS,
    TimeMode_HH_MM_SS_PMAM,
    TimeMode_HMS,
    TimeMode_HMS_PMAM
  )$UDINT;
  t_e_OPMode :  //! <Type Comment="Reihenfolge der Enumeration darf nicht verändert werden!" Name="t_e_OPMode"/>
  (
    OPMode_Init,
    OPMode_Homing,
    OPMode_Stop,
    OPMode_Setup,
    OPMode_Manual,
    OPMode_SemiAuto,
    OPMode_Automatic,
    OPMode_Error,
    OPMode_ChangeMode
  )$UDINT;
#pragma pack(push, 1)
  WeightingStr : STRUCT
    Offset1Min : DINT;
    Offste2Min : DINT;
    TargetWeight : DINT;
    Offset1Plus : DINT;
    Offset2Plus : DINT;
    GainZone1 : DINT;
    GainZone2 : DINT;
    GainZone3 : DINT;
    GainZone4 : DINT;
    GainZone5 : DINT;
    GainZone6 : DINT;
    cwGain : DINT;
    GewRegelMin : DINT;
    SpareW02 : DINT;
    SpareW01 : DINT;
    ContrWeightingFB : DINT;
    MeasuredCwPacket : DINT;
    GewRegelMax : DINT;
    DoorlopendGem : DINT;
  END_STRUCT;
#pragma pack(pop)
END_TYPE
