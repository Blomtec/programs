//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
#pragma pack(push, 1)
typedef struct _11CameraStr 
  {
    DINT Optie;
  } _11CameraStr;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _00ProductStr 
  {
    _11CameraStr _11Camera;
  } _00ProductStr;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _Diag_ClsVersCRC 
  {
    CHAR ClsName [49+1-0];
    CHAR ClsRevision [9+1-0];
    UDINT ClsCRC;
  } _Diag_ClsVersCRC;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _Diag_IPInfo 
  {
    HDINT IPAdress;
    HDINT Subnet;
    HDINT Gateway;
  } _Diag_IPInfo;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _Diag_LoaderStruct 
  {
    USINT usLoRev;
    USINT usHiRev;
  } _Diag_LoaderStruct;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _Diag_ProjectInfo 
  {
    CHAR ProjectName [49+1-0];
    UDINT ProjectCRC;
    DINT ClassAmount;
    _Diag_ClsVersCRC ClsVersCRC [500+1-0];
  } _Diag_ProjectInfo;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _Diag_SystemInfo 
  {
    CHAR PLCType [19+1-0];
    CHAR OSVersion [19+1-0];
    _Diag_LoaderStruct LoaderVersion;
    CHAR SerialNumber [19+1-0];
    _Diag_IPInfo IPInfo;
  } _Diag_SystemInfo;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _DiagErrorCode 
  {
    DINT ErrorNr;
    DINT ErrorCode;
  } _DiagErrorCode;
#pragma pack(pop)

typedef CHAR _DiagString [Diagnostic_MAX_FileFolderString+1-0];

typedef UDINT _FSM_TCP_USER;   //! <Type Comment="stepping switch for TCP/IP connection" Name="_FSM_TCP_USER"/>
    #define _STATE_INIT_SERVER 0
    #define _STATE_IDLE 1
    #define _STATE_MAIN_SOCK 2
    #define _STATE_LISTEN 3
    #define _STATE_ACCEPT 4
    #define _STATE_CONNECT 5
    #define _STATE_RECV 6
    #define _STATE_SHUTDOWN 7
    #define _STATE_CLOSE_MAIN_SOCK 8
    #define _STATE_CLOSE_SOCK 9
    #define _STATE_ERROR 10
    #define _STATE_ERROR_ALLOCATING_MEMORY 11
    #define _STATE_ERROR_CREATING_MUTEX 12
    #define _STATE_SEND 13
    #define _STATE_READ_RINGBUFFER 14

typedef UDINT _LMC_DYN_SWLIMITS;   //! <Type Comment="Dynamic software end positions" Name="_LMC_DYN_SWLIMITS"/>
    #define _LMC_DynSWLimitMin 0
    #define _LMC_DynSWLimitMax 1

typedef struct   //! <Type Comment="Status flags" Name="_LMCAXIS_CMDERROR"/>
  {
    long PowerOff : 1;  //! <Type Comment="1 --&gt; Position controller is off" Name="_LMCAXIS_CMDERROR.PowerOff"/>
    long NoReference : 1;  //! <Type Comment="1 --&gt; The axis is not referenced" Name="_LMCAXIS_CMDERROR.NoReference"/>
    long HWError : 1;  //! <Type Comment="1 --&gt; Servo hardware error" Name="_LMCAXIS_CMDERROR.HWError"/>
    long ActPosError : 1;  //! <Type Comment="1 --&gt; Invalid position of the hardware" Name="_LMCAXIS_CMDERROR.ActPosError"/>
    long ContouringError : 1;  //! <Type Comment="1 --&gt; Tracking limit exceeded" Name="_LMCAXIS_CMDERROR.ContouringError"/>
    long CommandError : 1;  //! <Type Comment="1 --&gt; Command not allowed or &#13;&#10;within the CNC RTWork cycle more than one command has been set&#13;&#10;" Name="_LMCAXIS_CMDERROR.CommandError"/>
    long SWMinError : 1;  //! <Type Comment="1 --&gt; Software endswitch minimum active" Name="_LMCAXIS_CMDERROR.SWMinError"/>
    long SWMaxError : 1;  //! <Type Comment="1 --&gt; Software endswitch maximum active" Name="_LMCAXIS_CMDERROR.SWMaxError"/>
    long vError : 1;  //! <Type Comment="1 --&gt; Selected speed too high" Name="_LMCAXIS_CMDERROR.vError"/>
    long aError : 1;  //! <Type Comment="1 --&gt; Selected acceleration / deceleration too high" Name="_LMCAXIS_CMDERROR.aError"/>
    long HWMinError : 1;  //! <Type Comment="1 --&gt; Hardware endswitch minimum active" Name="_LMCAXIS_CMDERROR.HWMinError"/>
    long HWMaxError : 1;  //! <Type Comment="1 --&gt; Hardware endswitch maximum active" Name="_LMCAXIS_CMDERROR.HWMaxError"/>
    long DirError : 1;  //! <Type Comment="1 --&gt; The direction of motion is not allowed" Name="_LMCAXIS_CMDERROR.DirError"/>
    long EmergencyError : 1;  //! <Type Comment="when Client _LMCSafety.Emergency goes to 1&#13;&#10; 0 -&gt; StopMove&#13;&#10; 1 -&gt; PowerOff" Name="_LMCAXIS_CMDERROR.EmergencyError"/>
    long ResolutionError : 1;  //! <Type Comment="1 -&gt; An overflow by multiplication with the value of the server: Resolution occurred&#13;&#10;" Name="_LMCAXIS_CMDERROR.ResolutionError"/>
    long GlobalError : 1;  //! <Type Comment="1 --&gt; Global error" Name="_LMCAXIS_CMDERROR.GlobalError"/>
    long JError : 1;  //! <Type Comment="1--&gt; Selected jerk is too high or low." Name="_LMCAXIS_CMDERROR.JError"/>
  }_LMCAXIS_CMDERROR;

typedef struct   //! <Type Comment="Control-Bits" Name="_LMCAXIS_CONTROLBITS"/>
  {
    long SetPowerOn : 1;  //! <Type Comment="Set if the clients &quot;LMCController&quot; and &quot;ActPosition&quot; are not connected or &#13;&#10;the axis is active" Name="_LMCAXIS_CONTROLBITS.SetPowerOn"/>
    long SetFollowMode : 1;  //! <Type Comment="Set if the axis is in operationmode: &quot;FOLLOW_LMCAXIS&quot;" Name="_LMCAXIS_CONTROLBITS.SetFollowMode"/>
    long ReadActPosFromController : 1;
    long CallReadPDO : 1;
  }_LMCAXIS_CONTROLBITS;

typedef UDINT _LMCAXIS_COUPLE_GEAR_MODE;   //! <Type Comment="Parameter of the methods &quot;CoupleUserPos&quot; and &quot;CoupleProfilePos&quot;" Name="_LMCAXIS_COUPLE_GEAR_MODE"/>
    #define LMCAXIS_COUPLE_PROFILE_GEAR 0
    #define LMCAXIS_COUPLE_PROFILE_NO_GEAR 1

typedef UDINT _LMCAXIS_COUPLEERROR;   //! <Type Comment="Errorlist returned by the function: &quot;CoupleGearPolynom&quot;" Name="_LMCAXIS_COUPLEERROR"/>
    #define LMCAXIS_NO_ERROR_OCCURED 0
    #define LMCAXIS_MASTERPOINTER_INVALID 1
    #define LMCAXIS_SELFCOUPLING 2
    #define LMCAXIS_SOFTWARE_ERROR 3
    #define LMCAXIS_VEL_MASTER_NOT_POSITIVE 4
    #define LMCAXIS_PATH_MASTER_NOT_POSITIVE 5
    #define LMCAXIS_PATH_SLAVE_NOT_POSITIVE 6
    #define LMCAXIS_VEL_MASTER_DEFINITION_ERROR 7
    #define LMCAXIS_JERK_MAX_DEFINITION_ERROR 8
    #define LMCAXIS_ACC_ANNIHILATION_FAILED_3_5 9
    #define LMCAXIS_PATH_SX_NEGATIVE_3_5 10
    #define LMCAXIS_VEL_COUPLE_NEGATIVE_3_5 11
    #define LMCAXIS_VEL_COUPLE_EXCEED_3_5 12
    #define LMCAXIS_PATH_SZ_NEGATIVE_3_5 13
    #define LMCAXIS_TIME_SZ_NEGATIVE_3_5 14
    #define LMCAXIS_VEL_MIN_NEGATIVE_3_5 15
    #define LMCAXIS_VEL_MAX_EXCEED_3_5 16
    #define LMCAXIS_ACC_MAX_EXCEED_3_5 17
    #define LMCAXIS_JERK_MAX_SLAVE_EXCEED_3_5 18
    #define LMCAXIS_ACC_ANNIHILATION_FAILED_4_1_4 19
    #define LMCAXIS_VEL_ACCNIHIL_NEGATIVE 20
    #define LMCAXIS_VEL_ACCNIHIL_EXCEED 21
    #define LMCAXIS_ACC_MAX_DEFINITION_ERROR 22
    #define LMCAXIS_VEL_COUPLE_NEGATIVE_4_1_4 23
    #define LMCAXIS_VEL_COUPLE_EXCEED_4_1_4 24
    #define LMCAXIS_PATH_SX_NEGATIVE_4_1_4 25
    #define LMCAXIS_PATH_SY_NEGATIVE_4_1_4 26
    #define LMCAXIS_PATH_SZ_NEGATIVE_4_1_4 27
    #define LMCAXIS_VEL_MIN_NEGATIVE_4_1_4 28
    #define LMCAXIS_VEL_MAX_EXCEED_4_1_4 29
    #define LMCAXIS_ACC_MAX_1_EXCEED_4_1_4 30
    #define LMCAXIS_ACC_MAX_2_EXCEED_4_1_4 31
    #define LMCAXIS_JERK_MAX_1_EXCEED_4_1_4 32
    #define LMCAXIS_JERK_MAX_2_EXCEED_4_1_4 33
    #define LMCAXIS_TRAPEZOIDSPLINE_DISABLED 34
    #define LMCAXIS_VEL_COUPLE_NO_SOLUTION 35
    #define LMCAXIS_VEL_COUPLE_NEGATIVE_2_1_2 36
    #define LMCAXIS_VEL_COUPLE_EXCEED_2_1_2 37
    #define LMCAXIS_TIME_SX_NEGATIVE_2_1_2 38
    #define LMCAXIS_TIME_SY_NEGATIVE_2_1_2 39
    #define LMCAXIS_TIME_SZ_NEGATIVE_2_1_2 40
    #define LMCAXIS_PATH_SX_NEGATIVE_2_1_2 41
    #define LMCAXIS_PATH_SY_NEGATIVE_2_1_2 42
    #define LMCAXIS_PATH_SZ_NEGATIVE_2_1_2 43
    #define LMCAXIS_DURATION_ERROR 44

#pragma pack(push, 1)
typedef struct CurveTable   //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="CurveTable"/>
  {
    DINT MasterPos;  //! <Type Comment="Master axis position [Application units]" Name="CurveTable.MasterPos"/>
    DINT SlavePos;  //! <Type Comment="Slave axis position [Application units]" Name="CurveTable.SlavePos"/>
  } CurveTable;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _LMCAXIS_CURVE   //! <Type Comment="Motion type curve data" Name="_LMCAXIS_CURVE"/>
  {
    DINT modulo;  //! <Type Comment="Lead axis modulo value" Name="_LMCAXIS_CURVE.modulo"/>
    DINT points;  //! <Type Comment="number of curve points" Name="_LMCAXIS_CURVE.points"/>
    DINT mul;  //! <Type Comment="Numerator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="_LMCAXIS_CURVE.mul"/>
    DINT div;  //! <Type Comment="Denominator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="_LMCAXIS_CURVE.div"/>
    DINT offset;  //! <Type Comment="Position offset in the slave axis of the cam definition [Internal units].&#13;&#10;Added to the slave value of the cam table." Name="_LMCAXIS_CURVE.offset"/>
    CurveTable table [1023+1-0];  //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="_LMCAXIS_CURVE.table"/>
  } _LMCAXIS_CURVE;
#pragma pack(pop)

typedef struct   //! <Type Comment="Slave axis operating mode" Name="_LMCAXIS_CURVETABMODE"/>
  {
    long bStopAxisNoMod : 1;  //! <Type Comment="Parameter of the function &quot;CoupleCurveTab&quot;&#13;&#10;0 --&gt; Normal operation. Slave follows the master over the curve definition, including a master axis position overflow.&#13;&#10;1 --&gt; Stop slave axis immediately when master axis position overflows." Name="_LMCAXIS_CURVETABMODE.bStopAxisNoMod"/>
  }_LMCAXIS_CURVETABMODE;

typedef struct   //! <Type Comment="Error-Bits" Name="_LMCAXIS_ERROR"/>
  {
    long HwError : 1;  //! <Type Comment="Set if a general Hardware-Error occured" Name="_LMCAXIS_ERROR.HwError"/>
    long SwMinError : 1;  //! <Type Comment="Set if the Software-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.SwMinError"/>
    long SwMaxError : 1;  //! <Type Comment="Set if the Software-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.SwMaxError"/>
    long HwMinError : 1;  //! <Type Comment="Set if the Hardware-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.HwMinError"/>
    long HwMaxError : 1;  //! <Type Comment="Set if the Hardware-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.HwMaxError"/>
    long ReferenceError : 1;  //! <Type Comment="Set if an error occured during the reference-run" Name="_LMCAXIS_ERROR.ReferenceError"/>
    long ContouringError : 1;  //! <Type Comment="Set if a tracking-error occured" Name="_LMCAXIS_ERROR.ContouringError"/>
    long ActPosError : 1;  //! <Type Comment="Set if the Hardware-Position is invalid" Name="_LMCAXIS_ERROR.ActPosError"/>
    long AbsOffsetError : 1;  //! <Type Comment="Set if an Offset-Error occured" Name="_LMCAXIS_ERROR.AbsOffsetError"/>
    long OverFlowError : 1;  //! <Type Comment="Set if a Position-Overflow occured" Name="_LMCAXIS_ERROR.OverFlowError"/>
    long EmergencyError : 1;  //! <Type Comment="Set if the _LMCSafety.Emergency is active" Name="_LMCAXIS_ERROR.EmergencyError"/>
    long ResolutionError : 1;  //! <Type Comment="Set if the Resolution causes an overflow error&#13;&#10;" Name="_LMCAXIS_ERROR.ResolutionError"/>
    long PowerOnError : 1;  //! <Type Comment="Set, if the enable signal of the hardware was cleared during operation, or if after calling PowerOn() the axis has not been enabled before a timeout of 30 seconds occured." Name="_LMCAXIS_ERROR.PowerOnError"/>
    long dummy0 : 2;
    long GlobErr : 1;  //! <Type Comment="Set if a global error is active" Name="_LMCAXIS_ERROR.GlobErr"/>
  }_LMCAXIS_ERROR;

typedef struct   //! <Type Comment="Error-Config Bits" Name="_LMCAXIS_ERROR_CONFIG"/>
  {
    long vError : 1;  //! <Type Comment="when programmed speed is too high:&#13;&#10; 0 ... the speed will be limited (default)&#13;&#10; 1 ... set the vError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.vError"/>
    long aError : 1;  //! <Type Comment="when programmed acceleration is too high:&#13;&#10; 0 ... the acceleration will be limited (default)&#13;&#10; 1 ... set the aError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.aError"/>
    long SWMinError : 1;  //! <Type Comment="when position would be smaller than SWMinPos:&#13;&#10; 0 ... position will be limited (default)&#13;&#10; 1 ... set the SWMinError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.SWMinError"/>
    long SWMaxError : 1;  //! <Type Comment="when position would be bigger than SWMaxPos:&#13;&#10; 0 ... position will be limited (default)&#13;&#10; 1 ... set the SWMaxError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.SWMaxError"/>
    long CommandError : 1;  //! <Type Comment="when the deltaposition is bigger than the&#13;&#10;MaxModulo during coupling:&#13;&#10; 0 ... no check (default)&#13;&#10; 1 ... set the CommandError flag in the command result" Name="_LMCAXIS_ERROR_CONFIG.CommandError"/>
    long EmergencyError : 1;  //! <Type Comment="when Emergency goes to 1:&#13;&#10; 0 ... StopMove() (default)&#13;&#10; 1 ... PowerOff()&#13;&#10;" Name="_LMCAXIS_ERROR_CONFIG.EmergencyError"/>
    long CoupleMonitoring : 1;  //! <Type Comment="0: Monitoring the coupled axes is disabled. This axis does not recognise an error of its master axis and also does not report its own errors to the master. Furthermore, there is no reaction on errors of its slaves.&#13;&#10;1: Monitoring of all coupled master and slave axes for errors is enabled. The error handling can be configured with SetParameter with modes LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR, LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR, and LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG." Name="_LMCAXIS_ERROR_CONFIG.CoupleMonitoring"/>
    long JError : 1;  //! <Type Comment="when programmed jerk is too high or low:&#13;&#10; 0 ... the acceleration will be limited (default)&#13;&#10; 1 ... set the JError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.JError"/>
  }_LMCAXIS_ERROR_CONFIG;

typedef UDINT _LMCAXIS_FOLLOW_MODE;   //! <Type Comment="Parameter of the function &quot;SetFollowMode&quot;" Name="_LMCAXIS_FOLLOW_MODE"/>
    #define LMCAXIS_DEACTIVATE_FOLLOW_MODE 0
    #define LMCAXIS_ACTIVATE_FOLLOW_MODE 1

typedef UDINT _LMCAXIS_MOVE_RELATIVE_MODE;   //! <Type Comment="Parameter of the function &quot;MoveRelative&quot;" Name="_LMCAXIS_MOVE_RELATIVE_MODE"/>
    #define LMCAXIS_MOVE_RELATIVE_TO_DESTINATION 0
    #define LMCAXIS_MOVE_RELATIVE_TO_POSITION 1

typedef UDINT _LMCAXIS_MOVEDIRECTION;   //! <Type Comment="Set direction of movement for the axis&#13;&#10;" Name="_LMCAXIS_MOVEDIRECTION"/>
    #define LMCAXIS_MOVE_ANY_WAY 0
    #define LMCAXIS_MOVE_NEG_DIR 1
    #define LMCAXIS_MOVE_SHORTEST_WAY 2
    #define LMCAXIS_MOVE_POS_DIR 3

typedef UDINT _LMCAXIS_MOVEPROFILE;   //! <Type Comment="Velocity-profile" Name="_LMCAXIS_MOVEPROFILE"/>
    #define _RAMP_PROFILE 0
    #define _SCURVE_PROFILE 1
    #define _JERK_PROFILE 10

typedef UDINT _LMCAXIS_MOVINGTIMEERROR;   //! <Type Comment="Errorlist returned by the function: &quot;CalcMovingTime&quot;" Name="_LMCAXIS_MOVINGTIMEERROR"/>
    #define LMCAXIS_NO_ERROR_ 0
    #define LMCAXIS_MAXVEL_NOT_POSITIV 1
    #define LMCAXIS_STARTVEL_TO_BIG 2
    #define LMCAXIS_ENDVEL_TO_BIG 3
    #define LMCAXIS_PATH_IS_ZERO 4
    #define LMCAXIS_STARTVEL_NEGATIVE 5
    #define LMCAXIS_OVERFLOW_ERROR 6
    #define LMCAXIS_TIME_ERROR_1 7
    #define LMCAXIS_TIME_ERROR_2 8
    #define LMCAXIS_TIME_ERROR_3 9
    #define LMCAXIS_POINTER_ERROR 10
    #define LMCAXIS_ENDVEL_NEGATIVE 11
    #define LMCAXIS_ACCEL_NOT_POSITIV 12
    #define LMCAXIS_DECEL_NOT_POSITIV 13
    #define LMCAXIS_PATH_ERROR 14
    #define LMCAXIS_GLOBAL_ERROR 15

typedef UDINT _LMCAXIS_OPMODE;   //! <Type Comment="Current state of the axis" Name="_LMCAXIS_OPMODE"/>
    #define PASSIVE_LMCAXIS 0
    #define WAITIDLE_LMCAXIS 1
    #define IDLE_LMCAXIS 2
    #define MOVE_LMCAXIS 3
    #define FOLLOW_LMCAXIS 4
    #define STOPED_LMCAXIS 5
    #define LOCKED_LMCAXIS 6
    #define REFRUN_LMCAXIS 7
    #define TUNEPOS_LMCAXIS 8
    #define TUNENEG_LMCAXIS 9
    #define ERROR_LMCAXIS 10

typedef UDINT _LMCAXIS_POSMODE;   //! <Type Comment="Positionmode" Name="_LMCAXIS_POSMODE"/>
    #define _Positioning 0
    #define _NCPositioning 1
    #define _StdSyncPositioning 2
    #define _UserSyncPositioning 3
    #define _CAMSyncPositioning 4
    #define _ProfileSyncPositioning 5
    #define _SyncVelocity 6
    #define _StartPolynomPositioning 7
    #define _SyncPolynomPositioning 8

typedef UDINT _LMCAXIS_POWER_OFF_MODE;   //! <Type Comment="Parameter of the function: &quot;PowerOff&quot;" Name="_LMCAXIS_POWER_OFF_MODE"/>
    #define LMCAXIS_IMMEDIATE_STOPP 0
    #define LMCAXIS_SMOOTH_STOPP 1

typedef DINT _LMCAXIS_QUERY_POSITION_MODE;   //! <Type Comment="Parameter of the function &quot;InPosition&quot;" Name="_LMCAXIS_QUERY_POSITION_MODE"/>
    #define LMCAXIS_NO_JERK_FILTER -2
    #define LMCAXIS_NO_POSITIONWINDOW -1
    #define LMCAXIS_POSITIONWINDOW_APP_UNITS 0
    #define LMCAXIS_POSITIONWINDOW_INT_UNITS 1
    #define LMCAXIS_SETPOS_IN_WINDOW_APP_UNITS 2
    #define LMCAXIS_SETPOS_IN_WINDOW_INT_UNITS 3
    #define LMCAXIS_ACTPOS_IN_WINDOW_APP_UNITS 4
    #define LMCAXIS_ACTPOS_IN_WINDOW_INT_UNITS 5

typedef UDINT _LMCAXIS_READPARAMETER;   //! <Type Comment="Parameter-ID" Name="_LMCAXIS_READPARAMETER"/>
    #define LMCAXIS_PAR_RD_V_MAX 0
    #define LMCAXIS_PAR_RD_A_MAX 1
    #define LMCAXIS_PAR_RD_EXTUNITS 2
    #define LMCAXIS_PAR_RD_RESFACT 3
    #define LMCAXIS_PAR_RD_INTUNITS 4
    #define LMCAXIS_PAR_RD_SEMAPHOR 5
    #define LMCAXIS_PAR_RD_REFPOS 6
    #define LMCAXIS_PAR_RD_MODULO 7
    #define LMCAXIS_PAR_RD_MASTERLOCK_12 8
    #define LMCAXIS_PAR_RD_MASTERLOCK_11 9
    #define LMCAXIS_PAR_RD_MAX_MODULO 10
    #define LMCAXIS_PAR_RD_BINOFFSET 11
    #define LMCAXIS_PAR_RD_CONTROLLERTYPE 12
    #define LMCAXIS_PAR_RD_POSMODE 13
    #define LMCAXIS_PAR_RD_TIMEBASE 14
    #define LMCAXIS_PAR_RD_CONTROLLERPAR 15
    #define LMCAXIS_PAR_RD_J_MAX 16
    #define LMCAXIS_PAR_RD_MOVETYPE 17
    #define LMCAXIS_PAR_RD_T_JERK 18
    #define LMCAXIS_PAR_RD_HARDLOCK 19
    #define LMCAXIS_PAR_RD_SHAPE_SPLINE 20
    #define LMCAXIS_PAR_RD_MOVEDIRECTION 21
    #define LMCAXIS_PAR_RD_COUPLE_ERROR 22
    #define LMCAXIS_PAR_RD_SWLIMWINDOW 23
    #define LMCAXIS_PAR_RD_MASTER_DELAY 24
    #define LMCAXIS_PAR_RD_DEC 25
    #define LMCAXIS_PAR_RD_DYN_SW_LIMIT 26
    #define LMCAXIS_PAR_RD_MAX_OVERRIDE 27
    #define LMCAXIS_PAR_RD_NORM_OVERRIDE 28
    #define LMCAXIS_PAR_RD_OVERRIDE 29
    #define LMCAXIS_PAR_RD_DELAYEDMASTERLOCK 30
    #define LMCAXIS_PAR_RD_OVERFLOW_POS 31
    #define LMCAXIS_PAR_RD_MIN_POSITION 32
    #define LMCAXIS_PAR_RD_MAX_POSITION 33
    #define LMCAXIS_PAR_RD_ZPULSE_DIST 34
    #define LMCAXIS_PAR_RD_ALLOWED_ACC_JUMP 35
    #define LMCAXIS_PAR_RD_SIMULATE_MODE 36

typedef UDINT _LMCAXIS_READPOS;   //! <Type Comment="Type of the position that should be read" Name="_LMCAXIS_READPOS"/>
    #define LMCAXIS_SETPOS_APPUNIT 0
    #define LMCAXIS_SETPOS_INTUNIT 1
    #define LMCAXIS_SETPOS_INTUNIT_WO_MOD 2
    #define LMCAXIS_DESTPOS_INTUNIT 3
    #define LMCAXIS_SETPOS_INTUNIT_JERK_WO_MOD 4
    #define LMCAXIS_SETPOS_INTUNIT_JERK 5
    #define LMCAXIS_SETPOS_APPUNIT_JERK 6
    #define LMCAXIS_SETPOS_APPUNIT_SPEC1 7
    #define LMCAXIS_ACTPOS_APPUNIT 8
    #define LMCAXIS_ACTPOS_INTUNIT 9
    #define LMCAXIS_ACTPOS_INTUNIT_WO_MOD 10
    #define LMCAXIS_BRAKEPOS_APPUNIT 11
    #define LMCAXIS_MASTERPOS_INTUNIT 12
    #define LMCAXIS_XW_TO_DESTPOS_INTUNIT 13

typedef UDINT _LMCAXIS_READSWENDPOS;   //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;" Name="_LMCAXIS_READSWENDPOS"/>
    #define LMCAXIS_RD_SWMAX_APPUNIT 0
    #define LMCAXIS_RD_SWMIN_APPUNIT 1
    #define LMCAXIS_RD_SWMAX_INTUNIT 2
    #define LMCAXIS_RD_SWMIN_INTUNIT 3

typedef UDINT _LMCAXIS_READVELOCITY;   //! <Type Comment="Type of the axis velocity that should be read" Name="_LMCAXIS_READVELOCITY"/>
    #define LMCAXIS_SETVEL_APPUNIT_SEC 0
    #define LMCAXIS_SETVEL_INTUNIT_SEC 1
    #define LMCAXIS_SETVEL_APPUNIT_NCMODE 2
    #define LMCAXIS_SETVEL_INTUNIT_NCMODE 3
    #define LMCAXIS_ACTVEL_APPUNIT_MS 4
    #define LMCAXIS_ACTVEL_INTUNIT_MS 5
    #define LMCAXIS_SETVEL_INTUNIT_TICK_JERK 6
    #define LMCAXIS_SETVEL_APPUNIT_SEC_JERK 7
    #define LMCAXIS_SETVEL_INTUNIT_TICK 8
    #define LMCAXIS_ACTVEL_APPUNIT_SEC 9
    #define LMCAXIS_ACTVEL_INTUNIT_SEC 10
    #define LMCAXIS_ACTVEL_APPUNIT_SEC_FILT 11
    #define LMCAXIS_ACTVEL_INTUNIT_SEC_FILT 12
    #define LMCAXIS_CMDVEL_APPUNIT 13

#pragma pack(push, 1)
typedef struct _LMCAXIS_REFDATA   //! <Type Comment="Parameters of the functions: &#13;&#10;&quot;MoveReference&quot;, &quot;ReferenceAxis&quot; and &quot;_LMCAxisRef::control&quot;" Name="_LMCAXIS_REFDATA"/>
  {
    iprStates Status;
    DINT Velocity;  //! <Type Comment="Velocity during the refernce run" Name="_LMCAXIS_REFDATA.Velocity"/>
    DINT Acc;  //! <Type Comment="Acceleration during the refernce run" Name="_LMCAXIS_REFDATA.Acc"/>
    DINT vSetRef1;  //! <Type Comment="Velocity during the movement to the refernce-switch" Name="_LMCAXIS_REFDATA.vSetRef1"/>
    DINT vSetRef2;  //! <Type Comment="Velocity during the movement away from the refernce-switch" Name="_LMCAXIS_REFDATA.vSetRef2"/>
    DINT PosWindow;  //! <Type Comment="Position window for the Z-Impuls" Name="_LMCAXIS_REFDATA.PosWindow"/>
    DINT LatchPosRef;  //! <Type Comment="External position used in mode &quot;RefLatchPos&quot;" Name="_LMCAXIS_REFDATA.LatchPosRef"/>
  } _LMCAXIS_REFDATA;
#pragma pack(pop)

typedef struct   //! <Type Comment="Reference mode" Name="_LMCAXIS_REFMODE"/>
  {
    long NoZImpulse : 1;  //! <Type Comment="0 --&gt; Referencing with referencing impulse&#13;&#10;1 --&gt; Referencing without referencing impulse" Name="_LMCAXIS_REFMODE.NoZImpulse"/>
    long NoEndSwitch : 1;  //! <Type Comment="0 --&gt; Referencing with endswitches&#13;&#10;1 --&gt; Referencing without endswitches" Name="_LMCAXIS_REFMODE.NoEndSwitch"/>
    long RefDirection : 1;  //! <Type Comment="1 --&gt; Referencing on positive direction&#13;&#10;0 --&gt; Referencing on negative direction" Name="_LMCAXIS_REFMODE.RefDirection"/>
    long NoTurnOnSwitch : 1;  //! <Type Comment="0 --&gt; Reverse direction at the reference switch&#13;&#10;1 --&gt; Do not reverse direction at the reference switch" Name="_LMCAXIS_REFMODE.NoTurnOnSwitch"/>
    long ESEqualRef : 1;  //! <Type Comment="1 --&gt; Hardware end switch is used as reference switch" Name="_LMCAXIS_REFMODE.ESEqualRef"/>
    long NoSet : 1;  //! <Type Comment="0 --&gt; The transmitted position is the reference position&#13;&#10;1 --&gt; The actual position is the reference position" Name="_LMCAXIS_REFMODE.NoSet"/>
    long RefLatchPos : 1;  //! <Type Comment="1 --&gt; Read reference position from client cLatchPos. If value changes, do a MoveAbsolute(cLatchPos) and set cLatchPos as current position." Name="_LMCAXIS_REFMODE.RefLatchPos"/>
    long RefFirstEdge : 1;  //! <Type Comment="1 --&gt; Go back to first edge of ref.switch or end switch" Name="_LMCAXIS_REFMODE.RefFirstEdge"/>
  }_LMCAXIS_REFMODE;

typedef UDINT _LMCAXIS_SETPARAMETER;   //! <Type Comment="Parameter-ID" Name="_LMCAXIS_SETPARAMETER"/>
    #define LMCAXIS_PAR_SET_COUPLING_MODE 0
    #define LMCAXIS_PAR_SET_DESTINATION 1
    #define LMCAXIS_PAR_SET_OVERRIDE 2
    #define LMCAXIS_PAR_SET_LOGMODE 3
    #define LMCAXIS_PAR_RESET_REF_STATE 4
    #define LMCAXIS_PAR_SET_CHANGE_SW_LIMITS 5
    #define LMCAXIS_PAR_SET_JERK_LIMITATION 6
    #define LMCAXIS_PAR_SET_SHIFT_BREAKPOS 7
    #define LMCAXIS_PAR_SET_OVERFLOW_POS 8
    #define LMCAXIS_PAR_SET_MIN_POSITION 9
    #define LMCAXIS_PAR_SET_MAX_POSITION 10
    #define LMCAXIS_PAR_SET_HARDLOCK 11
    #define LMCAXIS_PAR_SET_SWLIM_STANDSTILL 12
    #define LMCAXIS_PAR_SET_SWLIM_DIR_CHANGE 13
    #define LMCAXIS_PAR_SET_SWLIM_MOVING 14
    #define LMCAXIS_PAR_SET_INIT_JERK_FILTER 15
    #define LMCAXIS_PAR_SET_BINOFFSET 16
    #define LMCAXIS_PAR_SET_VJUMP 17
    #define LMCAXIS_PAR_SET_SW_LIMIT_FLAGS 18
    #define LMCAXIS_PAR_SET_SW_LIM_WINDOW 19
    #define LMCAXIS_PAR_SET_MOVE_DIR 20
    #define LMCAXIS_PAR_SET_TIMEBASE 21
    #define LMCAXIS_PAR_SET_CONTROLLERPAR 22
    #define LMCAXIS_PAR_SET_ACTVELFILTER 23
    #define LMCAXIS_PAR_SET_SHAPE_SPLINE 24
    #define LMCAXIS_PAR_SET_NO_OVERFLOWERROR 25
    #define LMCAXIS_PAR_SET_MASTERPOS_OLD 26
    #define LMCAXIS_PAR_SET_MASTER_DELAY 27
    #define LMCAXIS_PAR_SET_MAXMODULO 28
    #define LMCAXIS_PAR_SET_MAX_OVERRIDE 29
    #define LMCAXIS_PAR_SET_NORM_OVERRIDE 30
    #define LMCAXIS_PAR_SET_MASTERLOCK_DELAYCYCLES 31
    #define LMCAXIS_PAR_SET_ALLOWED_ACC_JUMP 32
    #define LMCAXIS_PAR_SET_SIMULATE_MODE 33
    #define LMCAXIS_PAR_SET_DEACTIVATE_CALC_BRAKEPOS 34
    #define LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR 35
    #define LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR 36
    #define LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG 37

typedef UDINT _LMCAXIS_SETPOSITION;   //! <Type Comment="Type of the position that should be set" Name="_LMCAXIS_SETPOSITION"/>
    #define LMCAXIS_SET_ACTPOS_APPUNIT 0
    #define LMCAXIS_SET_SETPOS_APPUNIT 1
    #define LMCAXIS_SET_ACTPOS_INTUNIT 2
    #define LMCAXIS_SET_SETPOS_INTUNIT 3
    #define LMCAXIS_SET_SETPOS_INTUNIT_SPEC 4
    #define LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD 5
    #define LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD 6
    #define LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD_SW 7
    #define LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD_SW 8
    #define LMCAXIS_SET_ACTPOS_APPUNIT_DEST 9
    #define LMCAXIS_SET_SETPOS_APPUNIT_DEST 10
    #define LMCAXIS_SET_ACTPOS_APPUNIT_WO_MOD_SW 11
    #define LMCAXIS_SET_SETPOS_APPUNIT_WO_MOD_SW 12

typedef UDINT _LMCAXIS_SETSERVER;   //! <Type Comment="Server-ID" Name="_LMCAXIS_SETSERVER"/>
    #define LMCAXIS_SET_EXUNIT 0
    #define LMCAXIS_SET_INTUNIT 1
    #define LMCAXIS_SET_VMAX 2
    #define LMCAXIS_SET_AMAX 3
    #define LMCAXIS_SET_SWMINPOS 4
    #define LMCAXIS_SET_SWMAXPOS 5
    #define LMCAXIS_SET_MODULO 6
    #define LMCAXIS_SET_T_JERK 7
    #define LMCAXIS_SET_MOVETYPE 8
    #define LMCAXIS_SET_AEMERGENCY 9
    #define LMCAXIS_SET_JMAX 10

typedef UDINT _LMCAXIS_SETSWENDPOS;   //! <Type Comment="LMCAXIS_SET_SWMAX_APPUNIT&#13;&#10;New SW max end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_APPUNIT&#13;&#10;New SW min end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMAX_INTUNIT&#13;&#10;New SW max end position = Position&#13;&#10;This value is set based on Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_INTUNIT&#13;&#10;New SW min end position = Position &#13;&#10;This value is set based on Modulo.(new SW min end position = Position)&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD&#13;&#10;New SW Max end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD&#13;&#10;New SW min end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETSWENDPOS"/>
    #define LMCAXIS_SET_SWMAX_APPUNIT 0
    #define LMCAXIS_SET_SWMIN_APPUNIT 1
    #define LMCAXIS_SET_SWMAX_INTUNIT 2
    #define LMCAXIS_SET_SWMIN_INTUNIT 3
    #define LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD 4
    #define LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD 5

typedef struct   //! <Type Comment="Status-Bits of the axis" Name="_LMCAXIS_STATUS"/>
  {
    long PowerOn : 1;  //! <Type Comment="Set if axis is activated" Name="_LMCAXIS_STATUS.PowerOn"/>
    long IsReferenced : 1;  //! <Type Comment="Set if axis is referenced" Name="_LMCAXIS_STATUS.IsReferenced"/>
    long InPosition : 1;  //! <Type Comment="Set if axis is in correct position" Name="_LMCAXIS_STATUS.InPosition"/>
    long FiltRdy : 1;  //! <Type Comment="Set if axis is in correct position an the jerkfilter is ready" Name="_LMCAXIS_STATUS.FiltRdy"/>
    long Decell : 1;  //! <Type Comment="Set if axis is braking" Name="_LMCAXIS_STATUS.Decell"/>
    long PosLimActive : 1;  //! <Type Comment="Set if axis has reached one of its endpositions" Name="_LMCAXIS_STATUS.PosLimActive"/>
    long SetFlg : 1;  //! <Type Comment="Set by calling one of the functions: SetPosition or ReferenceAxis&#13;&#10;Reset if the axis is activated" Name="_LMCAXIS_STATUS.SetFlg"/>
    long EnLesFlg : 1;  //! <Type Comment="Set if the axis moves endless / infinitely" Name="_LMCAXIS_STATUS.EnLesFlg"/>
    long DirFlg : 1;  //! <Type Comment="Set if the axis moves in negative direction - speed is negative" Name="_LMCAXIS_STATUS.DirFlg"/>
    long EmergStop : 1;  //! <Type Comment="Set if the axis stops because an error occured or the axis is deactivated" Name="_LMCAXIS_STATUS.EmergStop"/>
    long Overflow : 1;  //! <Type Comment="Set if a position-overflow occured" Name="_LMCAXIS_STATUS.Overflow"/>
    long MasterLock : 1;  //! <Type Comment="Set if the slave-axis is coupled onto a master-axis" Name="_LMCAXIS_STATUS.MasterLock"/>
    long DirLock : 1;  //! <Type Comment="the direction is locked&#13;&#10;(because of HWMin, HWMax&#13;&#10; or by PowerOnMode)" Name="_LMCAXIS_STATUS.DirLock"/>
    long DynSwLimit : 1;
    long ActDirFlg : 1;  //! <Type Comment="Set if the speed of the axis is negative" Name="_LMCAXIS_STATUS.ActDirFlg"/>
    long HandFlg : 1;  //! <Type Comment="Set if one of the functions: PowerOff or MoveHand is called" Name="_LMCAXIS_STATUS.HandFlg"/>
    long ModuloFlg : 1;  //! <Type Comment="Set if the axis is defined as a modulo-axis" Name="_LMCAXIS_STATUS.ModuloFlg"/>
    long NCMotion : 1;  //! <Type Comment="Set if the axis is in NC postion mode: &quot;_NCPositioning&quot;" Name="_LMCAXIS_STATUS.NCMotion"/>
    long NoActPosMeth : 1;  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoActPosMeth"/>
    long NoControlMeth : 1;  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;LMCController&quot; is not connected" Name="_LMCAXIS_STATUS.NoControlMeth"/>
    long NoRefMeth : 1;  //! <Type Comment="Set if the client &quot;LMCReference&quot; is not connected or&#13;&#10;the function &quot;CheckConnection&quot; returns &quot;FALSE&quot; or&#13;&#10;the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoRefMeth"/>
    long NoActPosChk : 1;  //! <Type Comment="Set if the client LMCSafety is connected and the function &quot;ChkHWReadyConnect&quot; returns &quot;FALSE&quot; or&#13;&#10;the client LMCSafety is not connected or&#13;&#10;the SimulateMode is active" Name="_LMCAXIS_STATUS.NoActPosChk"/>
    long NoPreRtWork : 1;  //! <Type Comment="Set if the client &quot;LMCPreRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPreRtWork"/>
    long NoPostRtWork : 1;  //! <Type Comment="Set if the client &quot;LMCPostRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPostRtWork"/>
    long DelayedMasterLock : 1;  //! <Type Comment="Set if the slave-axis is coupled onto a master-axis&#13;&#10;and reset when the MasterLock is 0 a configurable&#13;&#10;amount of cycles" Name="_LMCAXIS_STATUS.DelayedMasterLock"/>
    long Standstill : 1;  //! <Type Comment="Set if axis is not moving." Name="_LMCAXIS_STATUS.Standstill"/>
    long BrakeForPowerOff : 1;  //! <Type Comment="Set, if the axis is currently stoping for power off." Name="_LMCAXIS_STATUS.BrakeForPowerOff"/>
    long MasterError : 1;  //! <Type Comment="Set, if some error of the master axis occured." Name="_LMCAXIS_STATUS.MasterError"/>
    long SlaveError : 1;  //! <Type Comment="Set, if some error of a coupled slave axis occured." Name="_LMCAXIS_STATUS.SlaveError"/>
  }_LMCAXIS_STATUS;

typedef DINT _LMCAXIS_TUNE_MODE;   //! <Type Comment="Parameter of the function: &quot;TuneAxis&quot;&#13;&#10;Movement for the purpose of optimization of the control parameters" Name="_LMCAXIS_TUNE_MODE"/>
    #define LMCAXIS_TUNE_POSITON_IN_NEGATIVE_DIRECTION -2
    #define LMCAXIS_TUNE_ZERO_TO_NEGATIVE_POSITION -1
    #define LMCAXIS_TUNE_ACTPOSITION_POSITION 0
    #define LMCAXIS_TUNE_ZERO_TO_POSITIVE_POSITION 1
    #define LMCAXIS_TUNE_POSITON_IN_POSITIVE_DIRECTION 2

#pragma pack(push, 1)
typedef struct _LMCCommonCalcParas   //! <Type Comment="Common calculation parameters." Name="_LMCCommonCalcParas"/>
  {
    DINT ResolutionInt;  //! <Type Comment="Internal scale factor" Name="_LMCCommonCalcParas.ResolutionInt"/>
    UDINT Hires;  //! <Type Comment="Number of RtWork() cycles per second." Name="_LMCCommonCalcParas.Hires"/>
  } _LMCCommonCalcParas;
#pragma pack(pop)

typedef UDINT _LMCCONTROLLERTYPE; 
    #define _LMCNOCONTROLLER 0
    #define _LMCUSERCONTROLLER 1
    #define _LMCDUMMYCONTROLLER 2
    #define _LMCHYDROCONTROLLER 3
    #define _LMCKV_CONTROLLER 4
    #define _LMCNCCONTROLLER 5
    #define _LMCPOSCONTROLLER 6
    #define _LMCDRIVEPOSONTROL 7
    #define _LMCKV_CONTROLLER_NEW 104
    #define _LMCUSERCONTROLLER_NEW 101
    #define _LMCPOSCONTROLLER_NEW 106
    #define _LMCSIGMATEKCONTROLLER 107
    #define _LMCCALCMODEL_CONTROLLER 108

typedef UDINT _LMCPROF_ACTUALVALUES; 
    #define _LMCPROF_ACTUALPATH 0
    #define _LMCPROF_PATHLENGTH 1
    #define _LMCPROF_V_PATH 2
    #define _LMCPROF_ACTUALPATH_ORIG 3
    #define _LMCPROF_PATHLENGTH_ORIG 4
    #define _LMCPROF_DELTA_S 5

#pragma pack(push, 1)
typedef struct _LMCPROF_CIRCLEPOINT   //! <Type Comment="Absolute Position of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT"/>
  {
    DINT Point1;  //! <Type Comment="Absolute 1st coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point1"/>
    DINT Point2;  //! <Type Comment="Absolute 2nd coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point2"/>
    DINT Point3;  //! <Type Comment="Absolute 3rd coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point3"/>
  } _LMCPROF_CIRCLEPOINT;
#pragma pack(pop)

typedef UDINT _LMCPROF_CMDINDEX; 
    #define _LMCPROF_LASTLOADED 0
    #define _LMCPROF_ACTCMD 1
    #define _LMCPROF_VORANZ 2
    #define _LMCPROF_SUMINDEX 3
    #define _LMCPROF_LASTLOADED_I 4
    #define _LMCPROF_ACTCMD_I 5

typedef UDINT _LMCPROF_EXECUTE;   //! <Type Comment="Time of command execution" Name="_LMCPROF_EXECUTE"/>
    #define LMCPROF_BUFFERED 0
    #define LMCPROF_IMMEDIATE 1

typedef UDINT _LMCPROFCMDTYPES;   //! <Type Comment="Move command type" Name="_LMCPROFCMDTYPES"/>
    #define CMD_Nothing 0
    #define CMD_Linear 2
    #define CMD_CircleCW 5
    #define CMD_CircleCCW 4
    #define CMD_MoveCurve 12
    #define CMD_Circle3D 13
    #define CMD_SetProfPos 20

typedef struct   //! <Type Comment="Move command flags" Name="_LMCPROFINTCMDCONFIG"/>
  {
    long CmdActive : 1;  //! <Type Comment="1: the movement calculations are finished." Name="_LMCPROFINTCMDCONFIG.CmdActive"/>
    long RapidTraverse : 1;  //! <Type Comment="1: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFINTCMDCONFIG.RapidTraverse"/>
    long FeedRateInterpolation : 1;  //! <Type Comment="1: feed rate interpolation selected" Name="_LMCPROFINTCMDCONFIG.FeedRateInterpolation"/>
    long SecondTransition : 1;  //! <Type Comment="0: this is the first transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected&#13;&#10;1: this is the second transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected" Name="_LMCPROFINTCMDCONFIG.SecondTransition"/>
    long IsProgrammedExactStop : 1;  //! <Type Comment="this path segment was programmed with TransitionMode:=_LMCPROF_EXACT_STOP" Name="_LMCPROFINTCMDCONFIG.IsProgrammedExactStop"/>
    long AfterSetPosCmd : 1;  //! <Type Comment="The command before this one is a SetProfilePositions(). This command maybe needs to be recomputed." Name="_LMCPROFINTCMDCONFIG.AfterSetPosCmd"/>
    long MoveCurveSplineInserted : 1;
    long MoveCurveSplineExecuting : 1;
    long MoveCurvePathPerThousand : 1;
    long dummy0 : 7;
    long PathLenReduced : 1;  //! <Type Comment="The pathlength was reduced when inserting a transition movement (spline etc.).&#13;&#10;The attainable entry speed must be calculated new." Name="_LMCPROFINTCMDCONFIG.PathLenReduced"/>
    long dummy1 : 7;
    long Activated : 1;
    long WaitFinish : 1;
  }_LMCPROFINTCMDCONFIG;

typedef UDINT _LMCPROFTRANSMODES;   //! <Type Comment="Transition type between path segments" Name="_LMCPROFTRANSMODES"/>
    #define _LMCPROF_EXACT_STOP 0
    #define _LMCPROF_CONT_DIRECT 2
    #define _LMCPROF_SMOOTH_CUBIC 3
    #define _LMCPROF_SMOOTH_PARAB 4
    #define _LMCPROF_SMOOTH_QUINT 5

typedef struct   //! <Type Comment="Circle axes definition" Name="_LMCPROFCIRCLEDEF"/>
  {
    long Axis1 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis1"/>
    long Axis2 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis2"/>
    long Axis3 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis3"/>
    long Axis4 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis4"/>
    long Axis5 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis5"/>
    long Axis6 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis6"/>
    long Axis7 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis7"/>
    long Axis8 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis8"/>
    long Axis9 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis9"/>
  }_LMCPROFCIRCLEDEF;

#pragma pack(push, 1)
typedef struct _LMCPROF_POSITIONS   //! <Type Comment="Start and end positions of an axis [Internal units]" Name="_LMCPROF_POSITIONS"/>
  {
    DINT start;  //! <Type Comment="[Internal units]" Name="_LMCPROF_POSITIONS.start"/>
    DINT end;  //! <Type Comment="[Internal units]" Name="_LMCPROF_POSITIONS.end"/>
  } _LMCPROF_POSITIONS;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _LMCPROF_MoveData   //! <Type Comment="Element of the profile buffer " Name="_LMCPROF_MoveData"/>
  {
    UDINT index;  //! <Type Comment="Index in the profile buffer" Name="_LMCPROF_MoveData.index"/>
    _LMCPROFCMDTYPES enCmdType;  //! <Type Comment="Move command type" Name="_LMCPROF_MoveData.enCmdType"/>
    _LMCPROFINTCMDCONFIG bsCmdFlags;  //! <Type Comment="Move command flags" Name="_LMCPROF_MoveData.bsCmdFlags"/>
    _LMCPROFTRANSMODES enTransitionMode;  //! <Type Comment="Type of transition between path segments" Name="_LMCPROF_MoveData.enTransitionMode"/>
    DINT dTransitionRadius;  //! <Type Comment="Radius of the tolerance sphere. Used for the smooth rounding mode, the rounding mode with tolerance sphere and for the rounding mode with cubic spline." Name="_LMCPROF_MoveData.dTransitionRadius"/>
    _LMCPROFCIRCLEDEF bdCirAxis;  //! <Type Comment="Defines the circle axes." Name="_LMCPROF_MoveData.bdCirAxis"/>
    _LMCPROF_POSITIONS stPositions [_LMC_MAX_AXIS-1+1-0];  //! <Type Comment="Start and end positions of all axes [Internal units]" Name="_LMCPROF_MoveData.stPositions"/>
    DINT xMp;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the first circle axis [Internal units]" Name="_LMCPROF_MoveData.xMp"/>
    DINT yMp;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the second circle axis [Internal units]" Name="_LMCPROF_MoveData.yMp"/>
    DINT PathLength;  //! <Type Comment="Path length [Internal units]" Name="_LMCPROF_MoveData.PathLength"/>
    DINT vMax;  //! <Type Comment="Max. allowed path speed [Internal units/tick]" Name="_LMCPROF_MoveData.vMax"/>
    DINT aMax;  //! <Type Comment="Max. allowed path acceleration [Internal units/tick²]" Name="_LMCPROF_MoveData.aMax"/>
    DINT dMax;  //! <Type Comment="Max. allowed path deceleration [Internal units/tick²]" Name="_LMCPROF_MoveData.dMax"/>
    DINT jMax;  //! <Type Comment="Max. allowed path jerk [Internal units/tick²/sec]" Name="_LMCPROF_MoveData.jMax"/>
  } _LMCPROF_MoveData;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _LMCPROF_OBSTACLE   //! <Type Comment="Data for MoveCurve definition" Name="_LMCPROF_OBSTACLE"/>
  {
    BOOL PathPerThousand;  //! <Type Comment="FALSE: The distances Obstacle.PathStart and Obstacle.PathEnd are given in application units.&#13;&#10;TRUE: The distances Obstacle.PathStart and Obstacle.PathEnd are given in parts per thousand of the path length." Name="_LMCPROF_OBSTACLE.PathPerThousand"/>
    DINT HeightStart_relativ;  //! <Type Comment="The evasive movement starts with an &quot;linear up movement&quot;. This value defines its height. &#13;&#10;distance in [application units]" Name="_LMCPROF_OBSTACLE.HeightStart_relativ"/>
    DINT AxisNr;  //! <Type Comment="Number of axis, in which direction the evasive movement should be performed [1-9]." Name="_LMCPROF_OBSTACLE.AxisNr"/>
    DINT HeightEnd_relativ;  //! <Type Comment="The evasive movement ends with a &quot;linear down movement&quot;. This value defines its height. &#13;&#10;distance in [application units]" Name="_LMCPROF_OBSTACLE.HeightEnd_relativ"/>
    DINT PathStart;  //! <Type Comment="position, where the HeightStart_absolute should be reached.&#13;&#10;&#13;&#10;Depending on the _LMCPROF_OBSTACLE struct element PathPerThousand the length is given in application units or in parts per thousand of the length of the &quot;vertical&quot; movement." Name="_LMCPROF_OBSTACLE.PathStart"/>
    DINT HeightStart_absolut;  //! <Type Comment="position of the evasive axis at PathStart [application units]" Name="_LMCPROF_OBSTACLE.HeightStart_absolut"/>
    DINT PathEnd;  //! <Type Comment="position, where the HeightEnd_absolute should be reached. The distance is measured from the end of the vertical movement.&#13;&#10;&#13;&#10;Depending on the _LMCPROF_OBSTACLE struct element PathPerThousand the length is given in application units or in parts per thousand of the length of the &quot;vertical&quot; movement.&#13;&#10;&#13;&#10;This value is ignored, if PathEnd + PathStart is longer then the vertical distance." Name="_LMCPROF_OBSTACLE.PathEnd"/>
    DINT HeightEnd_absolut;  //! <Type Comment="position of the evasive axis at PathEnd [application units]&#13;&#10;&#13;&#10;This value is ignored, if PathEnd + PathStart is longer then the vertical distance." Name="_LMCPROF_OBSTACLE.HeightEnd_absolut"/>
    DINT VelStart_relativ_ppT;  //! <Type Comment="value &gt; 0: maximal velocity of the starting linear up movement in parts per thousand of the programmed Velocity value.&#13;&#10;&#13;&#10;value &lt;= 0: maximal velocity of the starting linear up movement equals the programmed Velocity." Name="_LMCPROF_OBSTACLE.VelStart_relativ_ppT"/>
    DINT VelEnd_relativ_ppT;  //! <Type Comment="value &gt; 0: maximal velocity of the ending linear down movement in parts per thousand of the programmed Velocity value.&#13;&#10;&#13;&#10;value &lt;= 0: maximal velocity of the ending linear down movement equals the programmed Velocity." Name="_LMCPROF_OBSTACLE.VelEnd_relativ_ppT"/>
  } _LMCPROF_OBSTACLE;
#pragma pack(pop)

typedef UDINT _LMCPROF_OPMODE;   //! <Type Comment="Operating mode" Name="_LMCPROF_OPMODE"/>
    #define _LMC_AUTOMATIC 0
    #define _LMC_MANUAL 1

#pragma pack(push, 1)
typedef struct _LMCPROF_POS   //! <Type Comment="Absolute Endpositions / relative distances of all Axes [Application Units]" Name="_LMCPROF_POS"/>
  {
    DINT Pos1;  //! <Type Comment="Absolute Endposition of Axis1 [Application Units]" Name="_LMCPROF_POS.Pos1"/>
    DINT Pos2;  //! <Type Comment="Absolute Endposition of Axis2 [Application Units]" Name="_LMCPROF_POS.Pos2"/>
    DINT Pos3;  //! <Type Comment="Absolute Endposition of Axis3 [Application Units]" Name="_LMCPROF_POS.Pos3"/>
    DINT Pos4;  //! <Type Comment="Absolute Endposition of Axis4 [Application Units]" Name="_LMCPROF_POS.Pos4"/>
    DINT Pos5;  //! <Type Comment="Absolute Endposition of Axis5 [Application Units]" Name="_LMCPROF_POS.Pos5"/>
    DINT Pos6;  //! <Type Comment="Absolute Endposition of Axis6 [Application Units]" Name="_LMCPROF_POS.Pos6"/>
    DINT Pos7;  //! <Type Comment="Absolute Endposition of Axis7 [Application Units]" Name="_LMCPROF_POS.Pos7"/>
    DINT Pos8;  //! <Type Comment="Absolute Endposition of Axis8 [Application Units]" Name="_LMCPROF_POS.Pos8"/>
    DINT Pos9;  //! <Type Comment="Absolute Endposition of Axis9 [Application Units]" Name="_LMCPROF_POS.Pos9"/>
  } _LMCPROF_POS;
#pragma pack(pop)

typedef UDINT _LMCPROF_RECOUPLEMODE; 
    #define _LMCPROF_RECOUPLE_TO_PROFILE 0
    #define _LMCPROF_RECOUPLE_TO_ACTPOS 1

typedef UDINT _LMCPROF_RESTIME_CALCMODE;   //! <Type Comment="Modus of calculation of the Residualtime" Name="_LMCPROF_RESTIME_CALCMODE"/>
    #define LMCPROF_TONEXT_STOPP 0
    #define LMCPROF_TO_NEXT_PATH_SEGMENT 1
    #define LMCPROF_TO_NEXT_PATH_SEGMENT_ORIG 2

typedef UDINT _LMCPROF_SETPOS_MODE;   //! <Type Comment="Mode defines how we get the set positions." Name="_LMCPROF_SETPOS_MODE"/>
    #define _LMCPROF_SETPOS_TO_AXES_POS 0
    #define _LMCPROF_SETPOS_TO_USER_POS 1
    #define _LMCPROF_SETPOS_TO_USER_POS_NO_AX_TRAVEL 2

typedef struct   //! <Type Comment="Move command flags" Name="_LMCPROFCMDCONFIG"/>
  {
    long RapidTraverse : 1;  //! <Type Comment="True: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFCMDCONFIG.RapidTraverse"/>
    long CircleCW : 1;  //! <Type Comment="True: circular movement clockwise in case of a 2-dimensional movement&#13;&#10;True: circular movement dromic in case of a 3-dimensional movement" Name="_LMCPROFCMDCONFIG.CircleCW"/>
    long CircleCCW : 1;  //! <Type Comment="True: circular movement counter clockwise in case of a 2-dimensional movement&#13;&#10;True: circular movement antidromic in case of a 3-dimensional movement" Name="_LMCPROFCMDCONFIG.CircleCCW"/>
    long FeedRateInterpolation : 1;  //! <Type Comment="True: feed rate interpolation selected. The feedrate changes linearly over the path length." Name="_LMCPROFCMDCONFIG.FeedRateInterpolation"/>
  }_LMCPROFCMDCONFIG;

typedef UDINT _LMCPROFCMDTYPES_INTERN;   //! <Type Comment="Move command type" Name="_LMCPROFCMDTYPES_INTERN"/>
    #define _LMCPROF_CMD_Nothing 0
    #define _LMCMT_NoPosChange 1
    #define _LMCMT_Linear 2
    #define _LMCMT_SpeedLimit 3
    #define _LMCMT_CircleCCW 4
    #define _LMCMT_CircleCW 5
    #define _LMCMT_Round_All 6
    #define _LMCMT_Lin_Round_Aux 7
    #define _LMCMT_Circle_Lin_Round_Aux 8
    #define _LMCMT_SplineCub 9
    #define _LMCMT_SplineQuint 10
    #define _LMCMT_Fourier 11
    #define _LMCMT_MoveCurve 12
    #define _LMCMT_Circle3D 13
    #define _LMCMT_SetProfPos 20

typedef UDINT _LMCPROFERRORTYPES;   //! <Type Comment="Error numbers" Name="_LMCPROFERRORTYPES"/>
    #define _LMCPROF_NoError 0
    #define _LMCPROF_INIT_ERROR 1
    #define _LMCPROF_MOVECMD_ERROR 2
    #define _LMCPROF_INT_POINTER_ERROR 3
    #define _LMCPROF_JUMP_CMD_ERROR 4
    #define _LMCPROF_POS_OVERRUN_ERROR 5
    #define _LMCPROF_AXIS_ERROR 6
    #define _LMCPROF_SWE_ERROR 7
    #define _LMCPROF_CIRDEF_ERROR 8
    #define _LMCPROF_NO_POS_CHANGE 9
    #define _LMCPROF_GROUP_ERROR 10
    #define _LMCPROF_KOFAC_ERROR 11
    #define _LMCPROF_VEL_CMD_ERROR 12
    #define _LMCPROF_ACC_CMD_ERROR 13
    #define _LMCPROF_JERK_CMD_ERROR 14
    #define _LMCPROF_RESOLUTION_ERROR 15
    #define _LMCPROF_SAFETY_ZONES_REACHED 16
    #define _LMCPROF_INSERT_ERROR 17
    #define _LMCPROF_AXIS_NOT_CONNECTED 18
    #define _LMCPROF_GROUP_NOT_FOUND 19
    #define _LMCPROF_PARAMETER_NOT_FOUND 20
    #define _LMCPROF_PARAMETER_ERROR 21
    #define _LMCPROF_ERROR_BUSY 22
    #define _LMCPROF_OUT_OF_RANGE 23
    #define _LMCPROF_RADIUS_ERROR 24
    #define _LMCPROF_ARCLEN_ERROR 25
    #define _LMCPROF_RES_PATHLEN_ERROR 26
    #define _LMCPROF_ENDPOS_ERROR 27
    #define _LMCPROF_AXTRAVEL_ERROR 28
    #define _LMCPROF_AX_COUPLE_ERROR 29
    #define _LMCPROF_PLAINEDEF_ERROR 30
    #define _LMCPROF_VEC_ERROR 31
    #define _LMCPROF_LOCKGROUP_ERROR 32
    #define _LMCPROF_LINEDEF_ERROR 33
    #define _LMCPROF_CHORDLEN_ERROR 34
    #define _LMCPROF_LOCKGROUP_DIFF_RESTART 35
    #define _LMCPROF_REFPOINT_DIFF_RESTART 36
    #define _LMCPROF_AXIS_POS_ERROR 37
    #define _LMCPROF_INPOSITION_TIMEOUT_ERROR 38
    #define _LMCROBOT_REF_ERROR 1000
    #define _LMCROBOT_AX_COUPLING_ERROR 1001
    #define _LMCROBOT_BACKUP_POS_ERROR 1002
    #define _LMCROBOT_POWERON_ERROR 1003
    #define _LMCROBOT_POS_CHECK_ERROR 1004
    #define _LMCROBOT_LINEUP_AX_ERROR 1005
    #define _LMCROBOT_COUPLE_TIMEOUT 1006
    #define _LMCROBOT_AX_COUPLING_LOST 1007
    #define _LMCROBOT_AXIS_ERROR 1008
    #define _LMCROBOT_BELTCOUPLING_ERROR 1009
    #define _LMCROBOT_COORDSYSTEM_ERROR 1010
    #define _LMCROBOT_AX_CMD_ERROR 1011
    #define _LMCROBOT_KINEMATIC_ERROR 1012

#pragma pack(push, 1)
typedef struct _LMCPROFERRORDEF   //! <Type Comment="Error information" Name="_LMCPROFERRORDEF"/>
  {
    DINT LineNo;  //! <Type Comment="Number of the source code line where the error was reported" Name="_LMCPROFERRORDEF.LineNo"/>
    _LMCPROFERRORTYPES ErrorNo;  //! <Type Comment="Error number" Name="_LMCPROFERRORDEF.ErrorNo"/>
    DINT SubErrorNo;  //! <Type Comment="Additional error information" Name="_LMCPROFERRORDEF.SubErrorNo"/>
  } _LMCPROFERRORDEF;
#pragma pack(pop)

typedef struct   //! <Type Comment="User defined error message configuration" Name="_LMCPROFERRWARNCONFIG"/>
  {
    long bPosChangeWarning : 1;  //! <Type Comment="FALSE: no warning is issued when a movement with zero path length is encountered &#13;&#10;TRUE : a warning is issued when a movement with zero path length is encountered" Name="_LMCPROFERRWARNCONFIG.bPosChangeWarning"/>
    long bResolutionError : 1;  //! <Type Comment="FALSE: a warning is issued when a parameter value * resolution does not fit into a 32 bit signed integer.&#13;&#10;TRUE : an error is issued when a parameter value * resolution does not fit into a 32 bit signed integer." Name="_LMCPROFERRWARNCONFIG.bResolutionError"/>
    long bPosLimitError : 1;  //! <Type Comment="FALSE: a warning is issued when the endpoint of a movement is ouside of the software end position&#13;&#10;TRUE : an error is issued when the endpoint of a movement is ouside of the software end position" Name="_LMCPROFERRWARNCONFIG.bPosLimitError"/>
    long bCircleError : 1;  //! <Type Comment="FALSE: a warning is issued when the number of circle axes is not equal two.&#13;&#10;TRUE : an error is issued when the number of circle axes is not equal two." Name="_LMCPROFERRWARNCONFIG.bCircleError"/>
    long bCmdLimitError : 1;  //! <Type Comment="FALSE: a warning is issued when the path speed or path acceleration is less than one due to a limit in an auxiliary axis&#13;&#10;TRUE : an error is issued when the path speed or path acceleration is less than one due to a limit in an auxiliary axis" Name="_LMCPROFERRWARNCONFIG.bCmdLimitError"/>
    long bKoFacError : 1;  //! <Type Comment="FALSE: a warning is issued when the coupling factor does not fit into a 32 bit signed integer.&#13;&#10;TRUE : an error is issued when the coupling factor does not fit into a 32 bit signed integer." Name="_LMCPROFERRWARNCONFIG.bKoFacError"/>
    long bSafetyZonesError : 1;  //! <Type Comment="FALSE: a warning is issued when the endpoint of a movement is inside of a safety zone&#13;&#10;TRUE : an error is issued when the endpoint of a movement is inside of a safety zone" Name="_LMCPROFERRWARNCONFIG.bSafetyZonesError"/>
  }_LMCPROFERRWARNCONFIG;

typedef struct   //! <Type Comment="Profile States" Name="_LMCPROFILESTATES"/>
  {
    long bProfileLocked : 1;  //! <Type Comment="TRUE  .. All required axes are coupled to the profile.&#13;&#10;FALSE .. Axes are not coupled." Name="_LMCPROFILESTATES.bProfileLocked"/>
    long bProfileStoped : 1;  //! <Type Comment="TRUE ... command StopMove() is active and axes are not moving.&#13;&#10;FALSE .. command StopMove() is not active or at least the profile has not stopped now." Name="_LMCPROFILESTATES.bProfileStoped"/>
    long bProfileBraking : 1;  //! <Type Comment="TRUE ... The profile is reducing its speed.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bProfileBraking"/>
    long bNoPreRtWork : 1;  //! <Type Comment="TRUE ... LMCPreRtWorkTrigger is not connected&#13;&#10;FALSE .. LMCPreRtWorkTrigger is connected&#13;&#10;" Name="_LMCPROFILESTATES.bNoPreRtWork"/>
    long bNoPostRtWork : 1;  //! <Type Comment="TRUE ... LMCPostRtWorkTrigger is not connected&#13;&#10;FALSE .. LMCPostRtWorkTrigger is connected" Name="_LMCPROFILESTATES.bNoPostRtWork"/>
    long bBraketoExactStop : 1;  //! <Type Comment="TRUE ... The profile is reducing its speed due to stoping at an exact stop point.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bBraketoExactStop"/>
    long bDynSWLimit : 1;  //! <Type Comment="TRUE ... maximumum or minimum dynamic software limit has been reached&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bDynSWLimit"/>
    long bBraketoDynSWLimit : 1;  //! <Type Comment="TRUE ... The profile is reducing its speed due to a dynamic software limit&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bBraketoDynSWLimit"/>
    long bDynSWLimitViolation : 1;  //! <Type Comment="TRUE ... The dynamic software limit is violated or we probably cannot stop before violating it.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bDynSWLimitViolation"/>
  }_LMCPROFILESTATES;

typedef UDINT _LMCPROFINPOSTYPES;   //! <Type Comment="Mode" Name="_LMCPROFINPOSTYPES"/>
    #define _LMCPROF_ProfileInPosition 0
    #define _LMCPROF_ProfileFinished 1
    #define _LMCPROF_ProfileAxisInPos 2
    #define _LMCPROF_ProfileAxisFinished 3
    #define _LMCPROF_ProfileInWindow 4
    #define _LMCPROF_ProfileInWindowFinished 5
    #define _LMCPROF_ProfileAndAxisInWindow 6
    #define _LMCPROF_ProfileAndAxisInWindowFinished 7
    #define _LMCPROF_ProfileStandstill 8

typedef UDINT _LMCPROFMOVEPROFILE;   //! <Type Comment="Type of profile" Name="_LMCPROFMOVEPROFILE"/>
    #define RAMP_PROFILE 0
    #define JERK_PROFILE 1

typedef UDINT _LMCPROFPARAMETER;   //! <Type Comment="_LMCProfile parameters" Name="_LMCPROFPARAMETER"/>
    #define _LMCPROF_MaxOverride 0
    #define _LMCPROF_MinOverride 1
    #define _LMCPROF_SafetyZones 2
    #define _LMCPROF_Max_Entries 3
    #define _LMCPROF_NoOverrideChange 4
    #define _LMCPROF_ChkArcLength 9
    #define _LMCPROF_NoChkAuxAxis 10
    #define _LMCPROF_OverrideType 11
    #define _LMCPROF_RoundConnectMode 13
    #define _LMCPROF_aMinOverride 14
    #define _LMCPROF_ActVel 15
    #define _LMCPROF_ActAcc 16
    #define _LMCPROF_MoveType 17
    #define _LMCPROF_LockState 21
    #define _LMCPROF_Window 22
    #define _LMCPROF_vSTART_F_IPO 23
    #define _LMCPROF_CheckAxisGroup 24
    #define _LMCPROF_NormOverride 25
    #define _LMCPROF_AxisCount 26
    #define _LMCPROF_AddOffset 27
    #define _LMCPROF_Read_Decel 28
    #define _LMCPROF_Read_Timebase 29
    #define _LMCPROF_LookAhead 30
    #define _LMCPROF_HalfCircleTolerance 31
    #define _LMCPROF_TransRad_ppTh 32
    #define _LMCPROF_Set_LogMode 33
    #define _LMCPROF_ChkEndPosForSwLimit 34
    #define _LMCPROF_ProfileInPos 35
    #define _LMCPROF_ProfileInPos_Timeout 36
    #define _LMCPROF_UnlimitCurveSplines 37
    #define _LMCPROF_IncreaseLimit_SpeedWindow 38
    #define _LMCPROF_IncreaseLimit_FastAccel 39
    #define _LMCPROF_IncreaseLimit_FastJerk 40

typedef UDINT _LMCPROFPARAMETERAXIS;   //! <Type Comment="Type of axis parameter" Name="_LMCPROFPARAMETERAXIS"/>
    #define _LMCPROF_AX_VEL_LIMIT 0
    #define _LMCPROF_AX_ACCEL_LIMIT 1
    #define _LMCPROF_AX_TJERK 2
    #define _LMCPROF_AX_UNLOCK_DECEL 3
    #define _LMCPROF_AX_MAX_VEL_JUMP 4
    #define _LMCPROF_AX_INPOS_WINDOW 5
    #define _LMCPROF_AX_LOCK_GRP 6
    #define _LMCPROF_AX_MAX_ACCEL_JUMP 7
    #define _LMCPROF_AX_DEC 8
    #define _LMCPROF_AX_NOT_CHECK_SWLIMIT 9
    #define _LMCPROF_AX_SW_MIN_LIMIT 10
    #define _LMCPROF_AX_SW_MAX_LIMIT 11
    #define _LMCPROF_AX_INPOS_WIN_ADDITIVELYCOUPLED 12
    #define _LMCPROF_AX_VEL_LIMIT_RAPID_TRAVERSE 13
    #define _LMCPROF_AX_ACCEL_LIMIT_RAPID_TRAVERSE 14
    #define _LMCPROF_AX_TJERK_RAPID_TRAVERSE 15

typedef UDINT _LMCPROFPARAMETERGROUPS;   //! <Type Comment="Type of axes group parameter" Name="_LMCPROFPARAMETERGROUPS"/>
    #define _LMCPROF_GRP_VEL_LIMIT 0
    #define _LMCPROF_GRP_ACCEL_LIMIT 1
    #define _LMCPROF_GRP_TJERK 2

typedef struct   //! <Type Comment="Currently active profile settings." Name="_LMCPROFSETTINGS"/>
  {
    long bInitDone : 1;  //! <Type Comment="Set if the Last Init run was done&#13;&#10;This var is used for lock some SetPar Functions" Name="_LMCPROFSETTINGS.bInitDone"/>
    long bFirstInitDone : 1;  //! <Type Comment="Set if the first init run was done&#13;&#10;This var is used for lock some SetPar Functions" Name="_LMCPROFSETTINGS.bFirstInitDone"/>
    long bOverrideTyp : 1;  //! <Type Comment="0: Default value. The type of Override is always based on the actual speed of the path segment. &#13;&#10;1: The type of Override is based on the specified speed of the path segment only. Limits of the path speed by circle limits, maximum speeds, etc. are not included in the override calculation." Name="_LMCPROFSETTINGS.bOverrideTyp"/>
    long bNoOverrideChange : 1;  //! <Type Comment="0: Default value. When calling the LockProfile() method, the override is set to the maximum value automatically.&#13;&#10;1: When calling the LockProfile() method, the override is not changed and therefore remains at the last values set." Name="_LMCPROFSETTINGS.bNoOverrideChange"/>
    long bNoChkSWLimit : 1;
    long LogReadMethods : 1;  //! <Type Comment="Additionally log request method calls" Name="_LMCPROFSETTINGS.LogReadMethods"/>
    long LogMethodCallPlusParam : 1;  //! <Type Comment="Additionally log the method parameters" Name="_LMCPROFSETTINGS.LogMethodCallPlusParam"/>
    long bFatalError : 1;  //! <Type Comment="Is set if the Init was not OK ... We have no Buffer memory" Name="_LMCPROFSETTINGS.bFatalError"/>
    long bExtTrigger : 1;  //! <Type Comment="0: RtWork() is called by the the operating system (default)&#13;&#10;1: RtWork() has to be called by the application" Name="_LMCPROFSETTINGS.bExtTrigger"/>
    long bAxCount : 1;  //! <Type Comment="This Bit indicates, if the user already set the number of used axis with the methode SetProfileParameter - _LMCPROF_AxisCount." Name="_LMCPROFSETTINGS.bAxCount"/>
    long bChkArcLength : 1;  //! <Type Comment="0: Default value. Whether the arc length is the same as the chord length, is not tested.&#13;&#10;1: If the arc length is the same as the chord length + 1, a linear movement is executed instead of a circular movement." Name="_LMCPROFSETTINGS.bChkArcLength"/>
    long bNoChkAuxAxis : 1;  //! <Type Comment="0: Default value. Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes and the limit values of the auxiliary axes.&#13;&#10;1: Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes only." Name="_LMCPROFSETTINGS.bNoChkAuxAxis"/>
    long bWaitActPosition : 1;  //! <Type Comment="0: the exact stop functions with the set position (default)&#13;&#10;1: the exact stop functions with the actual position" Name="_LMCPROFSETTINGS.bWaitActPosition"/>
    long bNoLookAhead : 1;  //! <Type Comment="0: Default value. the move-command must calculate a&#13;&#10;   vNext, so it takes a bit more time, but the speed&#13;&#10;   of connected move-commands can be reached exactly at&#13;&#10;   the end of the further command&#13;&#10;1: there is no calculation of vNext, so the velocity&#13;&#10;   reaches the new target-velocity, when it would go&#13;&#10;   down to standstill" Name="_LMCPROFSETTINGS.bNoLookAhead"/>
    long bOverrideInitialized : 1;
    long bRoundConnectMode : 1;  //! <Type Comment="FALSE: Default value. The single axis movement at the segment transfer with tolerance sphere is always trapezoidal.&#13;&#10;TRUE : The single axis movement at the segment transfer with tolerance sphere is executed with a &quot;softer&quot; movement.&#13;&#10;       As the duration of the movement remains unchanged compared to the trapezoidal movement, temporarily the acceleration is higher than defined but the jerk is minimized." Name="_LMCPROFSETTINGS.bRoundConnectMode"/>
    long bCheckAxisGroup : 1;  //! <Type Comment="False: the AxisGroup where checked&#13;&#10;True : no check of the AxisGroup" Name="_LMCPROFSETTINGS.bCheckAxisGroup"/>
    long bNoOffsetposition : 1;  //! <Type Comment="false = the Offsetposition is added to the server Position/Destination&#13;&#10;true = the Offsetposition is not added to the server Position/Destination" Name="_LMCPROFSETTINGS.bNoOffsetposition"/>
    long NoLimitCurveAxisSpline : 1;  //! <Type Comment="NoLimitCurveAxisSpline = 1:  &#13;&#10;No monitoring inside of the transition-sphere moving along a quint-spline:&#13;&#10;limitation of jerk to maximal jerk and also &#13;&#10;limitation of acceleration to maximal acceleration is disregarded for the swerve-axis" Name="_LMCPROFSETTINGS.NoLimitCurveAxisSpline"/>
    long NoLimitAllCurveAxisSplines : 1;  //! <Type Comment="NoLimitAllCurveAxisSplines = 1:  &#13;&#10;No monitoring inside of the transition-sphere moving along a quint-spline:&#13;&#10;limitation of jerk to maximal jerk and also &#13;&#10;limitation of acceleration to maximal acceleration is disregarded for all axis" Name="_LMCPROFSETTINGS.NoLimitAllCurveAxisSplines"/>
    long bOverrideAxLimit : 1;  //! <Type Comment="just has an effect with bOverrideTyp = 1&#13;&#10;FALSE --&gt; Default: The type of Override is based on the specified speed of the path segment only.&#13;&#10;TRUE  --&gt; The type of Override is based on the actual speed of the path segment." Name="_LMCPROFSETTINGS.bOverrideAxLimit"/>
    long Axis_1_IsConnected : 1;
    long Axis_2_IsConnected : 1;
    long Axis_3_IsConnected : 1;
    long Axis_4_IsConnected : 1;
    long Axis_5_IsConnected : 1;
    long Axis_6_IsConnected : 1;
    long Axis_7_IsConnected : 1;
    long Axis_8_IsConnected : 1;
    long Axis_9_IsConnected : 1;
    long bLMCCNCIprMode : 1;
  }_LMCPROFSETTINGS;

typedef struct 
  {
    long SetSFF : 1;  //! <Type Comment="0 .. the set velocity isn&apos;t written to the drive axis object (SFF)&#13;&#10;1 .. default :the set velocity is written to the drive axis object (SFF)" Name="_POSFLAGS.SetSFF"/>
    long XWCalcInt : 1;  //! <Type Comment="0 .. default : the contouring error is read directly from the drive axis object&#13;&#10;1 .. the contouring error is calculated in the DrivePosControl object&#13;&#10;" Name="_POSFLAGS.XWCalcInt"/>
  }_POSFLAGS;

typedef struct 
  {
    long SDD_OnePhase : 1;
    long SDD_MainError : 1;
    long SDD_MotorAxisOverCurrent : 1;
    long SDD_DCOver : 1;
    long SDD_DCUnder : 1;
    long SDD_PhaseFailure : 1;
    long SDD_BrakeError : 1;
    long SDD_BrakeSwitchError : 1;
    long SDD_Free3 : 1;
    long SDD_MotorOverTemp : 1;
    long SDD_AmbientOverTemp : 1;
    long SDD_HeatSinkOverTemp : 1;
    long SDD_FeedBackError : 1;
    long SDD_CommutationError : 1;
    long SDD_Overspeed : 1;
    long SDD_PEMax : 1;
    long SDD_PCmdError : 1;
    long SDD_HostComError : 1;
    long SDD_DriveError_E2 : 1;
    long SDD_DriveErrorE1 : 1;
    long SDD_EnableLockedError : 1;
    long SDD_DriverVoltageError : 1;
    long SDD_MaxRegenPower : 1;
    long SDD_Brake24VError : 1;
    long SDD_BrakeEnableError : 1;
    long SDD_I2TError : 1;
    long SDD_MotorTempWarn : 1;
    long SDD_MotorObjectError : 1;
    long SDD_MultiPosError : 1;
    long SDD_MaxSumPowerLimit : 1;
    long SDD_SpeedControlerSaturation : 1;
    long SDD_FanError : 1;
  }_SDDISTATE;

typedef struct 
  {
    long HwError : 1;  //! <Type Comment="Hardware error Flag" Name="CncFlags.HwError"/>
    long SwMin : 1;  //! <Type Comment="Software endswitch minimum active" Name="CncFlags.SwMin"/>
    long SwMax : 1;  //! <Type Comment="Software endswitch maximum active" Name="CncFlags.SwMax"/>
    long v_error : 1;  //! <Type Comment="velocity setting error" Name="CncFlags.v_error"/>
    long a_error : 1;  //! <Type Comment="Acceleration / deceleration setting error" Name="CncFlags.a_error"/>
    long ContrOff : 1;  //! <Type Comment="position controller off" Name="CncFlags.ContrOff"/>
    long NoRef : 1;  //! <Type Comment="no position reference" Name="CncFlags.NoRef"/>
    long DragLim : 1;  //! <Type Comment="contouring error" Name="CncFlags.DragLim"/>
    long ComandErr : 1;  //! <Type Comment="Command is not exepted" Name="CncFlags.ComandErr"/>
    long ActPosError : 1;  //! <Type Comment="invalid position of the hardware" Name="CncFlags.ActPosError"/>
    long IsNotControlling : 1;  //! <Type Comment="wake and shake is active" Name="CncFlags.IsNotControlling"/>
    long Follow : 1;
    long OverFlowError : 1;
    long dummy0 : 2;
    long GlobErr : 1;  //! <Type Comment="Any other errors is active" Name="CncFlags.GlobErr"/>
  }CncFlags;

#pragma pack(push, 1)
typedef struct CNCInternalStruct 
  {
    DINT *ptrExt;
    DINT *ptrInt;
    DINT *ptrBinOffset;
    DINT NowOverflow;
    DINT OverflowDelta;
    DINT SetPos;
  } CNCInternalStruct;
#pragma pack(pop)

typedef struct 
  {
    long InPosition : 1;  //! <Type Comment="Axis is in position" Name="CntrFlgs.InPosition"/>
    long FiltRdy : 1;  //! <Type Comment="Axis is in position and jerk filter is ready" Name="CntrFlgs.FiltRdy"/>
    long PosLimActive : 1;  //! <Type Comment="Position limit is active, set position is over the SW end position" Name="CntrFlgs.PosLimActive"/>
    long Decell : 1;  //! <Type Comment="Deceleration is active" Name="CntrFlgs.Decell"/>
    long bDynSWLimit : 1;  //! <Type Comment="Set if axis has reached one of its dynamic SW endpositions" Name="CntrFlgs.bDynSWLimit"/>
    long dummy0 : 1;
    long SetFlg : 1;  //! <Type Comment="Set by calling the SetPositon, CNCRefRun and NCRefRun functions Reset after activating the controller." Name="CntrFlgs.SetFlg"/>
    long dummy1 : 2;
    long EnLesFlg : 1;  //! <Type Comment="Endless positioning is active" Name="CntrFlgs.EnLesFlg"/>
    long DirFlg : 1;  //! <Type Comment="Commanded axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.DirFlg"/>
    long ActDirFlg : 1;  //! <Type Comment="Actual axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.ActDirFlg"/>
    long EmergStop : 1;  //! <Type Comment="Emergency stop is active" Name="CntrFlgs.EmergStop"/>
    long AutoRun : 1;  //! <Type Comment="Controller output autotuning is running" Name="CntrFlgs.AutoRun"/>
    long AutoStop : 1;  //! <Type Comment="Controller output autotuning is ready" Name="CntrFlgs.AutoStop"/>
    long Test : 1;  //! <Type Comment="Is only queried when ControllerOn is set to 0." Name="CntrFlgs.Test"/>
    long NoActpos : 1;  //! <Type Comment="The Client &quot;iActPosition&quot; is not connected" Name="CntrFlgs.NoActpos"/>
    long Overflow : 1;  //! <Type Comment="The axis has an internal position overflow." Name="CntrFlgs.Overflow"/>
    long NoControl : 1;  //! <Type Comment="The axis is not connected to a controller and the CNC therefore operates as a profile generator only." Name="CntrFlgs.NoControl"/>
    long ModuloFlg : 1;  //! <Type Comment="The axis is defined as a modulo axis." Name="CntrFlgs.ModuloFlg"/>
    long NoActPosMeth : 1;  //! <Type Comment="The &quot;iActPosition&quot; client is not connected to a server (axis operates without posi-tion feedback)." Name="CntrFlgs.NoActPosMeth"/>
    long NoRefMeth : 1;  //! <Type Comment="The &quot;iRefChannal&quot; is not connected" Name="CntrFlgs.NoRefMeth"/>
    long NoControlMeth : 1;  //! <Type Comment="The &quot;oSignalchannal&quot; client is not connected" Name="CntrFlgs.NoControlMeth"/>
    long NoSpecial : 1;  //! <Type Comment="The &quot;oPrecyclictrigger&quot; client is not connected" Name="CntrFlgs.NoSpecial"/>
    long NCMotion : 1;  //! <Type Comment="The CNC class is operated in NC mode" Name="CntrFlgs.NCMotion"/>
    long NoActPosChk : 1;
  }CntrFlgs;

#pragma pack(push, 1)
typedef struct CntrStr 
  {
    DINT MinutsOfRunning;
    DINT NbrOfPackets;
  } CntrStr;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct DataMachineStr 
  {
    DINT LineSpeed;
    DINT TraysPerMinute;
    DINT TrayLenght;
  } DataMachineStr;
#pragma pack(pop)

typedef struct DataRecipeStr 
  {
    CHAR Name [39+1-0];
    DataMachineStr Machine;
  } DataRecipeStr;

#pragma pack(push, 1)
typedef struct DateTime 
  {
    UDINT Year;
    UDINT Month;
    UDINT Day;
    UDINT Hour;
    UDINT Minute;
    CHAR Str [20+1-0];
  } DateTime;
#pragma pack(pop)

typedef struct DatumEnTijd 
  {
    UINT Year;
    USINT Month;
    USINT Day;
    USINT Hour;
    USINT Minute;
    USINT Second;
  } DatumEnTijd;

typedef UDINT DM_CPU_Types; 
    #define CPUNotIdentified 0
    #define IPC_Text_CPU 1
    #define IPC_800_CPU 2
    #define IPC_1024_CPU 3
    #define PCD_CPU 4
    #define DSE_CPU 5
    #define DCP_CPU 6
    #define DCC080_CPU 7
    #define DCP645_CPU 8
    #define AK500_CPU 9
    #define TSTROM_CPU 10
    #define NoCPU_11 11
    #define NoCPU_12 12
    #define NoCPU_13 13
    #define NoCPU_14 14
    #define NoCPU_15 15
    #define ELAN_CPU 16
    #define ELAN800_CPU 17
    #define WINPC_CPU 18
    #define TERMINAL_CPU 19
    #define DTC281_CPU 20
    #define ELAN_TEXT_CPU 21
    #define ELAN_800_CPU 22
    #define ETT321_CPU 23
    #define HERZ_CPU 24
    #define ETT261_CPU 25
    #define ETT431_CPU 26
    #define WIN_PC98_CPU 27
    #define WINPC_NT_CPU 28
    #define WINIPC_98_CPU 29
    #define WINIPC_NT_CPU 30
    #define IPC_320_CPU 31
    #define C_IPC_CPU 32
    #define NoCPU_33 33
    #define RK500_CPU 34
    #define CCL721_CPU 35
    #define CCL911_CPU 36
    #define BDF2000_CPU 37
    #define StandardPC_CPU 38
    #define CCL081CET_CPU 39
    #define CCL081_CPU 40
    #define CCL722_CPU 41
    #define DCL642_CPU 42
    #define Teachbox_CPU 43
    #define DTC081_CPU 44
    #define DTC081_IP_CPU 45
    #define ETV_CPU 46
    #define HZS511_CPU 47
    #define AUW11X_CPU 48
    #define BDF2000_USB_CPU 49
    #define DTC101_CPU 50
    #define HZS515_CPU 51
    #define CCP511_CPU 52
    #define ETVEDGE_CPU 53
    #define ARM_IMX6_CPU 65537

typedef UDINT EventModeTxt; 
    #define Event01Log 0
    #define Event1xLog 1
    #define TraceLog 2

typedef UDINT eVisionStatus; 
    #define eNoVisionInp 0
    #define eVisionOK 1
    #define eVisionNotOK 2

typedef UDINT eWeightStatus; 
    #define eNoWeightInp 0
    #define eWeightOK 1
    #define eWeightNotOK 2

typedef UDINT OptiesEnum; 
    #define NietActief 0
    #define Actief 1

typedef UDINT RunningStateEnum; 
    #define eStopStatus 0
    #define eStartUpStatus 1
    #define eRunStatus 2
    #define eErrorStatus 3
    #define eNoodstop 4
    #define ePauseStatus 5
    #define eCleaningStatus 6
    #define eDriveOffStatus 7
    #define eLockStatus 8
    #define eNoodstopStatus 9

#pragma pack(push, 1)
typedef struct GlobalDataStr 
  {
    struct gGeneralData 
    {
      DINT iDrivesOK;
      DINT iDrivesEnabled;
      DINT iNoodstopOk;
      DINT iExternrelease;
      DINT iJogCleaning;
      DINT CleaningJogDistance;
      DINT PauzeOverride;
      DINT NoError;
      DINT CleaningMode;
      DINT CleaningSpeed;
      DINT CleaningAccDec;
      OptiesEnum CleaningJogOption;
      DINT CleaningJog;
      DINT oResetSignal;
      DINT oMachineOK;
      DINT LineSpeed;
      DINT cleaningOverrule;
    } gGeneralData;
    struct gRunStatus 
    {
      RunningStateEnum gRunStatusGlob;
      RunningStateEnum gRunStatusInfeedBelt;
      RunningStateEnum gRunStatusRobot;
      RunningStateEnum gRunStatusStrokeConveyor;
    } gRunStatus;
    DINT StructItem1;
    DINT StructItem2;
    DINT StructItem3;
    DINT StructItem4;
    DINT StructItem5;
    DINT StructItem6;
    DINT StructItem7;
    DINT StructItem8;
    DINT StructItem9;
    DINT StructItem10;
    DINT StructItem11;
    DINT StructItem12;
  } GlobalDataStr;
#pragma pack(pop)

typedef CntrStr HourCntrStr [24+1-0];

#pragma pack(push, 1)
typedef struct ImpClkStr 
  {
    DINT _Imp10mSec;
    DINT _Imp100mSec;
    DINT _Imp500mSec;
    DINT _Imp1Sec;
    DINT _Imp10Sec;
    DINT _Clk10mSec;
    DINT _Clk100mSec;
    DINT _Clk500mSec;
    DINT _Clk1Sec;
    DINT _Clk10Sec;
  } ImpClkStr;
#pragma pack(pop)

typedef UDINT InvoluteOrbitalENUM; 
    #define Involute 0
    #define Orbital 1

typedef struct   //! <Type Comment="Status Flag für IO Daten" Name="IO_FLAG"/>
  {
    short WrongHW : 1;  //! <Type Comment="Falsche Hardware verbunden" Name="IO_FLAG.WrongHW"/>
    short NoHW : 1;  //! <Type Comment="Keine Hardware verbunden" Name="IO_FLAG.NoHW"/>
    short NoCalibration : 1;  //! <Type Comment="Keine Kalibrierungsdaten im Modul-EEPROM" Name="IO_FLAG.NoCalibration"/>
    short ParaChkWrong : 1;  //! <Type Comment="Die Parameter-Checksumme ist falsch" Name="IO_FLAG.ParaChkWrong"/>
    short PhysicHiLimit : 1;  //! <Type Comment="IO ist am oberen physikalischen Limit" Name="IO_FLAG.PhysicHiLimit"/>
    short PhysicLoLimit : 1;  //! <Type Comment="IO ist am unteren physikalischen Limit" Name="IO_FLAG.PhysicLoLimit"/>
    short Invert : 1;  //! <Type Comment="Daten sind invertiert" Name="IO_FLAG.Invert"/>
    short dummy0 : 6;
    short OnDummyMode : 1;  //! <Type Comment="1 = Objekt ist im Dummymodus (nicht refreshed)" Name="IO_FLAG.OnDummyMode"/>
    short NotConnected : 1;  //! <Type Comment="1 = Objekt ist nicht verbunden" Name="IO_FLAG.NotConnected"/>
    short PhysicAccessOff : 1;  //! <Type Comment="1 = kein physikalischer Zugriff erlaubt" Name="IO_FLAG.PhysicAccessOff"/>
  }IO_FLAG;

#pragma pack(push, 1)
typedef struct IO_State 
  {
    IO_FLAG uiIO_Flags;
    UINT uiChNo;
  } IO_State;
#pragma pack(pop)

typedef CHAR IpAdrStr [15+1-0];

#pragma pack(push, 1)
typedef struct LogRecStr 
  {
    DINT Stepper;
    UDINT tElapsTime;
    UDINT tOpsTime;
  } LogRecStr;
#pragma pack(pop)

typedef struct 
  {
    long WDayB0 : 1;
    long WDayB1 : 1;
    long WDayB2 : 1;
    long WDayB3 : 1;
    long DayB0 : 1;
    long DayB1 : 1;
    long DayB2 : 1;
    long DayB3 : 1;
    long DayB4 : 1;
    long DayB5 : 1;
    long DayB6 : 1;
    long DayB7 : 1;
    long MonB0 : 1;
    long MonB1 : 1;
    long MonB2 : 1;
    long MonB3 : 1;
    long YearB0 : 1;
    long YearB1 : 1;
    long YearB2 : 1;
    long YearB3 : 1;
    long YearB4 : 1;
    long YearB5 : 1;
    long YearB6 : 1;
    long YearB7 : 1;
    long YearB8 : 1;
    long YearB9 : 1;
    long YearB10 : 1;
    long YearB11 : 1;
    long YearB12 : 1;
    long YearB13 : 1;
    long YearB14 : 1;
    long YearB15 : 1;
  }LseDateStr;

typedef struct 
  {
    long dummy0 : 8;
    long SecB0 : 1;
    long SecB1 : 1;
    long SecB2 : 1;
    long SecB3 : 1;
    long SecB4 : 1;
    long SecB5 : 1;
    long SecB6 : 1;
    long SecB7 : 1;
    long MinB0 : 1;
    long MinB1 : 1;
    long MinB2 : 1;
    long MinB3 : 1;
    long MinB4 : 1;
    long MinB5 : 1;
    long MinB6 : 1;
    long MinB7 : 1;
    long HourB0 : 1;
    long HourB1 : 1;
    long HourB2 : 1;
    long HourB3 : 1;
    long HourB4 : 1;
    long HourB5 : 1;
    long HourB6 : 1;
    long HourB7 : 1;
  }LseTimeStr;

typedef struct MasterStruct   //! <Type Comment="Pointers to the master axis data" Name="MasterStruct"/>
  {
    DINT *pos;  //! <Type Comment="Pointer to the master axis position [internal units]" Name="MasterStruct.pos"/>
    DINT *Speed;  //! <Type Comment="Pointer to the master axis speed [internal units / tick]" Name="MasterStruct.Speed"/>
    DINT *ModuloMaster;  //! <Type Comment="Pointer to ModuloInt of master axis [internal units]" Name="MasterStruct.ModuloMaster"/>
    pVoid PosLREAL;  //! <Type Comment="pointer to a LREAL value cointainig the master position [internal units]&#13;&#10;(this pointer is set and used only by _LMCAxis objects with MoveType=_JERK_PROFILE)" Name="MasterStruct.PosLREAL"/>
    pVoid SpeedLREAL;  //! <Type Comment="pointer to a LREAL value cointainig the master speed [internal units /tick]&#13;&#10;(this pointer is set and used only by _LMCAxis objects with MoveType=_JERK_PROFILE)" Name="MasterStruct.SpeedLREAL"/>
    pVoid pMasterThis;  //! <Type Comment="pointer to the _LMCAxis master object" Name="MasterStruct.pMasterThis"/>
  } MasterStruct;

typedef UDINT ProfileCommandStatus; 
    #define PassiveProfile 0
    #define IdleProfile 1
    #define RunProfile 2
    #define EndProfile 3
    #define ErrorProfile 4
    #define IdleProfileRestart 5
    #define WaitProfileRestart 6
    #define WaitProfileForAxInPos 7

typedef struct RecipeStr 
  {
    CHAR Name [39+1-0];
  } RecipeStr;

#pragma pack(push, 1)
typedef struct RobotPosStr 
  {
    DINT Xpos;
    DINT Ypos;
    DINT Zpos;
    DINT Rpos;
  } RobotPosStr;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct ScoopChanDataStr 
  {
    _KOORD *pScoopData;
    _COLOR Color;
  } ScoopChanDataStr;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct ScoopGenDataStr 
  {
    DINT TrigerFl;
    DINT AxisXY;
    DINT AxisDir;
    DINT MaxOverScale;
    _KOORD PixMaxLengthX;
    _KOORD PixMaxLengthY;
    _KOORD PixNulX;
    _KOORD PixNulY;
    UDINT ScrollArraySize;
  } ScoopGenDataStr;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct StepLogStr 
  {
    DINT Nr;  //! <Type Comment="Array offset for the next step.&#13;&#10;So this is the oldest step number in the FIFO." Name="StepLogStr.Nr"/>
    LogRecStr Logger [cSCbMaxLogArray+1-0];  //! <Type Comment="Step numbers in sequance." Name="StepLogStr.Logger"/>
  } StepLogStr;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct StepperDataStr 
  {
    DINT First;  //! <Type Comment="First time in this step." Name="StepperDataStr.First"/>
    UDINT tTime;  //! <Type Comment="Time this step is active in mSec." Name="StepperDataStr.tTime"/>
    StepLogStr StepLog;  //! <Type Comment="Step numbers in sequance of excecution." Name="StepperDataStr.StepLog"/>
    DINT StepperOld;  //! <Type Comment="Internal, Old stepper value." Name="StepperDataStr.StepperOld"/>
    UDINT tMark;  //! <Type Comment="Internal, Ops.tAbsolute time when step was enterd for the first time." Name="StepperDataStr.tMark"/>
    DINT OerInit;  //! <Type Comment="Internal, Detection this function is called for the first time." Name="StepperDataStr.OerInit"/>
    LogRecStr *pActLog;
  } StepperDataStr;
#pragma pack(pop)

typedef UDINT StringDateTxt; 
    #define DateMode_YYYYMMDD 0
    #define DateMode_YYMMDD 1
    #define DateMode_DD_MM_YYYY 2
    #define DateMode_DD_MM_YY 3
    #define DateMode_D_M_jjjY 4
    #define DateMode_D_M_jY 5

typedef UDINT StringTimeTxt; 
    #define TimeMode_HHMMSS 0
    #define TimeMode_HH_MM_SS 1
    #define TimeMode_HH_MM_SS_PMAM 2
    #define TimeMode_HMS 3
    #define TimeMode_HMS_PMAM 4

typedef UDINT t_e_OPMode;   //! <Type Comment="Reihenfolge der Enumeration darf nicht verändert werden!" Name="t_e_OPMode"/>
    #define OPMode_Init 0
    #define OPMode_Homing 1
    #define OPMode_Stop 2
    #define OPMode_Setup 3
    #define OPMode_Manual 4
    #define OPMode_SemiAuto 5
    #define OPMode_Automatic 6
    #define OPMode_Error 7
    #define OPMode_ChangeMode 8

#pragma pack(push, 1)
typedef struct WeightingStr 
  {
    DINT Offset1Min;
    DINT Offste2Min;
    DINT TargetWeight;
    DINT Offset1Plus;
    DINT Offset2Plus;
    DINT GainZone1;
    DINT GainZone2;
    DINT GainZone3;
    DINT GainZone4;
    DINT GainZone5;
    DINT GainZone6;
    DINT cwGain;
    DINT GewRegelMin;
    DINT SpareW02;
    DINT SpareW01;
    DINT ContrWeightingFB;
    DINT MeasuredCwPacket;
    DINT GewRegelMax;
    DINT DoorlopendGem;
  } WeightingStr;
#pragma pack(pop)

